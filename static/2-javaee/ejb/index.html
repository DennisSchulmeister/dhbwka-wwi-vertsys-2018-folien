 <!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <title>Enterprise Java Beans</title>

        <link rel="shortcut icon" href="../../favicon.svg" />
        <link rel="stylesheet" href="../../style.css" />
        <script src="../../learning-slides.bundle.js"></script>
    </head>
    <body class="slides invisible" data-title="Enterprise Java Beans" tabindex="0">
        <header>
            <h2>Inhaltsverzeichnis</h2>
            <p class="deprecation-note">
                Diese Unterlagen werden nicht mehr weiter entwickelt, da die
                Vorlesung ab 2020 mit neuem Konzept neu startet.
            </p>
            <p>
                Endlich wieder Programmieren. üíª An dieser Stelle kehren wir noch einmal
                zu letztem Semester zur√ºck und vertiefen die Entwicklung serverseitiger
                Webanwendungen mit der Jakarta Enterprise Edition.
            </p>
        </header>

        <!--
            ========================
            LERNZIELE DIESER EINHEIT
            ========================
        -->
        <section data-chapter data-background-color="rgb(210,190,210)">
            <h1>Lernziele dieser Einheit</h1>
            <article>
                <h3>Nach Abschluss dieser Einheit kannst du ‚Ä¶</h3>
                <ul>
                    <li>
                        erkl√§ren, was die <span class="dhbw-lightblue font-weight-bold">Jakarta Enterprise Edition</span>¬π
                        (kurz JEE) ist und wie sie mit Java zusammenh√§ngt.
                    </li>
                    <li>
                        die wichtigsten, <span class="dhbw-lightblue font-weight-bold">√ºber eine einfache Middleware
                        hinausgehenden Dienste</span> von Jakarta&nbsp;EE benennen.
                    </li>
                    <li>
                        aufzeigen, mit welchen <span class="dhbw-lightblue font-weight-bold">Schnittstellentechnologien</span>
                        Jakarta&nbsp;EE in eine IT-Landschaft integrieren werden kann.
                    </li>
                    <li>
                        die wichtigsten <span class="dhbw-lightblue font-weight-bold">APIs</span> zur Programmierung mit
                        der Jakarta Enterprise Edition aufz√§hlen.
                    </li>
                    <li>
                        erkl√§ren, wie eine Java-Webanwendung nach <span class="dhbw-lightblue font-weight-bold">Model-View-Controller</span>
                        gegliedert werden kann.
                    </li>
                    <li>
                        eine minimale Webanwendung nach dem MVC-Prinzip programmieren.
                    </li>
                    <li>
                        die Vor- und Nachteile der verschiedenen Arten von <span class="dhbw-lightblue font-weight-bold">Enterprise
                        Java Beans</span> gegeneinander abw√§gen.
                    </li>
                    <li>
                        entscheiden, wann eine Enterprise Java Bean ein <span class="dhbw-lightblue font-weight-bold">Local Interface</span>,
                        ein <span class="dhbw-lightblue font-weight-bold">Remote Interface</span> oder keines davon ben√∂tigt.
                    </li>
                </ul>
                <p>
                    <small>
                        ¬π Fr√ºher hie√ü das Projekt ‚ÄûJava Enterprise Edition‚Äù und wurde von Oracle vorangetrieben.
                        Seit der √úbergabe an die Eclipse Foundation im Jahr 2018 wurde es in ‚ÄûJakarta Enterprise Edition‚Äù umbenannt.
                    </small>
                </p>
                <span style="font-size: 240px; color: white;" class="dhbw-text-shadow" >üèÅ</span>
            </article>
            <aside>
                <p>
                    Ohne Zweifel handelt es sich beim World Wide Web um die gr√∂√üte verteilte Anwendung √ºberhaupt.
                    Was liegt also n√§her, als sich in der Vorlesung ‚ÄûVerteilte Systeme‚Äù nochmal damit auseinanderzusetzen
                    und die Dinge abzuschlie√üen, die wir letztes Semester begonnen haben? Beginnen werden wir daher mit
                    einem kurzen √úberblick √ºber die <b>Jakarta Enterprise Edition</b>, die uns als echte anwendungsorientierte
                    Middleware gleich eine Vielzahl an <b>Applikationsservern</b> zur Verf√ºgung stellt. üéÅ Wir werden dabei
                    sehen, was die Jakarta Enterprise Edition genau ist und welche <b>APIs und Funktionen</b> sie beinhaltet.
                    Auch werden wir sehen, wie so ein Anwendungsserver aufgebaut ist und was er au√üer Servlets und JSP noch
                    alles so kann.
                </p>
                <p>
                    Mit diesem Wissen tasten wir uns dann zu <b>Model-View-Controller</b> vor und lernen, wie eine
                    Webanwendung mit Java sinnvoll aufgebaut wird. F√ºr einen kurzen Augenblick werden wir daher
                    zu den guten alten <b>Servlets und Java Server Pages</b> zur√ºckkehren und zeigen, dass diese erst
                    durch <b>Enterprise Java Beans</b> und <b>Persistence Entities</b> wirklich komplett sind.
                </p>
                <p>
                    Von Datenbankzugriffen einmal abgesehen¬π wei√üt du an dieser Stelle üéå dann auch schon alles, was du
                    f√ºr die Entwicklung serverseitiger Webanwendungen in Java brauchst. Abschlie√üen werden wir die Einheit
                    daher mit einem tieferen Blick auf Enterprise Java Beans, da diese auch f√ºr Nicht-Webanwendungen und
                    damit f√ºr die weitere Vorlesung ganz interessant sind.
                </p>
                <p>
                    <small>
                        ¬π Diese schauen wir uns im n√§chsten Foliensatz separat an.
                    </small>
                </p>
            </aside>
        </section>

        <!--
            ====================
            Jakarta&nbsp;EE IM √úBERBLICK
            ====================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Jakarta&nbsp;EE im √úberblick</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Was ist die Jakarta Enterprise Edition?</h1>
            <article>
                <img src="appserver-schnittstellen.png" alt="Grober Aufbau eines Java-Applikationsservers" class="d-block" style="width: 100%; margin-bottom: 1em;" />
                <p>
                    Die Jakarta Enterprise Edition ist ein offener Standard f√ºr javabasierte Anwendungsserver.
                    Diese werden von unterschiedlichen Herstellern angeboten:
                </p>
                <ul>
                    <li>
                        <a href="https://tomee.apache.org" target="_blank">Apache TomEE</a>
                    </li>
                    <li>
                        <a href="https://javaee.github.io/glassfish/" target="_blank">Oracle Glassfish</a>
                    </li>
                    <li>
                        <a href="http://www.wildfly.org/" target="_blank">RedHat Wildfly</a>
                    </li>
                    <li>
                        ‚Ä¶
                    </li>
                </ul>
                <p>
                    Jeder Anwendungsserver besitzt dabei einen <b>Webcontainer</b> zur Bereitstellung von Webinhalten sowie eine
                    <b>EJB-Container</b> zur Ausf√ºhrung der fachlichen Anwendungsklassen. Dar√ºber hinaus bietet er viele eingebaute
                    Zusatzfunktionen:
                </p>
                <ul>
                    <li>
                        Verschiedene Arten der Benutzerverwaltung (Datenbankbasiert, LDAP, ‚Ä¶)
                    </li>
                    <li>
                        Ein rollenbasiertes Berechtigungskonzept
                    </li>
                    <li>
                        Einen <a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">O/R-Mapper</a> f√ºr Datenbankzugriffe
                    </li>
                    <li>
                        Die M√∂glichkeit, Nachrichten an einen Message Broker zu senden
                    </li>
                    <li>
                        Eine API zum Versand von E-Mails
                    </li>
                    <li>
                        Einen Timer zur Einplanung von Hintergrundaktivit√§ten
                    </li>
                    <li>
                        Und noch vieles, vieles mehr üå†
                    </li>
                </ul>
            </article>
            <aside>
                <p>
                    Letztes Semester haben wir schon gesehen, dass es <a href="../../../webprog/4-server/http_jsp_servlets/#10">mehrere M√∂glichkeiten</a> gibt,
                    den Serverteil einer Webanwendung in Java zu entwickeln. Der klassische Ansatz besteht darin, einen Webcontainer (Applikationsserver)
                    zu verwenden und die Anwendung in Form eines Webarchivs üì¶ in diesem zum Laufen zu bringen. Dies hat den Vorteil, dass man sich keine
                    Gedanken √ºber die ‚ÄûInfrastruktur‚Äù machen muss, da diese durch den Server bereits gegeben ist.¬π Zus√§tzlich kann man innerhalb des Servers
                    noch weitere Webanwendungen ausf√ºhren und somit ein gro√ües Webprojekt in kleine, √ºbersichtliche Teilanwendungen zerlegen. Was wir dabei
                    noch nicht so sehr betont haben ist, dass Webcontainer zur ‚ÄûJakarta Enterprise Edition‚Äù (bis 2018 ‚ÄûJava Enterprise Edition‚Äù) geh√∂ren,
                    die ganz allgemein darauf abzielt, Client/Server-Anwendungen im Unternehmensumfeld zu entwickeln.
                </p>
                <p>
                    <small>
                        ¬π Microservices hingegen gehen oft nach dem Prinzip ‚ÄûPut a Webserver In Your Application" bzw. ‚ÄûBring Your Own Webserver‚Äù
                        vor. Sie verschmelzen quasi Webanwendung und Server in einem Javaprogramm, das dann wie andere Javaprogramme direkt gestartet
                        werden kann. In diesem Fall werden meistens andere APIs als die der Jakarta Enterprise Edition genutzt (zum Beispiel
                        <a href="https://spring.io/projects/spring-boot" target="_blank">Spring Boot</a>).
                    </small>
                </p>
                <p>
                    Da das normale Java in seiner Langform ‚ÄûJava Standard Edition‚Äù (Java SE) hei√üt, k√∂nnte man auf die Idee kommen, dass die
                    Standard Edition eine Art kleines Java f√ºr den Desktop üêÅ und die Enterprise Edition ein gro√ües Java f√ºr den Server sei. üêò
                    Tats√§chlich ist das aber nicht so. Java&nbsp;SE ist stattdessen einfach die Programmiersprache selbst, die wirklich immer
                    ben√∂tigt wird, und Jakarta&nbsp;EE eine Sammlung zus√§tzlicher APIs¬≤ zur Entwicklung datenbankbasierter Webanwendungen und
                    Informationssysteme. Es handelt sich daher ‚Äûnur‚Äù um eine Erweiterung der Java-Klassenbibliothek und nicht der Sprache selbst. üí¨
                </p>
                <p>
                    <small>
                        ¬≤ API = Application Programming Interface. Gemeint sind zus√§tzliche Interfaces, Klassen und Methoden, die nicht zum
                        Standardumfang von Java geh√∂ren.
                    </small>
                </p>
                <p>
                    Um die Verwirrung dar√ºber hinaus noch komplett zu machen, gibt es gar keine Jakarta Enterprise Edition. die man einfach herunterladen
                    und installieren k√∂nnte. Denn, wie f√ºr Java typisch, handelt es sich dabei nur um eine Spezifikation, die von der
                    <a href="https://jakarta.ee/about/" target="_blank">Jakarta&nbsp;EE Working Group</a> als offener Standard
                    entwickelt wird und zu der es viele Implementierungen verschiedener Hersteller gibt. An dieser Stelle kommen dann auch die
                    Applikationsserver ins Spiel, da sie die Spezifikation umsetzen. Produkte wie
                    <a href="https://tomee.apache.org" target="_blank">Apache TomEE</a>,
                    <a href="https://javaee.github.io/glassfish/" target="_blank">Oracle Glassfish</a> oder
                    <a href="http://www.wildfly.org/" target="_blank">RedHat Wildfly</a>
                    sind also alles Implementierungen der Jakarta Enterprise Edition, die jeweils in Form eines eigenen Anwendungsservers daher kommen.
                    Sie alle k√∂nnen daher wie folgt genutzt werden:
                </p>
                <ul>
                    <li>
                        Als <b>Webserver</b> zur Entwicklung javabasierter Webanwendungen
                    </li>
                    <li>
                        Als <b>Backend-Server</b> f√ºr beliebige, verteilte Anwendungen, auch wenn diese keine Weboberfl√§che besitzen
                    </li>
                </ul>
                <p>
                    Denn neben einer reinen HTTP-Schnittstelle f√ºr Servlets haben sie noch folgende Technologien an Board üö¢, um eine m√∂glichst breite
                    Konnektivit√§t mit anderen Anwendungsservern und unterschiedlichsten Clients herzustellen. Sie erm√∂glichen es, die fachlichen
                    Klassen einer Anwendung auf folgende Arten aufzurufen:
                </p>
                <ul>
                    <li>
                        Per entferntem Methodenaufruf
                    </li>
                    <li>
                        Als SOAP-Webservice
                    </li>
                    <li>
                        Als REST-Webservice
                    </li>
                    <li>
                        Als Nachrichtenempf√§nger √ºber einen Message Broker
                    </li>
                </ul>
                <p>
                    Zus√§tzlich stellen sie, da es sich ja um eine anwendungsorientierte Middleware handelt, noch folgende Zusatzfunktionen zur
                    Verf√ºgung, auf die wir beim Programmieren zugreifen k√∂nnen:
                </p>
                <ul>
                    <li>
                        Verschiedene Arten der Benutzerverwaltung (Datenbankbasiert, LDAP, ‚Ä¶)
                    </li>
                    <li>
                        Ein rollenbasiertes Berechtigungskonzept
                    </li>
                    <li>
                        Einen <a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">O/R-Mapper</a> f√ºr Datenbankzugriffe
                    </li>
                    <li>
                        Die M√∂glichkeit, Nachrichten an einen Message Broker zu senden
                    </li>
                    <li>
                        Eine API zum Versand von E-Mails
                    </li>
                    <li>
                        Einen Timer zur Einplanung von Hintergrundaktivit√§ten
                    </li>
                    <li>
                        Und noch vieles, vieles mehr üå†
                    </li>
                </ul>
                <p>
                    Tats√§chlich also alles was das Herz begehrt üíñ, was die Jakarta Enterprise Edition gleichzeitig aber auch sehr gro√ü
                    und leider auch ressourcenhungrig macht.
                </p>
            </aside>
        </section>

        <section>
            <h1>Aufbau eines Applikationsservers</h1>
            <article>
                <div class="container-fluid">
                    <div class="row">
                        <div class="col-md">
                            <img src="appserver-aufbau.png" alt="Interne Bestandteile eines Java-Applikationsservers" class="d-block" style="width: 100%; margin-bottom: 2em;" />
                        </div>
                    </div>

                    <!-- Webprogrammierung -->
                    <div class="row">
                        <div class="col-md">
                            <h2>Webprogrammierung</h2>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-12">
                            <h4>Servlets</h4>
                            Grundlegende Klassenbibliothek zur Reaktion auf HTTP-Anfragen. Es handelt sich dabei um
                            die Basistechnologie, die allen h√∂heren Webframeworks f√ºr Jakarta&nbsp;EE zugrunde liegt.
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6">
                            <h4>Java Server Pages</h4>
                            Serverseitige Erweiterung von HTML. Erlaubt es, den HTML-Code dynamisch auf dem Server
                            zu erzeugen, bevor er an den Browser geschickt wird.
                        </div>
                        <div class="col-md-6">
                            <h4>Java Server Faces</h4>
                            Von Oracle entwickeltes, mit Jakarta&nbsp;EE ausgeliefertes Webframework. Nutzt eine an HTML
                            angelehnte Beschreibungssprache zur Definition des Layouts.
                        </div>
                    </div>

                    <!-- Anwendungslogik -->
                    <div class="row">
                        <div class="col-md">
                            <h2>Anwendungslogik</h2>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6">
                            <h4>Enterprise Java Beans</h4>
                            Spezielle Laufzeitumgebung f√ºr die fachlichen Klassen einer Anwendung. Sie erm√∂glichen es,
                            Services zu definieren, die von lokalen und entfernten Clients genutzt werden k√∂nnen.
                        </div>
                        <div class="col-md-6">
                            <h4>Java Database Connection</h4>
                            Allgemeine Klassenbibliothek f√ºr den Zugriff auf SQL-Datenbanken. Sie bildet die Grundlage
                            f√ºr JPA und JTA und wird heutzutage selten direkt genutzt.
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6">
                            <h4>Java Persistence API</h4>
                            O/R-Mapper zur Vereinfachung des Datenbankzugriffes. Die Felder einer Tabelle werden
                            automatisch auf die Attribute einer Java-Bean gemappt.
                        </div>
                        <div class="col-md-6">
                            <h4>Java Transaction API</h4>
                            Framework f√ºr von der Datenbank unabh√§ngige, verteilte Transaktionen.
                        </div>
                    </div>

                    <!-- Schnittstellen -->
                    <div class="row">
                        <div class="col-md">
                            <h2>Schnittstellen</h2>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6">
                            <h4>Java API for XML-Webservices</h4>
                            Klassenbibliothek zum Erstellen und Aufrufen von SOAP-Webservices.
                        </div>
                        <div class="col-md-6">
                            <h4>Java API for REST-Webservices</h4>
                            Klassenbibliothek zum Erstellen und Aufrufen von REST-Webservices.
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6">
                            <h4>Java Message Services</h4>
                            Klassenbibliothek f√ºr den Zugriff auf einen Message Broker.
                        </div>
                        <div class="col-md-6">
                            <h4>Java Mail API</h4>
                            Hilfsklassen zum Versenden von E-Mails.
                        </div>
                    </div>

                    <!-- Sonstiges -->
                    <div class="row">
                        <div class="col-md">
                            <h2>Sonstiges</h2>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md">
                            <h4>Java Authentication &amp; Authorization Service</h4>
                            Rollenbasierte Benutzer- und Berechtigungsverwaltung. Erlaubt es, die Benutzer entweder in einer
                            Datenbanktabelle abzulegen oder auf externe Provider, wie zum Beispiel LDAP-Verzeichnisse,
                            zuzugreifen.
                        </div>
                    </div>
                </div>

            </article>
            <aside>
                <p>
                    Ein einfachsten l√§sst sich der Aufbau eines Anwendungsservers verstehen, indem man sich vor Augen h√§lt,
                    dass es sich dabei im Grunde genommen um nichts anderes als ein gew√∂hnliches Javaprogramm handelt,
                    das zwar schon sehr viele Funktionen enth√§lt, von sich aus aber noch gar nichts n√ºtzliches macht. üõãÔ∏è
                    Als Programmierer muss man dem Programm erst noch durch Hinzuf√ºgen eigener Klassen die gew√ºnschten
                    Funktionen beibringen. Das ist in etwa, was mit folgenden Begriffen gemeint ist:
                </p>
                <dl>
                    <dt>
                        Softwarekomponente
                    </dt>
                    <dd>
                        <p>
                            Manche Quellen sprechen im Zusammenhang mit Jakarta&nbsp;EE von einer komponentenbasierten Architektur
                            und nennen die zu erstellenden Klassen auch Softwarekomponenten. Damit soll zum Ausdruck gebracht werden,
                            dass jede Klasse folgende Eigenschaften erf√ºllen muss:
                        </p>
                        <ul>
                            <li>
                                <b>In sich geschlossen:</b> Die Klasse soll einen funktionalen Teilbereich der Anwendung
                                abdecken und alle hierf√ºr ben√∂tigten Methoden enthalten.
                            </li>
                            <li>
                                <b>Nur lose gekoppelt:</b> Die Klasse sollte so wenig wie m√∂glich von den anderen Klassen
                                der Anwendung abh√§ngen. Idealerweise ist jede Klasse f√ºr sich genommen alleine lauff√§hig.
                            </li>
                            <li>
                                <b>Wiederverwendbar:</b> Die Klasse soll m√∂glichst allgemeing√ºltig gehalten werden, so
                                dass sie auch in anderen Anwendungen mit √§hnlichen Anforderungen einsetzbar ist.
                            </li>
                            <li>
                                <b>Austauschbar:</b> Die Methoden der Klasse sollen in einem von der Klasse getrennten
                                Interface definiert werden und alle Verwender der Klasse sollen nur gegen das Interface
                                programmiert werden. Somit kann die implementierende Klasse sp√§ter jederzeit ersetzt werden.
                            </li>
                        </ul>
                    </dd>

                    <dt>
                        Container
                    </dt>
                    <dd>
                        <p>
                            Softwarekomponenten ben√∂tigen immer eine Laufzeitumgebung (auch Container genannt), innerhalb derer sie
                            ausgef√ºhrt werden. Der Container k√ºmmert sich hierf√ºr mindestens um die Erzeugung der Objektinstanzen,
                            kann aber auch weitere Dinge vorschreiben, wie dass eine Klasse ein bestimmtes Interface implementieren,
                            bestimmte Methoden beinhalten oder bestimmte Annotationen verwenden muss. Dadurch wird der Container in
                            die Lage versetzt, zum richtigen Zeitpunkt die ben√∂tigten Objekte zu erzeugen und aufzurufen.
                        </p>
                    </dd>

                    <dt>
                        Deployment
                    </dt>
                    <dd>
                        <p>
                            Dies ist der Vorgang, bei dem alle Klassen einer Anwendung zu einem Archiv verpackt und dem Server
                            zur Verf√ºgung gestellt werden. Hierf√ºr muss das Archiv, das nat√ºrlich einen vorgeschriebenen Aufbau
                            besitzen muss, in aller Regel nur in ein hierf√ºr vorgesehenes Deployment-Verzeichnis kopiert werden,
                            damit der Server es findet.
                        </p>
                    </dd>
                </dl>

                <p>
                    Die selbst zu entwickelnden Klassen lassen sich wiederum in folgende Kategorien einteilen:
                </p>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td>
                            üåç
                        </td>
                        <td>
                            <b>Servlets und JSP</b> laufen innerhalb des Webcontainers und dienen dazu, auf HTTP-Anfragen zu reagieren
                            bzw. eine Weboberfl√§che zu entwickeln.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            ‚öôÔ∏è
                        </td>
                        <td>
                            <b>Enterprise Java Beans</b> wiederum kapseln die fachliche Logik der Anwendung, unabh√§ngig davon, wie
                            die Funktionen in der Benutzeroberfl√§che aussehen werden. Mit Hilfe von EJBs werden daher einfach nur
                            Services definiert, die von den verschiedenen Clients aufgerufen werden k√∂nnen. Technisch geshen wird
                            dabei zwischen <b>Stateless Session Beans</b>, <b>Stateful Session Beans</b> und <b>Message Driven Beans</b>
                            unterschieden. Was das ist schauen wir uns allerdings erst weiter hinten an.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            üõ¢
                        </td>
                        <td>
                            <b>Persistence Entities</b> dienen schlie√ülich dem Lesen und Schreiben von Daten in einer Datenbank.
                            Die Entities sind hierf√ºr als gew√∂hnliche Javabeans definiert, deren Objekte immer einer Zeile in
                            einer Tabelle entsprechen.
                        </td>
                    </tr>
                </table>
                <p>
                    Das Grobger√ºst einer Java-Enterprise-Anwendung k√∂nnte daher so aussehen:
                </p>
                <source-code language="java">
                    // Servlet
                    // Geh√∂rt zur Weboberfl√§che der Anwendung
                    public class ShoppingCartServlet extends HttpServlet {
                        @EJB
                        private ShoppingCartBean shoppingCart;

                        public void doGet(‚Ä¶) { ‚Ä¶ }
                        public void doPost(‚Ä¶) { ‚Ä¶ }
                    }

                    // Enterprise Java Bean
                    // Beinhaltet die fachlichen Funktionen
                    @Stateles
                    public class ShoppingCartBean {
                        public List&lt;Article&gt; getContent() { ‚Ä¶ }
                        public void addArticle(int id, int amount) { ‚Ä¶ }
                        public void removeArticle(int id) { ‚Ä¶ }
                        public void checkout() { ‚Ä¶ }
                    }

                    // Persistence Entity
                    // Definiert eine Datenbanktabelle
                    @Entity
                    public class Article {
                        @Id
                        @GeneratedValue
                        long id;

                        String name;
                        ‚Ä¶

                        public void setId(long id) { ‚Ä¶ }
                        public long getId() { ‚Ä¶ }
                        public void setName(String name) { ‚Ä¶ }
                        public String getName() { ‚Ä¶ }
                    }
                </source-code>
                <p>
                    Wie du siehst, ist das gar nicht so kompliziert, auch wenn wir uns hier noch nicht um die
                    Einzelheiten k√ºmmern wollen. Zumindest kann man aber schon erkennen, dass eine klare
                    Aufgabenteilung zwischen den Klassen zu herrschen scheint. Abschlie√üend bleibt hier dann
                    nur noch zu sagen, dass Jakarta&nbsp;EE eine ganze Reihe von APIs definiert, auf die innerhalb
                    der Klassen zugegriffen werden kann. Welche das sind, siehst du auf der Folie.
                </p>
            </aside>
        </section>

        <section>
            <h1>Fallbeispiele f√ºr Java auf dem Server</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "fallbeispiele-pos-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#fallbeispiele-pos"
                                role          = "tab"
                                aria-controls = "fallbeispiele-pos"
                                aria-expanded = "true"
                            >
                                Point-Of-Sale
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fallbeispiele-reiseportal-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fallbeispiele-reiseportal"
                                role          = "tab"
                                aria-controls = "fallbeispiele-reiseportal"
                            >
                                Reiseportal
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content">
                        <!-- Point-Of-Sale -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "fallbeispiele-pos"
                            role            = "tabpanel"
                            aria-labelledby = "fallbeispiele-pos-tab"
                        >
                            <p>
                                Im Unternehmensumfeld geht es h√§ufig darum, mit unterschiedlichen Endger√§ten eine gemeinsame Datenbasis zur
                                Dokumentation aller Gesch√§ftsvorg√§nge zu pflegen. Anwendungen wie diese besitzen daher ein ausgefeiltes Datenmodell
                                und darauf aufbauend sehr viele Services, welche die Gesch√§ftsprozesse des Unternehmens abbilden. Das Datenmodell
                                wird dabei durch die <b>Persistence Entity</b>-Klassen modelliert, w√§hrend die Services in <b>Enterprise Java Beans</b>
                                enthalten sind. Fremde Clientprogramme k√∂nnen die EJBs √ºber Rechnergrenzen hinweg direkt aufrufen. Innerhalb des
                                Applikationsservers stehen sie aber auch zur Nutzung in Webanwendungen zur Verf√ºgung.
                            </p>
                            <img src="fallbeispiel-pos.jpg" alt="Architekturskizze einer Point-Of-Sale-Anwendung" class="d-block" style="width: 100%; margin-bottom: 1em;" />
                            <p>
                                <small>
                                    <small>
                                        Bildnachweise:
                                        <a href="https://de.wikipedia.org/wiki/Datei:Quorion_concerto.jpg" target="_blank">Wikipedia: Tokaito</a>,
                                        <a href="https://pixabay.com/en/isolated-money-euro-cash-finance-3118531/" target="_blank">Pixabay: Snap_it</a>,
                                        <a href="https://pixabay.com/en/imac-computer-apple-mac-calculator-1999642/" target="_blank">Pixabay: Nick_H</a>,
                                        <a href="https://pixabay.com/en/gps-navigation-garmin-yellow-295077/" target="_blank">Pixabay: Clker-Free-Vector-Images</a>,
                                        <a href="https://pixabay.com/en/wireless-signal-icon-image-vector-1119306/" target="_blank">Pixabay: Samuel1983</a>
                                    </small>
                                </small>
                            </p>
                        </div>
                        <!-- Reiseportal -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fallbeispiele-reiseportal"
                            role            = "tabpanel"
                            aria-labelledby = "fallbeispiele-reiseportal-tab"
                        >
                            <p>
                                Dieses Beispiel zeigt ein gro√ües Webportal mit mehreren, von der restlichen Anwendungslogik entkoppelten Webfrontends.
                                Zur besseren Skalierung werden getrennte Server f√ºr die Webfrontends (sog. ‚ÄûWebcontainer"¬π) und das Backend genutzt.
                                Im Backend werden zus√§tzlich die Dienste fremder Anbieter per Webservice integriert.
                            </p>
                            <p style="line-height: 1; margin-bottom: 1em;">
                                <small>
                                    <small>
                                        ¬π Vollwertige Jakarta&nbsp;EE-Applikationsserver bestehen im Grunde genommen aus nichts anderem als einem
                                        Webcontainer und einem EJB-Container, wobei der Webcontainer die Servlet- und webbezogenen APIs zur
                                        Verf√ºgung stellt und der EJB-Container den Rest. Wenn man aber wei√ü, dass man die Funktionen des EJB-Containers
                                        nicht ben√∂tigt, kann man den Webcontainer auch separat installieren.
                                    </small>
                                </small>
                            </p>
                            <img src="fallbeispiel-reiseportal.jpg" alt="Architekturskizze eines gro√üen Reiseportals" class="d-block" style="width: 100%; margin-bottom: 1em;" />
                            <p>
                                <small>
                                    <small>
                                        Bildnachweise:
                                        <a href="https://pixabay.com/en/computer-laptop-blank-empty-screen-3036166/" target="_blank">Pixabay: www_slon_pics</a>,
                                        <a href="https://pixabay.com/en/polynesia-french-polynesia-tahiti-3021072/" target="_blank">Pixabay: Julius_Silver</a>,
                                        <a href="https://pixabay.com/en/tropical-sunset-summer-beach-sunset-1651426/" target="_blank">Pixabay: TheDigitalArtist</a>,
                                        <a href="https://pixabay.com/en/train-railway-s-bahn-transport-797072/" target="_blank">Pixabay: Didgeman</a>,
                                        <a href="https://pixabay.com/en/transportation-system-vehicle-3064387/" target="_blank">Pixabay: joe137</a>,
                                        <a href="https://pixabay.com/en/hotel-room-bed-pillows-room-hotel-1447201/" target="_blank">Pixabay: Olichel</a>
                                    </small>
                                </small>
                            </p>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Auf dieser Folie siehst du zwei typische Anwendungsbeispiele f√ºr die Jakarta Enterprise Edition: Eine Gesch√§ftsanwendung,
                    wie sie als interne Anwendung in einem Supermarkt betrieben werden k√∂nnte, sowie ein gro√ües Webportal mit mehreren
                    Frontends und Schnittstellen zu externen Webserviceanbietern. In beiden F√§llen eignet sich die Jakarta Enterprise Edition
                    aufgrund folgender Eigenschaften besonders gut:
                </p>
                <ul>
                    <li>
                        <b>Persistence Entities:</b> Dank der Java Persistence API kann mit einfachen Klassen ein ausgefeiltes Datenmodell
                        realisiert werden, bei dem Java automatisch die Objekte dieser Klassen in der Datenbank ablegen und von dort wieder
                        rausholen kann. Ebenso unterst√ºtzt Java eine m√§chtige Anfragesprache, mit der relativ einfach auch komplexe Suchen auf
                        der Datenbank ausgef√ºhrt werden k√∂nnen.
                    </li>
                    <li>
                        <b>Enterprise Java Beans:</b> S√§mtliche Gesch√§ftsvorg√§nge lassen sich losgel√∂st von ihrer sp√§teren Darstellung sowie
                        ihrer sp√§teren Verwender in einfachen Beanklassen implementieren. Die Klassen sind dabei so flexibel, dass ihre Methoden
                        aus einer internen Webanwendung heraus, per Webservice oder per entferntem Methodenaufruf aufrufbar sind.
                    </li>
                    <li>
                        <b>Message Driven Beans:</b> √úber den Applikationsserver k√∂nnen auch Nachrichten an einen externen Message Broker
                        gesendet und von diesem abgerufen werden.
                    </li>
                    <li>
                        <b>Webcontainer:</b> Jeder Applikationsserver beinhaltet bereits einen Webcontainer, in dem neben statischen Webseiten
                        auch in Java realisierte Webanwendungen ausf√ºhrbar sind.
                    </li>

                    <li>
                        <b>Webservices:</b> Mit der Jakarta Enterprise Edition k√∂nnen sowohl fremde Webservices aufgerufen als auch eigene Webservices
                        angeboten werden. F√ºr die Erstellung der Webservices m√ºssen hierf√ºr nur eine Hand voll Annotationen in die vorhandenen
                        EJBs aufgenommen werden.
                    </li>
                    <li>
                        <b>Flexibles Deployment:</b>
                        Das Deployment von Jakarta&nbsp;EE ist so flexibel, dass entweder alle Bestandteile einer Anwendung in einem gemeinsamen
                        oder in getrennten Applikationsservern zum Laufen gebracht werden k√∂nnen. Falls die Anwendung sauber programmiert
                        wurde, sind hierf√ºr keine √Ñnderungen am Quellcode n√∂tig.
                    </li>
                </ul>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 1: Ein kleines Java-EE-Quiz</h1>
            <article>
                <h2>Aufgabe 1.1: Die Jakarta Enterprise Edition</h2>

                <p>
                    a) Um was f√ºr eine Middleware handelt es sich bei der Jakarta Enterprise Edition?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Kommunikationsorientierte Middleware
                    </li>
                    <li>
                        Anwendungsorientierte Middleware
                    </li>
                </ol>

                <p>
                    b) Wo gibt es die Jakarta Enterprise Edition zum herunterladen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Bei Oracle, dem Entwickler von Java
                    </li>
                    <li>
                        Bei Microsoft, allerdings nur f√ºr Windows
                    </li>
                    <li>
                        Bei den Herstellern der Applikationsserver
                    </li>
                    <li>
                        Bei der Eclipse Foundation
                    </li>
                    <li>
                        Gar nicht, sie ist in der Sprache Java enthalten
                    </li>
                </ol>

                <p>
                    c) Welche der folgenden Schnittstellen bietet ein typischer Anwendungsserver?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Entfernte Methodenaufrufe
                    </li>
                    <li>
                        SOAP-Webservices
                    </li>
                    <li>
                        REST-Webservices
                    </li>
                    <li>
                        Nachrichten √ºber einen Message Broker
                    </li>
                    <li>
                        HTTP zum Aufruf von Webanwendungen
                    </li>
                </ol>

                <h2>Aufgabe 1.2: Komponentenbasierte Entwicklung</h2>

                <p>
                    a) Welche Eigenschaften besitzt eine Klasse, wenn sie eine Softwarekomponente ist?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Alle Methoden und Attribute sind <src-code>public</src-code>.
                    </li>
                    <li>
                        Sie kapselt eine in sich geschlossene Funktionalit√§t.
                    </li>
                    <li>
                        Sie h√§ngt nur lose von anderen Komponentenklassen ab.
                    </li>
                    <li>
                        Sie implementiert das Interface <code>WebComponent</code>.
                    </li>
                    <li>
                        Idealerweise kann sie in mehreren Anwendungen genutzt werden.
                    </li>
                    <li>
                        Sie besitzt einen parameterlosen Konstruktor.
                    </li>
                    <li>
                        Sie kann h√§ufig gegen eine alternative Implementierung getauscht werden.
                    </li>
                </ol>

                <p>
                    b) Was sch√§tzt du, was f√ºr eine austauschbare Softwarekomponente zutreffen muss?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Sie besitzt ein Interface, das ihre fachlichen Methoden definiert.
                    </li>
                    <li>
                        Die Klasse darf nicht von einer anderen Klasse erben.
                    </li>
                    <li>
                        Die Klasse muss so geschrieben sein, dass mehrere Implementierungen zul√§ssig sind.
                    </li>
                    <li>
                        Die Verwender der Klasse m√ºssen gegen ein Interface und nicht gegen die Klasse programmiert werden.
                    </li>
                    <li>
                        Die Softwarekomponente sollte auf einem eigenen Applikationsserver deployed werden.
                    </li>
                    <li>
                        Die Klasse sollte eine bestimmte UI-Technologie auf Seiten der Clients vorschreiben.
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>L√∂sung:</b> Aufgabe 1.1: 2, 3, alle; Aufgabe 1.2: 2 + 3 + 5 + 7, 1 + 3 + 4
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Okay, so viel haben wir bis jetzt noch gar nicht gelernt. Trotzdem wollen wir
                    mal sehen, ob du dir alles gemerkt hast. üé≠
                </p>
            </aside>
        </section>

        <!--
            ===========================
            MVC-WEBANWENDUNGEN MIT JAVA
            ===========================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>MVC-Webanwendungen mit Java</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Welche Aufgaben √ºbernimmt der Server?</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "webanwendungen-serverseitig-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#webanwendungen-serverseitig"
                                role          = "tab"
                                aria-controls = "webanwendungen-serverseitig"
                                aria-expanded = "true"
                            >
                                Alles auf dem Server
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "webanwendungen-clientseitig-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#webanwendungen-clientseitig"
                                role          = "tab"
                                aria-controls = "webanwendungen-clientseitig"
                            >
                                Der Server als Funktionsbibliothek
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content">
                        <!-- Alles auf dem Server -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "webanwendungen-serverseitig"
                            role            = "tabpanel"
                            aria-labelledby = "webanwendungen-serverseitig-tab"
                        >
                            <img src="webanwendung-serverseitig.png" class="d-block" style="width: 100%; margin-bottom: 1em;" />
                            <ul>
                                <li>
                                    <b class="dhbw-lightblue">Der Klassiker:</b> Die Anwendungslogik liegt komplett auf dem Server.
                                </li>
                                <li>
                                    JavaScript kommt im Browser wenn √ºberhaupt nur sehr sparsam zum Einsatz.
                                </li>
                                <li>
                                    Stattdessen f√ºhrt jede Aktion dazu, dass eine neue Seite vom Server geladen wird.
                                </li>
                                <li>
                                    Der Server f√ºhrt dabei die Anwendungslogik aus und generiert das anzuzeigende HTML.
                                </li>
                            </ul>
                            <p style="color: darkred">
                                Das schauen wir uns heute etwas genauer an.
                            </p>
                        </div>
                        <!-- Der Server als Funktionsbibliothek -->
                        <div
                            class           = "tab-pane fade"
                            id              = "webanwendungen-clientseitig"
                            role            = "tabpanel"
                            aria-labelledby = "webanwendungen-clientseitig-tab"
                        >
                            <img src="webanwendung-clientseitig.png" class="d-block" style="width: 100%; margin-bottom: 1em;" />
                            <ul>
                                <li>
                                    <b class="dhbw-lightblue">Das Beste beider Welten:</b> Browser und Server beinhalten je einen Teil der Anwendungslogik.
                                </li>
                                <li>
                                    Der initiale HTML-Code kann vom Server generiert werden oder in einer einfachen HTML-Datei liegen.
                                </li>
                                <li>
                                    Bei verschiedenen Aktionen werden mit JavaScript weitere Daten mit dem Server ausgetauscht.
                                </li>
                                <li>
                                    Die empfangenen Daten werden dabei durch geschickte DOM-Manipulation sichtbar gemacht.
                                </li>
                            </ul>
                            <p style="color: darkred">
                                Dieses Modell behandeln im Kapitel √ºber REST-Webservices.
                            </p>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Um dir einen kurzen √úberblick zu geben, womit wir uns im Folgenden nun besch√§ftigen werden, haben wir hier
                    nochmal die zwei Arten zusammengefasst, wie die serverseitige Logik einer Webanwendung realisiert werden kann.
                    Dabei l√§uft es im Wesentlichen darauf hinaus, ob die fachlichen Anwendungsfunktionen untrennbar mit dem
                    Rest der Anwendung verschmolzen sind oder ob beide Teile unabh√§ngig voneinander existieren k√∂nnen. Insbesondere
                    steht dabei die Frage im Raum, ob der angezeigte HTML-Code bereits auf dem Server oder erst im Browser generiert
                    wird und ob die Fachfunktionen auch f√ºr andere Clients zur Verf√ºgung stehen sollen.
                </p>
                <ul>
                    <li>
                        <b>Rein serverseitige Webanwendungen:</b> In klassischen Webanwendungen liegt die komplette Logik auf dem
                        Server und auch der HTML-Code wird komplett auf dem Server generiert. Dies liegt darin begr√ºndet, dass
                        Javascript in fr√ºheren Browsern l√§ngst nicht so leistungsf√§hig wie heute war und es viele Inkompatiblit√§ten
                        zwischen den Browsern gab.
                    </li>
                    <li>
                        <b>Clientseitige Webanwendungen mit Backendserver:</b> Moderne Webanwendungen sehen eine strikte Trennung
                        zwischen den fachlichen Funktionen auf dem Server und der Benutzeroberfl√§che im Browser vor. Technisch
                        gesehen handelt es sich daher um zwei getrennte Anwendungen, die losgel√∂st voneinander und h√§ufig auch von
                        getrennten Teams entwickelt werden. Der Server bietet hierf√ºr eine Reihe von Webservices, die der
                        Browser bei Bedarf aufrufen kann.
                    </li>
                </ul>
                <p>
                    Auch wenn hier von klassischen und modernen Webanwendungen die Rede ist, haben beide Arten ihre jeweiligen
                    Vor- und Nachteile, so dass es falsch w√§re, sich pauschal nur auf eine davon zu fixieren. Klassische Webanwendungen
                    haben den Vorteil, dass sie einfach zu entwickeln sind, schnell zu guten Ergebnissen f√ºhren und auch von einem
                    kleinen Team betreut werden k√∂nnen. Nachteilig daran ist, dass die Fachfunktionen meist sehr eng mit der Anwendung
                    verflochten sind und, da der Browser st√§ndig neue Seiten vom Server laden muss, die Performance nicht so
                    gut wie bei rein clientseitigen Anwendungen ist. Clientseitige Webanwendungen mit getrenntem Serverbackend haben diese
                    Nachteile nicht, jedoch sind sie aufw√§ndiger in der Entwicklung, sowohl was den Browserteil angeht als auch die
                    Webservice-Schnittstelle zur Kapselung der fachlichen Logik.
                </p>
                <p>
                    In diesem Kapitel schauen wir uns nur rein serverseitige Webanwendungen an. Sp√§ter bei den REST-Webservices kommen
                    wir dann auch auf die andere Art zur√ºck.
                </p>
            </aside>
        </section>

        <section>
            <h1>Alle guten Dinge sind drei: Model, View &amp; Controller</h1>
            <article>
                <div class="container-fluid">
                    <!-- Model, View, Controller -->
                    <div class="row">
                        <div class="col-md">
                            <div class="img-thumbnail" style="padding: 0.5em; height: 100%; display: flex; flex-direction: column;">
                                <h2>Model</h2>
                                <ul>
                                    <li>
                                        Enterprise Java Beans
                                    </li>
                                    <li>
                                        Persistence Entities
                                    </li>
                                </ul>
                                <div style="flex: 1;"></div>
                                <p>
                                    Kapseln die fachliche Logik und das Datenmodell.
                                </p>
                                <img src="mvc-bilder-model.jpg" alt="" class="d-block" style="width: 100%;" />
                            </div>
                        </div>
                        <div class="col-md">
                            <div class="img-thumbnail" style="padding: 0.5em; height: 100%; display: flex; flex-direction: column;">
                                <h2>View</h2>
                                <ul>
                                    <li>
                                        HTML, CSS, JS-Dateien
                                    </li>
                                    <li>
                                        Java Server Pages
                                    </li>
                                </ul>
                                <div style="flex: 1;"></div>
                                <p>
                                    √úbernehmen die Darstellung auf dem Bildschirm.
                                </p>
                                <img src="mvc-bilder-view.jpg" alt="" class="d-block" style="width: 100%;" />
                            </div>
                        </div>
                        <div class="col-md">
                            <div class="img-thumbnail" style="padding: 0.5em; height: 100%; display: flex; flex-direction: column;">
                                <h2>Controller</h2>
                                <ul>
                                    <li>
                                        Servlets
                                    </li>
                                </ul>
                                <div style="flex: 1;"></div>
                                <p>
                                    Reagieren auf HTTP-Anfragen und vermitteln zwischen
                                    Model und View.
                                </p>
                                <img src="mvc-bilder-controller.jpg" alt="" class="d-block" style="width: 100%;" />
                            </div>
                        </div>
                    </div>

                    <!-- Karusell mit dem schematischen Ablauf -->
                    <div class="row">
                        <div class="col-md">
                            <ul class="nav nav-tabs" role="tablist">
                                <li>
                                    <a href="#mvc-carousel" class="nav-link" data-slide="next">N√§chstes Bild</a>
                                </li>
                                <li>
                                    <a href="#mvc-carousel" class="nav-link" data-slide="prev">Vorheriges Bild</a>
                                </li>
                                <li>
                                    <a href="#mvc-carousel" class="nav-link" data-slide-to="0">Nochmal von vorne</a>
                                </li>
                            </ul>
                            <div id="mvc-carousel" class="carousel" data-interval="false">
                                <div class="carousel-inner">
                                    <div class="carousel-item active">
                                        <p>
                                            Schauen wir uns an, wie Model, View und Controller beim Aufruf einer Webseite zusammenarbeiten.
                                            Hierf√ºr gibt der Anwender eine URL ein und schickt die Anfrage ab.
                                        </p>
                                        <img class="active d-block w-100" src="mvc-ablauf-01.png" />
                                    </div>
                                    <div class="carousel-item">
                                        <p>
                                            Anhand der URL ermittelt der Server ein <b>Servlet</b>, das die Anfrage bearbeitet.
                                        </p>
                                        <img class="active d-block w-100" src="mvc-ablauf-02.png" />
                                    </div>
                                    <div class="carousel-item">
                                        <p>
                                            Da das Servlet keine fachliche Logik enthalten darf, ruft es eine oder mehrere <b>Enterprise Java Beans</b> auf,
                                            die die eigentliche Arbeit erledigen.
                                        </p>
                                        <img class="active d-block w-100" src="mvc-ablauf-03.png" />
                                    </div>
                                    <div class="carousel-item">
                                        <p>
                                            Die Enterprise Java Beans wiederum nutzen <b>Persistence Entities</b>, um Daten aus der Datenbank zu
                                            lesen oder zu schreiben.
                                        </p>
                                        <img class="active d-block w-100" src="mvc-ablauf-04.png" />
                                    </div>
                                    <div class="carousel-item">
                                        <p>
                                            Das Servlet legt die eben erhaltenen Daten im <b>Request Context</b> ab und leitet die Anfrage
                                            an eine <b>Java Server Page</b> weiter.
                                        </p>
                                        <img class="active d-block w-100" src="mvc-ablauf-05.png" />
                                    </div>
                                    <div class="carousel-item">
                                        <p>
                                            Die Java Server Page wiederum generiert den HTML-Code, der an den Browser geschickt wird.
                                        </p>
                                        <img class="active d-block w-100" src="mvc-ablauf-06.png" />
                                    </div>
                                    <div class="carousel-item">
                                        <p>
                                            Der Browser zeigt die empfangene Seite an und der Anwender freut sich. üòä
                                        </p>
                                        <img class="active d-block w-100" src="mvc-ablauf-07.jpg" />
                                    </div>
                                    <div class="carousel-item">
                                        <p>
                                            Auf der n√§chsten Folie zeigen wir dir, wie der Quellcode hierf√ºr aussehen muss. ‚å®Ô∏è
                                        </p>
                                        <img class="active d-block w-25 m-auto" src="../../finish.svg" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bildnachweise -->
                    <div class="row">
                        <div class="col-md">
                            <small>
                                <small>
                                    Bildnachweise:
                                    <a href="https://pixabay.com/en/coffee-espresso-caffeine-the-drink-3132755/" target="_blank">Pixabay: fotostrobi</a>,
                                    <a href="https://pixabay.com/en/brushes-painter-work-shop-bowl-3129361/" target="_blank">Pixabay: Skitterphoto</a>,
                                    <a href="https://pixabay.com/en/pug-puppy-dog-animal-cute-690566/" target="_blank">Pixabay: Free-Photos</a>,
                                    <a href="https://pixabay.com/en/browser-internet-tab-new-tab-1666995/" target="_blank">Pixabay: JuralMin</a>,
                                    <a href="https://pixabay.com/en/pegasus-horse-winged-mythology-586124/" target="_blank">Pixabay: Stevebidmead</a>,
                                    <a href="https://pixabay.com/en/symbol-gui-internet-internet-page-2480163/" target="_blank">Pixabay: janf93</a>
                                </small>
                            </small>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Bei der Webentwicklung hat sich in besonderem Ma√üe die Strukturierung einer Anwendung nach dem
                    <a href="https://de.wikipedia.org/wiki/Model_View_Controller" target="_blank">Model-View-Controller</a>-Ansatz
                    etabliert, so dass heute beinahe jede Webanwendung nach diesem Muster aufgebaut ist. So ist es kein Wunder, dass
                    auch fast jedes Webframework mit MVC wirbt, obwohl die Meinungen dar√ºber, was zum Model, zur View oder zum Controller
                    geh√∂rt, doch sehr auseinander gehen. üôÑ Interessant dabei ist jedoch, dass das Konzept gar nicht f√ºr das Web
                    entwickelt wurde, sondern bereits 1979 am <a href="https://de.wikipedia.org/wiki/Xerox_PARC" target="_blank">Xerox PARC</a>
                    f√ºr die Programmiersprache <a href="https://de.wikipedia.org/wiki/Smalltalk_(Programmiersprache)" target="_blank">Smalltalk</a>
                    und den <a href="https://de.wikipedia.org/wiki/Xerox_Alto" target="_blank">Xerox Alto</a>-Computer¬π, der allgemein als
                    der erste Computer mit grafischer Benutzeroberfl√§che, Desktop und Maus üñ±Ô∏è gilt.
                </p>
                <p>
                    <small>
                        ¬π Eine sch√∂ne Beschreibung des Xerox Alto mit vielen Bildern gibt es auf der Seite des
                        <a href="http://www.computerhistory.org/revolution/input-output/14/347" target="_blank">Computer History Museum</a>.
                        Auf <a href="https://www.youtube.com/watch?v=M0zgj2p7Ww4" target="_blank">Youtube</a> gibt es dar√ºber hinaus auch
                        einen kurzen Werbefilm, der unter anderem auch eine fr√ºhe Form der E-Mail zeigt. Weitere Erfindungen am PARC waren
                        Ethernet, der Laserdrucker, Postscript, WYSIWYG und das Notebook.
                    </small>
                </p>
                <p>
                    Um zu verstehen, wie sich MVC entwickelt hat, muss man wissen, dass die fr√ºhen Computer l√§ngst nicht so weit entwickelt
                    waren wie heute. Damals konnte man mit sehr viel Programmierarbeit lediglich einzelne Pixel auf den Bildschirm zeichnen
                    oder den Status von Tastatur und Maus abfragen. Selbst einfache Benutzeroberfl√§chen mussten daher sehr aufw√§ndig und mit
                    teilweise sehr undurchsichtigem Code entwickelt werden. Fertige Widget Libraries wie heute gab es damals noch nicht.
                    Um daher etwas mehr Ordnung in das Chaos zu bringen, teilte man den Quellcode zur Erzeugung eines einfachen UI-Elements
                    (zum Beispiel eines Eingabefelds) in drei Teile auf:
                </p>
                <ul>
                    <li>
                        Das <b>Model</b>, welches die darzustellenden Daten enth√§lt,
                    </li>
                    <li>
                        Die <b>View</b>, welche die Daten irgendwie auf den Bildschirm bringt,
                    </li>
                    <li>
                        Sowie den <b>Controller</b>, der Tastatur und Maus abfr√§gt, daraufhin das Model aktualisiert und die View beauftragt, sich neu zu zeichnen.
                    </li>
                </ul>
                <p>
                    Die drei Einheiten geh√∂ren dabei immer zusammen, so wie die drei Schichten eines Doppelkeks: üç™
                </p>
                <img src="doppelkeks.jpg" alt="Doppelkekse zur Verdeutlichung des MVC-Ansatzes" class="d-block" style="width: 100%; margin: 0 auto;" />
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://commons.wikimedia.org/wiki/File:Leibniz_Pick-Up_4.jpg" target="_blank">Wikimedia Commons: SKopp</a>
                    </small>
                </p>
                <p>
                    Da die Programmierung heutiger Anwendungen nicht mehr so m√ºhselig ist, werden die Begriffe Model, View und Controller
                    heutzutage etwas allgemeiner ausgelegt:
                </p>
                <ul>
                    <li>
                        <b>Model:</b> Manche Autoren verstehen hierunter das Datenmodell und somit einfach die Daten einer Anwendung.
                        Im erweiterten Sinne macht es jedoch mehr Sinn, s√§mtliche fachlichen Aufgaben einer Anwendung hierunter zu verstehen.
                    </li>
                    <li>
                        <b>View:</b> Die View ist nach wie vor f√ºr die Darstellung auf dem Bildschirm zust√§ndig, wobei heute nat√ºrlich
                        viel komfortablere M√∂glichkeiten zur Verf√ºgung stehen.
                    </li>
                    <li>
                        <b>Controller:</b> Er ist die Schokolade, die Model und View zusammenh√§lt. Der Controller k√ºmmert sich um
                        die Vermittlung zwischen Model und View, indem er zum richtigen Zeitpunkt die richtigen Methoden aufruft.
                    </li>
                </ul>
                <p>
                    Hinzu kommt, dass keine Abh√§ngigkeiten vom Model zur View oder vom Model zum Controller bestehen d√ºrfen. Das Model stellt
                    lediglich (fachliche) Funktionen bereit, die von den anderen beiden Schichten aufgerufen werden. Somit soll die M√∂glichkeit
                    offen gehalten werden, zum selben Model sp√§ter zus√§tzliche Benutzeroberfl√§chen zu entwickeln. Umgekehrt ist es deshalb oft
                    erlaubt, dass View und Controller direkt auf das Model zugreifen.
                </p>
                <p>
                    Soweit die Theorie. Bezogen auf Webanwendungen mit Java hei√üt das folgendes:
                </p>
                <ul>
                    <li>
                        <b>Enterprise Java Beans</b> und <b>Persistence Entities</b> kapsel die fachliche Logik einer Webanwendung und
                        bilden daher das Model.
                    </li>
                    <li>
                        <b>Java Server Pages</b> und <b>HTML</b> dienen der Darstellung und bilden daher die View.
                    </li>
                    <li>
                        <b>Servlets</b> reagieren auf alle HTTP-Anfragen und sorgen daf√ºr, dass das Model und die View zum richtigen
                        Zeitpunkt aufgerufen werden. Sie sind daher die Controller.
                    </li>
                </ul>
                <p>
                    In welcher Reihenfolge was passiert, siehst du auf der Folie. Generell handelt es sich dabei aber um denselben
                    Ablauf, den wir bereits in <a href="../../../webprog/4-server/http_jsp_servlets/#17" target="_blank">Webprogrammierung</a>
                    kennengelernt haben.
                </p>
            </aside>
        </section>

        <section>
            <h1>Beispiel: MVC mit Servlets und JSP</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "mvc-beispiel-netbeans-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#mvc-beispiel-netbeans"
                                role          = "tab"
                                aria-controls = "mvc-beispiel-netbeans"
                                aria-expanded = "true"
                            >
                                Netbeans-Projekt
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "mvc-beispiel-entity-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#mvc-beispiel-entity"
                                role          = "tab"
                                aria-controls = "mvc-beispiel-entity"
                                aria-expanded = "true"
                            >
                                Entity
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "mvc-beispiel-ejb-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#mvc-beispiel-ejb"
                                role          = "tab"
                                aria-controls = "mvc-beispiel-ejb"
                                aria-expanded = "true"
                            >
                                EJB
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "mvc-beispiel-servlet-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#mvc-beispiel-servlet"
                                role          = "tab"
                                aria-controls = "mvc-beispiel-servlet"
                                aria-expanded = "true"
                            >
                                Servlet
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "mvc-beispiel-jsp-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#mvc-beispiel-jsp"
                                role          = "tab"
                                aria-controls = "mvc-beispiel-jsp"
                            >
                                JSP
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "mvc-beispiel-css-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#mvc-beispiel-css"
                                role          = "tab"
                                aria-controls = "mvc-beispiel-css"
                            >
                                CSS
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "mvc-beispiel-ergebnis-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#mvc-beispiel-ergebnis"
                                role          = "tab"
                                aria-controls = "mvc-beispiel-ergebnis"
                            >
                                Ergebnis
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content">
                        <!-- Netbeans-Projekt -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "mvc-beispiel-netbeans"
                            role            = "tabpanel"
                            aria-labelledby = "mvc-beispiel-netbeans-tab"
                        >
                            <p>
                                So sieht das Netbeans-Projekt aus. Wir bauen ein kleines G√§stebuch.
                            </p>
                            <img src="mvc-beispiel-netbeans.png" class="d-block" style="width: 100%" />
                        </div>
                        <!-- Entity -->
                        <div
                            class           = "tab-pane fade show"
                            id              = "mvc-beispiel-entity"
                            role            = "tabpanel"
                            aria-labelledby = "mvc-beispiel-entity-tab"
                        >
                            <p>
                                Diese <b>Persistence Entity</b> entspricht einem Eintrag in der Datenbank.
                            </p>
                            <source-code language="java">
                                package dhbwka.wwi.vertsys.javee.guestbook;

                                import java.io.Serializable;
                                import java.sql.Date;
                                import java.sql.Time;
                                import javax.persistence.Entity;
                                import javax.persistence.GeneratedValue;
                                import javax.persistence.GenerationType;
                                import javax.persistence.Id;

                                /**
                                * Persistenzklasse f√ºr einen G√§stebucheintrag.
                                */
                                @Entity
                                public class GuestbookEntry implements Serializable {

                                    private static final long serialVersionUID = 1L;

                                    @Id
                                    @GeneratedValue(strategy = GenerationType.AUTO)
                                    private Long id;

                                    private String name = "";
                                    private Date visitDate = new Date(System.currentTimeMillis());
                                    private Time visitTime = new Time(System.currentTimeMillis());

                                    public GuestbookEntry() {
                                    }

                                    public GuestbookEntry(String name) {
                                        this.name = name;
                                    }

                                    //&lt;editor-fold defaultstate="collapsed" desc="Setter und Getter"&gt;
                                    public Long getId() {
                                        return id;
                                    }

                                    public void setId(Long id) {
                                        this.id = id;
                                    }

                                    public String getName() {
                                        return name;
                                    }

                                    public void setName(String name) {
                                        this.name = name;
                                    }

                                    public Date getVisitDate() {
                                        return visitDate;
                                    }

                                    public void setVisitDate(Date visitDate) {
                                        this.visitDate = visitDate;
                                    }

                                    public Time getVisitTime() {
                                        return visitTime;
                                    }

                                    public void setVisitTime(Time visitTime) {
                                        this.visitTime = visitTime;
                                    }
                                    //&lt;/editor-fold&gt;

                                }
                            </source-code>
                        </div>
                        <!-- EJB -->
                        <div
                            class           = "tab-pane fade show"
                            id              = "mvc-beispiel-ejb"
                            role            = "tabpanel"
                            aria-labelledby = "mvc-beispiel-ejb-tab"
                        >
                            <p>
                                Dies ist eine <b>Enterprise Java Bean</b>. Sie enth√§lt die Methoden zum Lesen und Schreiben der Eintr√§ge.
                            </p>
                            <source-code language="java">
                                package dhbwka.wwi.vertsys.javee.guestbook;

                                import java.util.List;
                                import javax.ejb.Stateless;
                                import javax.persistence.EntityManager;
                                import javax.persistence.PersistenceContext;

                                /**
                                 * Enterprise Java Bean zum Auslesen und Speichern von G√§stebucheintr√§gen.
                                 */
                                @Stateless
                                public class GuestbookBean {

                                    @PersistenceContext
                                    protected EntityManager em;

                                    /**
                                     * @return Liste mit allen G√§stebucheintr√§gen
                                     */
                                    public List&lt;GuestbookEntry&gt; findAllEntries() {
                                        return em.createQuery("SELECT e FROM GuestbookEntry e "
                                                            + "  ORDER BY e.visitDate DESC, "
                                                            + "           e.visitTime DESC")
                                                .getResultList();
                                    }

                                    /**
                                     * Speichert einen neuen G√§stebucheintrag.
                                     * @param name Name des Besuchers
                                     * @return Der gespeicherte Eintrag
                                     */
                                    public GuestbookEntry createNewEntry(String name) {
                                        GuestbookEntry entry = new GuestbookEntry(name);
                                        em.persist(entry);
                                        return em.merge(entry);
                                    }
                                }
                            </source-code>
                        </div>
                        <!-- Servlet -->
                        <div
                            class           = "tab-pane fade show"
                            id              = "mvc-beispiel-servlet"
                            role            = "tabpanel"
                            aria-labelledby = "mvc-beispiel-servlet-tab"
                        >
                            <p>
                                Dies ist das Servlet, das bei jeder <tt>GET</tt>- und <tt>POST</tt>-Anfrage durchlaufen wird.
                            </p>
                            <source-code language="java">
                                package dhbwka.wwi.vertsys.javee.guestbook;

                                import java.io.IOException;
                                import java.util.List;
                                import javax.ejb.EJB;
                                import javax.servlet.ServletException;
                                import javax.servlet.annotation.WebServlet;
                                import javax.servlet.http.HttpServlet;
                                import javax.servlet.http.HttpServletRequest;
                                import javax.servlet.http.HttpServletResponse;
                                import javax.servlet.http.HttpSession;

                                /**
                                 * Servlet f√ºr die G√§stebuchseite
                                 */
                                @WebServlet(urlPatterns = {"/index.html"})
                                public class GuestbookServlet extends HttpServlet {

                                    @EJB
                                    private GuestbookBean guestbookBean;

                                    @Override
                                    public void doGet(HttpServletRequest request, HttpServletResponse response)
                                    throws ServletException, IOException {
                                        // Alle vorhandenen Eintr√§ge aus der Datenbank lesen und im Request
                                        // Context ablegen, damit sie in der JSP zur Verf√ºgung stehen
                                        List&lt;GuestbookEntry&gt; entries = this.guestbookBean.findAllEntries();
                                        request.setAttribute("entries", entries);

                                        // Anfrage an die JSP weiterleiten
                                        request.getRequestDispatcher("guestbook.jsp").forward(request, response);

                                        // In der Session liegende Fehlermeldung verwerfen, damit wir beim
                                        // n√§chsten Aufruf wieder mit einem leeren Eingabefeld anfangen
                                        HttpSession session = request.getSession();
                                        session.removeAttribute("fehler");
                                        session.removeAttribute("name");
                                    }

                                    @Override
                                    public void doPost(HttpServletRequest request, HttpServletResponse response)
                                    throws ServletException, IOException {
                                        // Pr√ºfen, ob der Anwender seinen Namen eingegeben hat
                                        HttpSession session = request.getSession();

                                        String fehler = "";
                                        String name = request.getParameter("name");

                                        if (name == null || name.trim().isEmpty()) {
                                            fehler = "Bitte gib erst deinen Namen ein.";
                                            session.setAttribute("fehler", fehler);
                                            session.setAttribute("name", name);
                                        }

                                        // Neuen Eintrag speichern
                                        if (fehler.isEmpty()) {
                                            this.guestbookBean.createNewEntry(name);
                                        }

                                        // Browser auffordern, die Seite neuzuladen
                                        response.sendRedirect(request.getContextPath());
                                    }

                                }
                            </source-code>
                        </div>
                        <!-- JSP -->
                        <div
                            class           = "tab-pane fade"
                            id              = "mvc-beispiel-jsp"
                            role            = "tabpanel"
                            aria-labelledby = "mvc-beispiel-jsp-tab"
                        >
                            <p>
                                Hier die Datei <tt>WEB-INF/guestbook.jsp</tt> mit dem JSP-Code zur Anzeige der Seite.
                            </p>
                            <source-code language="html">
                                &lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;

                                &lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;
                                &lt;%@taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%&gt;

                                &lt;!DOCTYPE html&gt;
                                &lt;html&gt;
                                    &lt;head&gt;
                                        &lt;meta charset="utf-8"&gt;
                                        &lt;title&gt;G√§stebuch MVC-Beispiel&lt;/title&gt;
                                        &lt;link rel="stylesheet" href="style.css"&gt;
                                    &lt;/head&gt;
                                    &lt;body&gt;
                                        &lt;div class="container"&gt;
                                            &lt;h1&gt;Mein kleines G√§stebuch&lt;/h1&gt;

                                            &lt;form method="POST"&gt;
                                                &lt;input type="text" name="name" placeholder="Dein Name" value="${name}"/&gt;
                                                &lt;button type="submit"&gt;Abschicken&lt;/button&gt;
                                            &lt;/form&gt;

                                            &lt;c:if test="${!empty fehler}"&gt;
                                                &lt;p class="error"&gt;
                                                    ${fehler}
                                                &lt;/p&gt;
                                            &lt;/c:if&gt;

                                            &lt;ul&gt;
                                                &lt;c:forEach items="${entries}" var="entry"&gt;
                                                    &lt;li&gt;
                                                        ${entry.visitDate}, ${entry.visitTime}: ${entry.name}
                                                    &lt;/li&gt;
                                                &lt;/c:forEach&gt;
                                            &lt;/ul&gt;
                                        &lt;/div&gt;
                                    &lt;/body&gt;
                                &lt;/html&gt;
                            </source-code>
                        </div>
                        <!-- CSS -->
                        <div
                            class           = "tab-pane fade"
                            id              = "mvc-beispiel-css"
                            role            = "tabpanel"
                            aria-labelledby = "mvc-beispiel-css-tab"
                        >
                        <p>
                            Damit es ordentlich aussieht, nutzen wir ein kleines Stylesheet namens <tt>style.css</tt>.
                        </p>
                        <source-code language="css">
                            html, body {
                                font-family: sans-serif;
                                font-size: 12pt;
                                height: 100%;

                                margin: 0;
                                padding: 0;
                            }

                            html {
                                background-image: url(https://picsum.photos/1024/?image=871);
                                background-repeat: no-repeat;
                                background-position: center center;
                                background-size: cover;
                            }

                            body {
                                display: flex;
                                justify-content: center;
                                align-items: center;
                            }

                            .container {
                                background: rgba(255,255,255,0.8);
                                border-radius: 0.5em;
                                padding: 1em;
                                margin: 2em;
                            }

                            h1, h2 {
                                color: crimson;
                                text-shadow: 0 0 1px rgba(0,0,0,0.5);
                                margin: 0 0 0.5em 0;
                            }

                            h2 {
                                color: deepskyblue;
                            }

                            input[type="text"] {
                                display: block;
                                width: 25em;
                                box-sizing: border-box;
                                border: 1px solid grey;
                                margin-bottom: 0.5em;
                            }

                            ul {
                                list-style: none;
                                margin: 1em 0 0 0;
                                padding: 0;
                                font-size: 90%;
                            }

                            li {
                                margin: 0 0 0.75em 0;
                                padding: 0;
                            }

                            .error {
                                color: red;
                                font-weight: bold;
                                margin: 0 0 0.75em 0;
                            }
                        </source-code>
                        </div>
                        <!-- Ergebnis -->
                        <div
                            class           = "tab-pane fade"
                            id              = "mvc-beispiel-ergebnis"
                            role            = "tabpanel"
                            aria-labelledby = "mvc-beispiel-ergebnis-tab"
                        >
                            <p>
                                Und so sieht die fertige Anwendung aus:
                            </p>
                            <img src="mvc-beispiel-ergebnis.jpg" class="d-block" style="width: 100%;" />
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Bist du bereit f√ºr ein wenig Quellcode? Auf dieser Folie siehst du eine einfache Webanwendung, deren einzige Seite
                    nach Model-View-Controller strukturiert wurde. Die gute Nachricht daran ist: Es sieht eigentlich nicht wirklich
                    anders aus, als das was wir zuletzt in <a href="../../../webprog/4-server/http_jsp_servlets/#23" target="_blank">Webprogrammierung</a>
                    gemacht haben. ü§ó Die schlechte Nachricht ist: JSP, Stylesheet und Servlet werden wir hier daher nicht sonderlich
                    erkl√§ren. ü§ê Diese kannst du ja einen Folien von letztem Semester nachlesen.
                </p>

                <h2>Am Anfang steht das Datenmodell</h2>
                <p>
                    Linus Torvalds wird das Zitat zugeschrieben ‚Äûgute Programmierer scheren sich nicht um Algorithmen, sondern um
                    Datenstrukturen‚Äù. üí¨ Vor allem anderen sollten wir uns daher erst das Datenmodell unserer kleinen Anwendung
                    √ºberlegen. F√ºr den Anfang soll es nichts Kompliziertes sein. Ein G√§stebuch mit folgenden Feldern je Eintrag
                    soll uns erst mal gen√ºgen:
                </p>
                <ul>
                    <li>
                        <tt>name:</tt> Der Name des Besuchers
                    </li>
                    <li>
                        <tt>visitDate:</tt> Datum des Besuchs
                    </li>
                    <li>
                        <tt>visitTime:</tt> Uhrzeit des Besuchs
                    </li>
                </ul>
                <p>
                    Hierf√ºr legen wir eine <b>Persistence Entity</b> ein, was eigentlich nur ein wichtig klingender Begriff f√ºr eine
                    langweilige Javabean ist. Ihre Objekte kann Java in einer Datenbank ablegen, wof√ºr die Bean folgenden Aufbau
                    haben muss:
                </p>
                <source-code language="java">
                    @Entity
                    public class GuestbookEntry {
                        @ID
                        @GeneratedValue
                        private long id;

                        private String name = "";
                        private Date visitDate = new Date(‚Ä¶);
                        private Time visitTime = new Time(‚Ä¶);

                        // Konstruktoren ‚Ä¶
                        // Setter und Getter ‚Ä¶
                    }
                </source-code>
                <p>
                    Du siehst: An der Klasse ist eigentlich gar nichts besonderes dran. Lediglich die Annotation
                    <src-code language="java">@Entity</src-code> muss davor stehen und sie muss eine ID als Schl√ºsselfeld
                    besitzen. Das reicht bereits v√∂llig aus, damit Java eine dazu passende Tabelle f√ºr uns anlegen kann.
                    Nat√ºrlich kann man hier noch viel mehr machen, das schauen wir uns aber erst im n√§chsten Foliensatz an.
                </p>

                <h2>Wir brauchen einen Service</h2>
                <p>
                    Als n√§chstes folgt die Fachlogik unserer Anwendung. Diese ist zum Gl√ºck ebenfalls sehr einfach.
                    Wir brauchen lediglich zwei Methoden, um alle Eintr√§ge auszulesen und einen neuen Eintrag zu speichern.
                    Diese Methoden packen wir in eine <b>Enterprise Java Bean</b>:
                </p>
                <source-code language="java">
                    @Stateless
                    public class GuestbookBean {

                        // Damit greifen wir auf die Datenbank zu
                        @PersistenceContext
                        protected EntityManager em;

                        public List&lt;GuestbookEntry&gt; findAllEntries() { ‚Ä¶ }
                        public GuestbookEntry createNewEntry(String name) { ‚Ä¶ }
                    }
                </source-code>
                <p>
                    Das ist ja noch viel einfacher! ü§† Enterprise Java Beans sind tats√§chlich ganz normale Klassen
                    mit ganz normalen Methoden. Einzig die Annotation <src-code language="java">@Stateless</src-code> ver√§t,
                    dass es sich um eine EJB handelt. Die zwei Zeilen oberhalb der Methoden haben damit schon wieder gar nichts
                    mehr zu tun. Sie k√∂nnten auch in einem Servlet stehen und dienen nur dem Zugriff auf die Datenbank. Auch das
                    schauen wir uns im n√§chsten Foliensatz genauer an.
                </p>

                <h2>Der dritte Mann: Servlet und JSP</h2>
                <p>
                    Und hier sind wir schon wieder in gewohntem Territorium. Da wir eine Webanwendung schreiben, brauchen wir ein
                    Servlet, eine JSP und ein Stylesheet. Tats√§chlich k√∂nnten wir sie auch weglassen, wenn wir nur einen Webservice
                    ohne UI anbieten wollten. Darauf kommen wir ein anderes mal nochmal zur√ºck. Jetzt aber zu unserem Servlet:
                </p>
                <source-code language="java">
                    public class GuestbookServlet extends HttpServler {

                        @EJB
                        private GuestbookBean guestbookBean

                        public void doGet(‚Ä¶) { ‚Ä¶ }
                        public void doPost(‚Ä¶) { ‚Ä¶ }

                    }
                </source-code>
                <p>
                    Das Serlvet sollte eigentlich keine √úberraschungen bieten. Einzig neu ist die Annotation
                    <src-code language="java">@EJB</src-code>, mit der wir uns eine Referenz auf die Enterprise Java Bean
                    besorgen. Auf den ersten Blick sieht das zwar wie ein Fehler aus, weil der Variable niemals ein Wert
                    zugewiesen wird, aber tats√§chlich sorgt Java daf√ºr, dass hier eine Referenz auf unsere EJB zur Verf√ºgung
                    steht. Selbst, wenn die Bean auf einem anderen Server liegen w√ºrde!
                </p>
                <p>
                    Das ist tats√§chlich schon alles (vom Inhalt der Methoden abgesehen), ganz ehrlich. Um das zu beweisen,
                    eigen wir dir auf der n√§chsten Folie, wie du das Projekt in Netbeans nachbauen kannst.
                </p>
            </aside>
        </section>

        <section>
            <h1>Wo geht's denn hier zur IDE?</h1>
            <article>
                <ul class="nav nav-tabs" role="tablist">
                    <li>
                        <a href="#mvc-netbeans-carousel" class="nav-link" data-slide="next">N√§chstes Bild</a>
                    </li>
                    <li>
                        <a href="#mvc-netbeans-carousel" class="nav-link" data-slide="prev">Vorheriges Bild</a>
                    </li>
                    <li>
                        <a href="#mvc-netbeans-carousel" class="nav-link" data-slide-to="0">Nochmal von vorne</a>
                    </li>
                </ul>
                <div id="mvc-netbeans-carousel" class="carousel slide" style="margin-bottom: 1em;" data-interval="false">
                    <div class="carousel-inner">
                        <div class="carousel-item active">
                            <p>
                                Starte Netbeans und w√§hle im <tt>File</tt>-Men√º <tt>New Project‚Ä¶</tt> aus.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-01.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Als Projekttyp solltest du <b>Web Application</b> in der Kategorie <b>Maven</b> nehmen.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-02.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Gib im n√§chsten Schritt den Namen des Projekts ein und √§ndere ggf. die <tt>Project Location</tt>
                                und das <tt>Package</tt>.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-03.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Die Eintr√§ge im letzten Schritt sollten bereits richtig sein. Du kannst das Projekt daher nun anlegen.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-04.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Die Datei <tt>index.html</tt> solltest du l√∂schen. Wir ersetzen sie durch ein Servlet und eine JSP.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-05.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Doch zun√§chst legen wir eine Persistence Entity an. In Netbeans hei√üt der Eintrag <tt>Entity Class‚Ä¶</tt>.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-06.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Nenne die neue Klasse <tt>GuestbookEntry</tt> und gehe weiter.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-07.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                An dieser Stelle kannst du alles so lassen, wie es ist. Wir konfigurieren
                                die Datenbankverbindung im n√§chsten Schritt manuell.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-08.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                √ñffne die Datei <tt>persistence.xml</tt> im Ordner <tt>Other Sources</tt> ‚Üí <tt>src/main/resources</tt>
                                und tausche sie durch folgendes XML aus. Dadurch wei√ü die Anwendung, wie sie auf die Datenbank zugreifen kann.
                            </p>
                            <img src="netbeans-persistence.xml.png" class="active d-block" style="max-width: 100%; margin-bottom: 1em;" />
                            <source-code language="xml">
                                &lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
                                &lt;persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"&gt;
                                    &lt;persistence-unit name="default" transaction-type="JTA"&gt;
                                        &lt;provider&gt;org.apache.openjpa.persistence.PersistenceProviderImpl&lt;/provider&gt;
                                        &lt;jta-data-source&gt;Default-Database-Managed&lt;/jta-data-source&gt;
                                        &lt;non-jta-data-source&gt;Default-Database-Unmanaged&lt;/non-jta-data-source&gt;

                                        &lt;properties&gt;
                                            &lt;property name="javax.persistence.schema-generation.database.action" value="create"/&gt;
                                            &lt;property name="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true)" /&gt;
                                        &lt;/properties&gt;
                                    &lt;/persistence-unit&gt;
                                &lt;/persistence&gt;
                            </source-code>
                        </div>
                        <div class="carousel-item">
                            <p>
                                Nicht zwingend notwendig aber empfohlen ist, im gleichen Ordner noch eine Datei namens <tt>orm.xml</tt>
                                mit folgendem Inhalt anzulegen. Dadurch werden Konflikte mit anderen Anwendungen in der Datenbank vermieden.
                            </p>
                            <img src="netbeans-orm.xml.png" class="active d-block" style="max-width: 100%; margin-bottom: 1em;" />
                            <source-code language="xml">
                                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                                &lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
                                                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                                                 xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_1_0.xsd"
                                                 version="1.0"&gt;

                                    &lt;persistence-unit-metadata&gt;
                                        &lt;persistence-unit-defaults&gt;
                                            &lt;!-- Dieser Wert muss f√ºr jede Anwendung ein anderer sein! --&gt;
                                            &lt;schema&gt;GAESTEBUCH_MVC_BEISPIEL&lt;/schema&gt;
                                        &lt;/persistence-unit-defaults&gt;
                                    &lt;/persistence-unit-metadata&gt;

                                &lt;/entity-mappings&gt;
                            </source-code>
                        </div>
                        <div class="carousel-item">
                            <p>
                                Den Quellcode kannst du aus der vorherigen Folie kopieren.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-09.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Weiter geht es mit der Enterprise Java Bean. Hierf√ºr legst du am besten einfach eine leere Klasse an.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-10.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Nenne die Klasse <tt>GuestbookBean</tt> und best√§tige das Fenster.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-11.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Auch hier kannst du den Quellcode aus der vorherigen Folie kopieren.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-12.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Weiter geht es mit dem Servlet. Lege auch hierf√ºr eine <tt>Empty Class‚Ä¶</tt> anstelle eines <tt>Servlet‚Ä¶</tt> an.
                                Denn sonst generiert Netbeans viel zu viel unn√∂tigen Quellcode!
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-13.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Die Klasse hei√üt (Trommelwirbel bitte ü•Å): <tt>GuestbookServlet</tt>.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-14.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Nun kommt die Java Server Page.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-15.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Sie hei√üt einfach nur <tt>guestbook</tt>. Die Dateiendung erg√§nzt Netbeans von alleine.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-16.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Das Stylesheet kannst du in eine neue, leere Datei mit dem Namen <tt>style.css</tt> kopieren.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-17.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Nun solltest du die Anwendung √ºber das gr√ºne Play-Symbol
                                <span style="color: lawngreen; text-shadow: 1px 1px 1px rgba(0,0,0,0.5);">‚ñ∂Ô∏è</span> starten k√∂nnen.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-18.png" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Wenn alles gut geht, sollte der Browser dann folgendes Bild anzeigen.
                            </p>
                            <img class="active d-block w-100" src="mvc-beispiel-ergebnis.jpg" />
                        </div>
                        <div class="carousel-item">
                            <p>
                                Das war's auch schon.
                                Zwar waren das jetzt schon einige Schritte.
                                Daf√ºr ist das Projekt von Anfang an sauber gegliedert.
                                üßΩüõÄüßπ‚ú®
                            </p>
                            <img class="active d-block w-25 m-auto" src="../../finish.svg" />
                        </div>
                    </div>
                </div>

                <p>
                    <small>
                        <small>
                            Bildnachweis f√ºr das Endesymbol: <a href="https://pixabay.com/en/symbol-gui-internet-internet-page-2480163/" target="_blank">Pixabay: janf93</a>
                        </small>
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Auf dieser Folie siehst du Schritt f√ºr Schritt, wie du das Beispiel von Eben nachbauen kannst. ‚õ∞Ô∏è
                    Im Prinzip ist es ganz einfach. Du legst einfach ein neues Webprojekt an und kopierst die Quellcodes
                    aus der vorherigen Folie hinein. In Vorbereitung auf sp√§tere Projekte nutzen wir hier allerdings
                    den Projekttyp <b>Web Application</b> aus der Kategorie <b>Maven</b>. Am Anfang macht das zwar noch
                    keinen Unterschied. Sp√§ter k√∂nnen wir dadurch aber ganz einfach weitere Bibliotheken in unsere Projekte
                    einbinden, ohne sie manuell herunterladen zu m√ºssen.
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 2: Deine erste Enterprise Java Bean</h1>
            <article>
                <p>
                    Lege in Netbeans ein <a href="#11">Maven Java-Webprojekt</a> an und probiere folgende Sachen aus:
                </p>

                <ol>
                    <li>
                        L√∂sche die Datei <tt>index.html</tt> aus dem Ordner <tt>Web Pages.</tt>
                    </li>
                    <li>
                        Stattdessen kopiere die Dateien <tt>guestbook.jsp</tt> und <tt>style.css</tt> in das Projekt.
                    </li>
                    <li>
                        Lege die Klassen <tt>GuestbookEntry</tt>, <tt>GuestbookBean</tt> und <tt>GuestbookSerlvet</tt> wie gezeigt an.
                    </li>
                    <li>
                        Lege die beiden Konfigurationsdateien <tt>persistence.xml</tt> und <tt>orm.xml</tt> wie gezeigt an.
                    </li>
                    <li>
                        Starte die Anwendung und schaue, ob alles fehlerfrei funktioniert.
                    </li>
                </ol>

                <img src="mvc-beispiel-netbeans.png" class="d-block img-thumbnail" style="width: 100%;" />
            </article>
            <aside>
                <p>
                    Bevor wir weiter in den Quellcode eintauchen, solltest du erst versuchen, das eben
                    gezeigte Beispiel zum Laufen zu bekommen. Starte daher Netbeans und befolge alle
                    Schritte wie eben gesehen. üêà
                </p>
                <img src="../../github_atom.png" class="img-fluid d-block"/>
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://atom.io/" target="_blank">Atom Webseite</a>
                    </small>
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 3: Ein kleines MVC-Quiz</h1>
            <article>
                <h2>Aufgabe 3.1: Allgemeine Fragen</h2>

                <p>
                    a) Welche Architekturans√§tze kommen f√ºr serverseitige Webanwendungen in Frage?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Alle Logik auf dem Server belassen und auch das HTML auf dem Server generieren.
                    </li>
                    <li>
                        Das HTML im Browser generieren, jedoch die fachlichen Funktionen auf dem Server lassen.
                    </li>
                    <li>
                        Das HTML im Browser generieren und auch die fachlichen Funktionen im Browser ausf√ºhren.
                    </li>
                    <li>
                        Einen Native Client f√ºr unterschiedliche Betriebssysteme mit dem Server als Backend entwickeln.
                    </li>
                </ol>

                <p>
                    b) Wof√ºr steht die Abk√ºrzung MVC?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Model-View-Component
                    </li>
                    <li>
                        Make-Visual-Controllers
                    </li>
                    <li>
                        Many-Versatile-Classes
                    </li>
                    <li>
                        Model-View-Controller
                    </li>
                    <li>
                        Jeden Morgen viel Chaos
                    </li>
                </ol>

                <p>
                    c) Welche Aufgaben √ºbernimmt der Controller bei MVC?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Er beinhaltet die fachliche Anwendungslogik.
                    </li>
                    <li>
                        Er beinhaltet das Datenmodell der Anwendung.
                    </li>
                    <li>
                        Er vermittelt zwischen Model und View.
                    </li>
                    <li>
                        Er reagiert auf entfernte Methodenaufrufe.
                    </li>
                </ol>

                <p>
                    d) Welche Aufgaben √ºbernimmt das Model bei MVC?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Es ist sch√∂n anzusehen. üëí
                    </li>
                    <li>
                        Es beinhaltet die fachliche Anwendungslogik.
                    </li>
                    <li>
                        Es beinhaltet das Datenmodell der Anwendung.
                    </li>
                    <li>
                        Es vermittelt zwischen View und Controller.
                    </li>
                    <li>
                        Es reagiert auf Webservice-Aufrufe.
                    </li>
                </ol>

                <h2>Aufgabe 3.2: MVC-Webanwendungen mit Java</h2>

                <p>
                    a) Welcher Teil einer Webanwendung entspricht dem Model?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Die Servlets
                    </li>
                    <li>
                        Die Java Server Pages und HTML-Seiten
                    </li>
                    <li>
                        Die Enterprise Java Beans
                    </li>
                    <li>
                        Die Persistence Entities
                    </li>
                    <li>
                        Die sonstigen Klassen der Anwendung
                    </li>
                </ol>

                <p>
                    b) Welcher Teil einer Webanwendung entspricht dem Controller?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Die Servlets
                    </li>
                    <li>
                        Die Java Server Pages und HTML-Seiten
                    </li>
                    <li>
                        Die Enterprise Java Beans
                    </li>
                    <li>
                        Die Persistence Entities
                    </li>
                    <li>
                        Die sonstigen Klassen der Anwendung
                    </li>
                </ol>

                <p>
                    c) Welche Annotation kennzeichnet eine Persistence Entity?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <code>@PersistenceUnit</code>
                    </li>
                    <li>
                        <code>@EntityManager</code>
                    </li>
                    <li>
                        <code>@DatabaseTable</code>
                    </li>
                    <li>
                        <code>@Entity</code>
                    </li>
                    <li>
                        <code>@ORMappedBean</code>
                    </li>
                </ol>

                <p>
                    d) Welche Annotation kennzeichnet eine Stateless Session Bean?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <code>@Stateless</code>
                    </li>
                    <li>
                        <code>@Bean</code>
                    </li>
                    <li>
                        <code>@SessionBean</code>
                    </li>
                    <li>
                        <code>@EJB</code>
                    </li>
                    <li>
                        <code>@ModelBean</code>
                    </li>
                </ol>

                <p>
                    e) Mit welcher Annotation erh√§lt man eine Referenz auf eine Enterprise Java Bean?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <code>@Object</code>
                    </li>
                    <li>
                        <code>@Reference</code>
                    </li>
                    <li>
                        <code>@Inject</code>
                    </li>
                    <li>
                        <code>@Bean</code>
                    </li>
                    <li>
                        <code>@EJB</code>
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>L√∂sung:</b> Aufgabe 3.1: 1 + 2, 4, 3, 2 + 3; Aufgabe 3.2: 3 + 4, 1, 4, 1, 5
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Na zum Gl√ºck war vieles eine Wiederholung aus Webprogrammierung.
                    Ein paar Sachen waren dann doch aber neu, so dass wir dein neu
                    erworbenes Wissen gleich mal testen wollen. ü•û
                </p>
            </aside>
        </section>

        <!--
            ===============================
            ENTERPRISE JAVA BEANS IM DETAIL
            ===============================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Enterprise Java Beans im Detail</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Mehr als nur Stateless Session Beans</h1>
            <article>
                <div class="container-fluid">
                    <div class="row">
                        <div class="col-md">
                            <div class="img-thumbnail" style="padding: 0.5em; height: 100%; display: flex; flex-direction: column;">
                                <h3>Singleton Session Beans</h3>
                                <table style="margin-bottom: 1em;">
                                    <tr>
                                        <td style="padding-right: 0.5em;">‚òï</td>
                                        <td>
                                            Eine Instanz f√ºr alle Clients
                                        </td>
                                    </tr>
                                    <tr>
                                        <td style="padding-right: 0.5em;">‚òï</td>
                                        <td>
                                            Threadsicherheit beachten!
                                        </td>
                                    </tr>
                                </table>
                                <source-code language="java">
                                    @Singleton
                                    public class CityBean {
                                        // ‚Ä¶
                                    }
                                </source-code>
                                <div style="flex: 1;"></div>
                                <img src="ejb-singleton.png" alt="" class="d-block" style="width: 100%;" />
                            </div>
                        </div>
                        <div class="col-md">
                            <div class="img-thumbnail" style="padding: 0.5em; height: 100%; display: flex; flex-direction: column;">
                                <h3>Stateless Session Beans</h3>
                                <table style="margin-bottom: 1em;">
                                    <tr>
                                        <td style="padding-right: 0.5em;">‚òï</td>
                                        <td>
                                            Geteilte Instanzen f√ºr alle Clients
                                        </td>
                                    </tr>
                                    <tr>
                                        <td style="padding-right: 0.5em;">‚òï</td>
                                        <td>
                                            Meistens die beste Wahl
                                        </td>
                                    </tr>
                                </table>
                                <source-code language="java">
                                    @Stateless
                                    public class CountryBean {
                                        // ‚Ä¶
                                    }
                                </source-code>
                                <div style="flex: 1;"></div>
                                <img src="ejb-stateless.png" alt="" class="d-block" style="width: 100%;" />
                            </div>
                        </div>
                        <div class="col-md">
                            <div class="img-thumbnail" style="padding: 0.5em; height: 100%; display: flex; flex-direction: column;">
                                <h3>Stateful Session Beans</h3>
                                <table style="margin-bottom: 1em;">
                                    <tr>
                                        <td style="padding-right: 0.5em;">‚òï</td>
                                        <td>
                                            Jedem Kind sein Luftballon üéà
                                        </td>
                                    </tr>
                                    <tr>
                                        <td style="padding-right: 0.5em;">‚òï</td>
                                        <td>
                                            Verbraucht viele Ressourcen
                                        </td>
                                    </tr>
                                </table>
                                <source-code language="java">
                                    @Stateful
                                    public class RiverBean {
                                        // ‚Ä¶
                                    }
                                </source-code>
                                <div style="flex: 1;"></div>
                                <img src="ejb-stateful.png" alt="" class="d-block" style="width: 100%;" />
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md">
                            <p>
                                <b>Doch Vorsicht!</b> Der Client einer Bean ist immer nur ihr direkter Verwender.
                                Gerade bei <span style="color: darkred;">Stateful Session Beans</span> macht das
                                einen Unterschied, wie die folgende Abbildung zeigt. <code>@Stateful</code> alleine
                                reicht nicht aus, um eine Bean einem einzelnen Besucher einer Webseite zuzuordnen.
                                Hierf√ºr muss die Bean manuell erzeugt und in der Session abgelegt werden.
                            </p>
                            <img src="ejb-clients.png" alt="Verschiedene Aufrufketten f√ºr EJBs" class="d-block" style="width: 100%;" />
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    <code>@Stateless</code> ist nicht die einzige Annotation, die eine Klasse zur Enterprise Java Bean macht.
                    Sie kennzeichnet eigentlich nur eine bestimmte Art von EJBs, n√§mlich die <b>Stateless Session Beans</b>.
                    Insgesamt gibt es noch folgende Arten:
                </p>
                <ul>
                    <li>
                        <code>@Singleton</code>: Singleton Session Beans
                    </li>
                    <li>
                        <code>@Stateles</code>: Stateless Session Beans
                    </li>
                    <li>
                        <code>@Stateful</code>: Stateful Session Beans
                    </li>
                    <li>
                        <code>@MessageDriven</code>: Message Driven Beans
                    </li>
                </ul>
                <p>
                    Anstelle von <code>@Stateless</code> verwendet man dann einfach eine der anderen
                    Annotationen, zum Beispiel so:
                </p>
                <source-code language="java">
                    @Singleton
                    public class VisitorCounterBean {
                        // Fachliche Methoden der Bean
                    }
                </source-code>

                <h2>Die verschiedenen Beantypen</h2>
                <p>
                    Soweit alles sch√∂n und gut. Doch was hat es mit diesen verschiedenen Beantypen auf sich? ü§î
                    Warum gibt es √ºberhaupt verschiedene Arten und welche soll man nehmen?
                </p>

                <h3>Singleton Session Beans</h3>
                <p>
                    Dies ist die einfachste Art von allen. Der Server erzeugt genau ein Objekt von der Klasse
                    (vgl. <a href="https://de.wikipedia.org/wiki/Singleton_(Entwurfsmuster)" target="_blank">Singleton-Entwurfsmuster</a>)
                    und l√§sst die Clients darauf zugreifen. Arbeiten mehrere Clients gleichzeitig mit der Bean, startet der Server
                    hierf√ºr unterschiedliche Threads. Die Klasse muss daher absolut und 100%ig threadsicher programmiert sein!
                </p>

                <h3>Stateless Session Beans</h3>
                <p>
                    Bei Stateless Session Beans sind die Anforderungen an die Threadsicherheit nicht ganz so streng, da jeder Client
                    eine eigene Objektinstanz auf dem Server zugewiesen bekommt. Es kann also nicht passieren, dass die Methoden ein
                    und derselben Instanz in unterschiedlichen Threads gleichzeitig ausgef√ºhrt werden. Jedoch kann es passieren, dass
                    die verschiedenen Instanzen in unterschiedlichen Threads laufen. <span style="color: crimson">‚ô®Ô∏è</span>
                    Die Klasse muss im Zweifelsfall also immer noch threadsicher sein.
                </p>
                <p>
                    Hinzu kommt, dass sich ein Client niemals darauf verlassen kann, bei mehreren Methodenaufrufen immer dieselbe Objektinstanz
                    zugewiesen zu bekommen. Denn im Hintergrund erzeugt der Server gleich mehrere Objekte (einen sogenannten Pool) und
                    weist dem Client bei jedem Aufruf eine Instanz zu, die zu diesem Zeitpunkt gerade nicht verwendet wird. Man kann sich
                    in der Klasse also nicht mal eben einen Wert f√ºr sp√§ter merken. Dies muss immer in der HTTP-Session des Servlets oder
                    in der Datenbank erfolgen.
                </p>

                <h3>Stateful Session Beans</h3>
                <p>
                    Stateful Session Beans, man kann es sich schon denken, geh√∂ren immer genau einem Client. Hier erzeugt der Server f√ºr
                    jeden Client ein eigenes Objekt und stellt sicher, dass alle Methodenaufrufe immer von derselben Objektinstanz
                    beantwortet werden. Sie belegen somit deutlich mehr Ressourcen auf dem Server und sollten nur verwendet werden,
                    wenn es wirklich zwingend erforderlich ist.
                </p>
                <p>
                    An dieser Stelle ist jedoch Vorsicht geboten! Bei Stateful Session Beans ist mit dem Client nicht zwingend der
                    Anwender am Bildschirm gemeint. Gerade bei Webanwendungen handelt es sich beim Client in der Regel um ein Servlet,
                    von dem es meistens nur eine Objektinstanz f√ºr alle User gibt. B√∂se Falle! ü¶ä Will man daher eine Stateful Session
                    Bean in einer Webanwendung nutzen, muss man sich die Bean-Instanz manuell besorgen und in der HTTP Session ablegen.
                    Folgender Quellcode wird hierf√ºr ben√∂tigt:
                </p>
                <source-code language="java">
                    @WebServlet
                    public class StatefulBeanServlet extends HttpServlet {

                        @Override
                        public void doGet(‚Ä¶) {
                            // Bean-Instanz besorgen und im Session Context ablegen
                            HttpSession session = request.getSession();
                            MisterBean misterBean = (MisterBean) session.getAttribute("misterBean");

                            if (misterBean == null) {
                                try {
                                    InitialContext ctx = new InitialContext();
                                    misterBean = (MisterBean) ctx.lookup("java:global/NameDerApp/NameDerBean");
                                } catch (NamingException ex) {
                                    throw new ServletException(ex);
                                }

                                session.setAttribute("misterBean", misterBean);
                            }

                            // Bean verwenden
                            ‚Ä¶
                        }
                    }
                </source-code>

                <p>
                    Damit greifst du √ºber die Klasse <code>InitialContext</code> auf
                    <a href="https://de.wikipedia.org/wiki/Java_Naming_and_Directory_Interface" target="_blank">den Namensdienst des Servers</a>
                    zu und besorgst dir eine neue Objektinstanz der Bean. Welchen Namen du dabei bei <code>ctx.lookup()</code> mitgegeben musst,
                    siehst du, wenn du das Serverprotokoll beim Start der Anwendung durchschaust. Stichwort: ‚ÄûPortable JNDI Name‚Äù.
                </p>

                <h3>Message Driven Beans</h3>
                <p>
                    Der Name ver√§t schon, dass es sich hierbei nicht um Session Beans wie bei all den anderen handelt.
                    Und das ist auch richtig so, denn im Gegensatz zu den anderen Arten verbindet sich eine Message
                    Driven Bean immer mit einem ‚ÄûMessage Broker‚Äù (auch ‚ÄûMessage Server‚Äù) genannt, um asynchrone
                    Nachrichten √ºber eine FIFO-Queue zu empfangen (vgl. <a href="#4">Folie 4</a>). üì®
                    Dieses Programmiermodell schauen wir uns ggf. ein anderes mal an. üî≠
                </p>

                <h2>Und welche soll ich nehmen?</h2>
                <p>
                    Das ist eigentlich ganz einfach. Eigentlich solltest du immer <b>Stateless Session Beans</b> nehmen,
                    es sei denn, du bist dir ganz sicher, einen anderen Typ zu ben√∂tigen. <b>Stateful Session Beans</b>
                    solltest du hingegen nur verwenden, wenn du diesen Typ wirklich ben√∂tigst.
                </p>
                <p>
                    <b>Singleton Session Beans</b> k√∂nnen eine leichtgewichtige Alternative zu Stateless Session Beans
                    sein, wenn du dir absolut sicher bist, dass deine Klasse threadsicher ist. Doch vorzeitige Optimierung
                    ist ja bekanntlich die Wurzel allen √úbels. Wenn es also keinen konkreten Grund gibt, solltest du
                    einfach bei Stateless Session Beans bleiben.
                </p>
                <p>
                    Und die <b>Message Driven Beans</b> tanzen sowieso aus der Reihe, so dass sie hier zun√§chst nicht in
                    Betracht kommen. üíÉüèª
                </p>
            </aside>
        </section>

        <section>
            <h1>Nur f√ºr Zuhause: EJBs mit No-Interface View</h1>
            <article>
                <p>
                    So haben unsere Enterprise Java Beans bisher ausgesehen:
                </p>
                <source-code language="java">
                    @Stateless
                    public class ArticleInformationBean {

                        public Article findArticle(long id) { ‚Ä¶ }
                        public List&lt;Article&gt; searchArticles(String search) { ‚Ä¶ }
                        ‚Ä¶

                    }
                </source-code>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">üî∞</td>
                        <td>
                            Sie besitzen kein Interface und erben von keiner Klasse.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">üî∞</td>
                        <td>
                            Sie sind deshalb nicht wirklich austauschbar.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">üî∞</td>
                        <td>
                            Sie k√∂nnen nicht √ºber Rechnergrenzen hinweg aufgerufen werden.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">üî∞</td>
                        <td>
                            Auch nicht aus anderen Webanwendungen desselben Servers heraus.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">üî∞</td>
                        <td>
                            Sie existieren lediglich innerhalb der eigenen Webanwendung.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">‚ò∫Ô∏è</td>
                        <td>
                            Und das ist v√∂llig okay so!
                        </td>
                    </tr>
                </table>
            </article>
            <aside>
                <p>
                    Auf <a href="#4">Folie 4</a> steht, dass Softwarekomponenten austauschbar sein sollten, so dass man
                    ohne gro√üen Aufwand eine vorhandene Komponente sp√§ter durch eine andere ersetzen kann. Beispielsweise
                    k√∂nnte man eine Komponente zur Zahlungsabwicklung irgendwann durch eine verbesserte Version
                    mit weiteren Zahlungsoptionen austauschen wollen. Doch wie soll das gehen, wenn unsere Enterprise
                    Java Beans ganz einfache Javaklassen sind, die weder von einer anderen Klasse erben noch irgendein
                    Interface implementieren? ü§î
                </p>
                <p>
                    Die Antwort ist: Es geht nicht und das ist auch gut so.
                </p>
                <p>
                    <i>
                        ‚Äì Wirklich!? Aber dann man m√ºsste ja alle Stellen anpassen, an denen eine EJB verwendet wird, um
                        sie auszutauschen ‚Ä¶
                    </i>
                    <span style="font-weight: bold; color: crimson; text-shadow: 1px 1px 1px rgba(0,0,0,0.5);">‚ùì‚ùì‚ùì</span>
                </p>
                <p>
                    Ja das m√ºsste man und das w√§re auch ziemlich aufw√§ndig. üòé
                </p>
                <p>
                    <i>
                        ‚Äì Aber warum soll das dann gut sein?
                    </i>
                </p>
                <p>
                    Weil Java einen nicht zwingt, austauschbare Komponenten zu schreiben, wenn man sie nicht braucht.
                    Unsere bisherigen EJBs besitzen kein sogenanntes <b>Business Interface</b> und sind somit weder
                    entfernt aufrufbar noch einfach austauschbar. Das ist aber v√∂llig okay, denn oftmals will man das
                    auch gar nicht und dann schreibt man eben Beans ohne Interface. Auf fachchinesisch üá®üá≥ hei√üt das
                    <b>Local No-Interface View</b>.
                </p>
            </aside>
        </section>

        <section>
            <h1>Wann braucht man ein Business Interface?</h1>
            <article>
                <table style="margin-bottom: 2em;">
                    <tr>
                        <td style="padding-right: 0.5em;">üê¶</td>
                        <td>
                            Soll eine EJB austauschbar sein, m√ºssen ihre Methoden in einem Business Interface deklariert werden.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">üê¶</td>
                        <td>
                            Das Interface kann dabei ein <b>Local Interface</b> oder ein <b>Remote Interface</b> sein.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">üê¶</td>
                        <td>
                            Die Verwender der Bean d√ºrfen sich dann nur auf das Interface und niemals auf die Klasse beziehen.
                        </td>
                    </tr>
                </table>

                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "interfaces-local-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#interfaces-local"
                                role          = "tab"
                                aria-controls = "interfaces-local"
                                aria-expanded = "true"
                            >
                                Local Interface
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "interfaces-remote-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#interfaces-remote"
                                role          = "tab"
                                aria-controls = "interfaces-remote"
                            >
                                Remote Interface
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "interfaces-mehrere-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#interfaces-mehrere"
                                role          = "tab"
                                aria-controls = "interfaces-mehrere"
                            >
                                Mehrere Implementierungen
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content">
                        <!-- Local Interface -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "interfaces-local"
                            role            = "tabpanel"
                            aria-labelledby = "interfaces-local-tab"
                        >
                            <p>
                                Ein <b>Local Interface</b> definiert Methoden, die innerhalb derselben JVM aufrufbar sind.
                                Der Aufrufer kann dabei auch Teil einer anderen Anwendung sein, solange sie im selben Server
                                in derselben JVM l√§uft.
                            </p>
                            <source-code language="java">
                                /**
                                 * Deklaration der verf√ºgbaren Business Methoden als Local Interface
                                 */
                                @Local
                                public interface Payment {
                                    List&lt;String&gt; getSupportedPaymentMethods();
                                    PaymentResult payDueAmount(String method, double amount);
                                }

                                /**
                                 * Erste Version unseres Bezahldienstes
                                 */
                                @Stateless
                                public class PaymentBeanV1 implements Payment {
                                    List&lt;String&gt; getSupportedPaymentMethods() { ‚Ä¶ }
                                    PaymentResult payDueAmount(String method, double amount) { ‚Ä¶ }
                                }

                                /**
                                 * Verwendung des Dienstes innerhalb einer anderen EJB
                                 */
                                @Stateless
                                public class ShoppingCartBean {

                                    // Hier nur das Interface angeben!
                                    @EJB
                                    private Payment payment;
                                    ‚Ä¶
                                }
                            </source-code>
                        </div>
                        <!-- Remote Interface -->
                        <div
                            class           = "tab-pane fade"
                            id              = "interfaces-remote"
                            role            = "tabpanel"
                            aria-labelledby = "interfaces-remote-tab"
                        >
                            <p>
                                Ein <b>Remote Interface</b> definiert Methoden, die auch √ºber JVM- und Rechnergrenzen hinweg aufrufbar sind.
                                Dies wird heutzutage zugunsten von Webservices aber nur noch selten gemacht.
                            </p>
                            <source-code language="java">
                                /**
                                 * Deklaration der entfernt aufrufbaren Business Methoden als Remote Interface
                                 */
                                @Remote
                                public interface MovieSearch {
                                    List&lt;Movie&gt; searchMovies(String search);
                                }

                                /**
                                 * Implementierende Enterprise Java Bean
                                 */
                                @Stateless
                                public class MovieSearchBean implements MovieSearch {
                                    List&lt;Movie&gt; searchMovies(String search) { ‚Ä¶ }
                                }

                                /**
                                 * Verwendung der Bean in einem Servlet
                                 */
                                @WebServlet(urlPatterns={"/search/"})
                                public class MovieSearchServlet extends HttpServlet {

                                    // Hier nur das Interface angeben
                                    @EJB
                                    private MovieSearch search;
                                    ‚Ä¶
                                }
                            </source-code>
                        </div>
                        <!-- Mehrere Implementierungen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "interfaces-mehrere"
                            role            = "tabpanel"
                            aria-labelledby = "interfaces-mehrere-tab"
                        >
                            <p>
                                Gibt es mehrere Implementierungen zum selben Interface, m√ºssen diese √ºber einen zus√§tzlichen Namen
                                auseinander gehalten werden. Der Name muss innerhalb der gesamten Anwendung eindeutig sein und
                                darf nur f√ºr eine EJB-Klasse verwendet werden.
                            </p>
                            <source-code language="java">
                                /**
                                 * Ein einfaches Business Interface
                                 */
                                @Local
                                public interface ReadProductData {
                                    public Map&lt;String, String&gt; getProductData(long articleId);
                                }

                                /**
                                 * Besondere Implementierung f√ºr Administratoren
                                 */
                                @Stateless(name="ReadProductData-Admin")
                                public class ReadProductDataAdminBean implements ReadProductData {
                                    public Map&lt;String, String&gt; getProductData(long articleId) { ‚Ä¶ }
                                }

                                /**
                                 * Einfache Version f√ºr normale Anwender
                                 */
                                @Stateless(name="ReadProductData-SimpleUser")
                                public class ReadProductDataSimpleUserBean implements ReadProductData {
                                    public Map&lt;String, String&gt; getProductData(long articleId) { ‚Ä¶ }
                                }

                                /**
                                 * Verwendung der Version f√ºr Administratoren
                                 */
                                @WebServlet(urlPatterns={"/admin/product/*"})
                                public class UserProfileAdminServlet extends HttpServlet {

                                    // Interface plus der richtige Name
                                    @EJB(beanName="ReadProductData-Admin")
                                    private ReadProductData readProductData;
                                    ‚Ä¶
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Falls man dann doch einmal austauschbare Komponenten schreiben will, kann man die Methoden
                    der EJBs ganz einfach in einem <b>Business Interface</b> deklarieren und eine oder mehrere
                    Enterprise Java Beans schreiben, die das Interface implementieren. So wie man das in Java
                    eben immer machen w√ºrde, wenn mehrere Klassen dieselbe Schnittstelle besitzen sollen. Auf
                    Seiten der Verwender muss man dann nur aufpassen, sich sch√∂n immer nur auf das Interface
                    und niemals auf direkt auf die Klassen zu beziehen. Jedoch steht man noch vor der Wahl,
                    ob man das Interface als Local oder Remote kennzeichnet (beides zusammen ist nicht erlaubt):
                </p>
                <ul>
                    <li>
                        Ein <b>Local Interface</b> schreibt Methoden vor, die nur innerhalb derselben JVM¬π
                        aufgerufen werden k√∂nnen. Der Aufrufer muss dabei nicht zur selben Anwendung geh√∂ren,
                        muss aber im selben Server innerhalb derselben JVM laufen.
                    </li>
                    <li>
                        Die Methoden eines <b>Remote Interface</b> hingegen k√∂nnen auch √ºber JVM- und Rechnergrenzen
                        hinweg aufgerufen werden. Dies wird heutzutage aber zugunsten von Webservices gar nicht mehr
                        so h√§ufig genutzt.
                    </li>
                </ul>
                <p>
                    <small>
                        ¬π Java Virtual Machine
                    </small>
                </p>
                <p>
                    Wurde diese Entscheidung getroffen, muss man eigentlich nur noch <code>@Local</code> oder
                    <code>@Remote</code> vor das Interface schreiben. Ungef√§hr so:
                </p>
                <source-code language="java">
                    @Local
                    public interface ProductRating {
                        void rateProduct(long productId, int amountStars);
                        double getAverageStars(long productId);
                    }

                    @Stateless
                    public class SimpleProductRatingBean
                    implements ProductRating {
                        void rateProduct(long productId, int amountStars) { ‚Ä¶ }
                        double getAverageStars(long productId) { ‚Ä¶ }
                    }
                </source-code>
                <p>
                    Als Verwender bezieht man sich dann nur auf das Interface:
                </p>
                <source-code language="java">
                    @WebServlet(urlPatterns={"index.html"})
                    public class ProductRatingServlet extends HttpServlet {

                        @EJB
                        private ProductRating productRatingBean;
                        ‚Ä¶
                    }
                </source-code>
                <p>
                    Hat man hingegen mehrere Klassen, die dasselbe Interface implementieren, muss man sie
                    √ºber einen zus√§tzlichen Namen auseinanderhalten. Der Name muss dabei innerhalb der
                    gesamten Anwendung eindeutig sein und darf nur f√ºr eine EJB-Klasse verwendet werden.
                </p>
                <source-code language="java">
                    @Stateless(name="ProductRating-Simple")
                    public class SimpleProductRatingBean
                    implements ProductRating {
                        ‚Ä¶
                    }

                    @Stateless(name="ProductRating-Sophisticated")
                    public class SophisticatedProductRatingBean
                    implements ProductRating {
                        ‚Ä¶
                    }

                    @WebServlet(urlPatterns={"index.html"})
                    public class ProductRatingServlet extends HttpServlet {

                        // Interface plus der richtige Name
                        @EJB(beanName="ProductRating-Simple")
                        private ProductRating productRatingBean;
                        ‚Ä¶
                    }
                </source-code>
                <p>
                    Und schwuppdiwupp hat man austauschbare Softwarekomponenten. üí´
                </p>
            </aside>
        </section>

        <section>
            <h1>Woher kommen eigentlich die EJB-Objekte?</h1>
            <article>
                <div class="container-fluid">
                    <div class="row">
                        <div class="col-md">
                            <img src="dependency-injection-01.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                            <small>
                                Woher kommen die EJB-Objekte!?
                            </small>
                        </div>
                        <div class="col-md">
                            <img src="dependency-injection-02.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                            <small>
                                Die Variablen m√ºssten doch leer sein.
                            </small>
                        </div>
                        <div class="col-md">
                            <img src="dependency-injection-03.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                            <small>
                                Ist es Zauberei?
                            </small>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md">
                            <p>
                                Nat√ºrlich ist es keine Zauberei. üëª
                                Das Prinzip, dass alle mit <code>@EJB</code> ausgezeichneten Variablen automatisch mit Inhalten versorgt werden,
                                nennt sich <b>Dependency Injection</b>. Es handelt sich dabei um eine Anwendung von Inversion of Control bzw. dem
                                Hollywood-Prinzip. Um zu verstehen, was hier passiert, musst du den Lebenszyklus von Enterprise Java Beans kennen:
                            </p>
                        </div>
                    </div>

                    <div class="row" style="margin-bottom: 0;">
                        <div class="col-md">
                            <source-code language="java">
                                @Stateful
                                public class GenieTheGhostBean {

                                    @EJB
                                    private MagicLampBean lamp;

                                    public GenieTheGhostBean {
                                        // Konstruktor: Hier ist this.lamp noch null!
                                    }

                                    @PostConstruct
                                    public void onInit() {
                                        // Ersatz f√ºr den Konstruktor: Hier ist this.lamp gef√ºllt!
                                    }

                                    @PreDestroy
                                    public void onDestroy() {
                                        // Die Bean wird gleich verworfen
                                    }

                                    public void placeFirstWish(String wish) {
                                        // Normale Business Methode
                                    }

                                    public void placeSecondWish(String wish) {
                                        // Normale Business Methode
                                    }

                                    @Remove
                                    public void placeThirdWish(String wish) {
                                        // Nachdem der Client diese Methode aufgerufen hat, verschwindet die Bean.
                                        // @Remove ist daher nur in Stateful Session Beans erlaubt.
                                    }

                                    @Remove
                                    public void leaveMeAlone() {
                                        // Bewirkt ebenfalls, dass die Bean verschwindet.
                                    }
                                }
                            </source-code>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md">
                            <small>
                                <small>
                                    Bildnachweise:
                                    <a href="https://pixabay.com/en/suit-business-man-business-man-673697/" target="_blank">Pixabay: RyanMcGuire</a>,
                                    <a href="https://pixabay.com/en/architecture-bridge-building-travel-3121009/" target="_blank">Pixabay: KarstenBergmann</a>,
                                    <a href="https://pixabay.com/en/suit-fashion-businessman-business-3137825/" target="_blank">Pixabay: lebone</a>,
                                    <a href="https://pixabay.com/en/genie-lamp-magic-magical-wishes-1129640/" target="_blank">Pixabay: JooJoo41</a>
                                </small>
                            </small>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Und wohin gehen sie, wenn sie nicht mehr gebraucht werden? üåà Die ganze Zeit schon haben wir gesehen, dass
                    man sich mit <code>@EJB</code> eine Referenz auf eine Enterprise Java Bean besorgen kann, was aber nur geht,
                    wenn die Annotation direkt innerhalb einer Klasse sowie vor einer passend deklarierten Variable steht. Also
                    ungef√§hr so:
                </p>
                <source-code language="java">
                    @Stateless
                    public class ProductCatalogueBean {

                        @EJB
                        private ShoppingCartBean shoppingCart;
                        ‚Ä¶
                    }
                </source-code>
                <p>
                    Dieses Vorgehen nennt sich <b>Dependency Injection</b> und ist ein Musterbeispiel f√ºr einen Programmierstil,
                    der sich
                    <a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank">Inversion of Control</a>
                    oder auch <b>Hollywood-Prinzip</b> nennt. Frei nach dem Motto ‚ÄûDon't call us, we'll call you‚Äù.
                </p>
                <lsx-youtube video="fHDNWf_ws38"></lsx-youtube>
                <p>
                    Im Grunde genommen gibt es hier eigentlich gar nichts Besonderes zu beachten. Man muss nur wissen, dass
                    dadurch nat√ºrlich nicht die Grundgesetze der Sprache Java aufgehoben werden. Das hei√üt, bevor im obigen
                    Beispiel die Dependency Injection laufen kann, muss nat√ºrlich erst mal von allen beteiligten Klassen ein
                    Objekt erzeugt werden. Dies hat zur Folge, dass die Variable zu dem Zeitpunkt, wenn der Konstruktor l√§uft,
                    noch leer ist:
                </p>
                <source-code language="java">
                    @Stateless
                    public class ProductCatalogueBean {

                        @EJB
                        private ShoppingCartBean shoppingCart;

                        public ProductCatalogueBean() {
                            // this.shoppingCart ist hier noch null!
                        }
                    }
                </source-code>
                <p>
                    Aus diesem Grund sollten EJBs eigentlich keinen Konstruktor haben. Stattdessen zeichnet man einfach eine
                    beliebige <code>public</code>-Methode ohne Parameter und ohne R√ºckgabewert mit <code>@PostConstruct</code>
                    aus:
                </p>
                <source-code language="java">
                    @Stateless
                    public class ProductCatalogueBean {

                        @EJB
                        private ShoppingCartBean shoppingCart;

                        @PostConstruct
                        public void onInit() {
                            // Hier ist this.shoppingCart gef√ºllt!
                        }
                    }
                </source-code>
                <p>
                    Analog dazu kann man eine Methode mit <code>@PreDestroy</code> auszeichnen, um den Zeitpunkt abzufangen,
                    kurz bevor das Objekt verschwindet. Doch wann ist das immer der Fall? Logischerweise immer dann, wenn der
                    Server gestoppt wird, oder bei einer Stateful Session Bean, wenn der Client die Bean nicht mehr ben√∂tigt.
                    Es gibt aber noch einen anderen Weg. N√§mlich immer dann, wenn der Client eine Methode aufruft, die mit
                    <code>@Remove</code> ausgezeichnet wurde (ebenfalls nur bei Stateful Session Beans). Also ungef√§hr so:
                </p>
                <source-code language="java">
                    @Stateful
                    public class WishListBean {

                        @PostConstruct
                        public void onInit() {
                            // Die Bean wird gerade instantiiert
                        }

                        @PreDestroy
                        public void onDestroy() {
                            // Die Bean wird gleich verworfen
                        }

                        @Remove
                        public void finishCurrentProcess() {
                            // Sobald der Client diese Methode aufruft, wei√ü Java,
                            // dass die Bean nicht mehr ben√∂tigt wird
                        }

                        @Remove
                        public void abortProcess() {
                            // Bewirkt ebenfalls, dass die Bean verschwindet
                        }
                    }
                </source-code>
                <p>
                    Und damit kennst du ‚Ä¶ die wahre Geschichte. üé© Oder besser gesagt: Den Lebenszyklus einer Enterprise
                    Java Bean.
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 4: Ein kleines EJB-Quiz</h1>
            <article>
                <h2>Aufgabe 4.1: Die verschiedenen Beantypen</h2>

                <p>
                    a) Welche der folgenden Annotationen zeichnet eine Klasse nicht als EJB aus?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <code>@Stateless</code>
                    </li>
                    <li>
                        <code>@Stateful</code>
                    </li>
                    <li>
                        <code>@Singleton</code>
                    </li>
                    <li>
                        <code>@EJB</code>
                    </li>
                    <li>
                        <code>@MessageDriven</code>
                    </li>
                </ol>

                <p>
                    b) Welche Aussage trifft am ehesten auf Stateless Session Beans zu?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Der Server verwaltet einen Pool von Instanzen, die zwischen allen Clients geteilt werden.
                    </li>
                    <li>
                        Jeder Client greift immer auf dieselbe Objektinstanz zu.
                    </li>
                    <li>
                        Der Server h√§lt nur eine Instanz vor, die sich alle Clients teilen.
                    </li>
                </ol>

                <p>
                    c) Und welche Aussage trifft am ehesten auf Stateful Session Beans zu?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Der Server verwaltet einen Pool von Instanzen, die zwischen allen Clients geteilt werden.
                    </li>
                    <li>
                        Jeder Client greift immer auf dieselbe Objektinstanz zu.
                    </li>
                    <li>
                        Der Server h√§lt nur eine Instanz vor, die sich alle Clients teilen.
                    </li>
                </ol>

                <p>
                    d) Was passiert, wenn ein Servlet mit <code>@EJB</code> auf eine Stateful Session Bean zugrefit?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Jeder Aufrufer des Servlets bekommt seine eigene EJB-Instanz zugewiesen.
                    </li>
                    <li>
                        Bei den meisten Servern arbeiten alle Aufrufer mit derselben EJB-Instanz.
                    </li>
                    <li>
                        Die EJB-Instanz wird bei jedem Aufruf des Servlets neu erzeugt.
                    </li>
                </ol>

                <h2>Aufgabe 4.2: Business Interfaces f√ºr EJBs</h2>

                <p>
                    a) Eine EJB ben√∂tigt immer ein Business Interface.
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Wahr
                    </li>
                    <li>
                        Falsch
                    </li>
                </ol>

                <p>
                    b) Welche Annotation kennzeichnet ein Local Interface?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <code>@EJB</code>
                    </li>
                    <li>
                        <code>@LocalInterface</code>
                    </li>
                    <li>
                        <code>@Local</code>
                    </li>
                    <li>
                        <code>@Interface</code>
                    </li>
                </ol>

                <p>
                    c) Und welche Annotation kennzeichnet ein Remote Interface?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <code>@EJB</code>
                    </li>
                    <li>
                        <code>@Remote</code>
                    </li>
                    <li>
                        <code>@Interface</code>
                    </li>
                    <li>
                        <code>@RemoteInterface</code>
                    </li>
                </ol>

                <p>
                    d) Was ist zu tun, wenn mehrere EJB-Klassen dasselbe Business Interface implementieren?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Die Klassen sind √ºber die <code>@EJB</code>-Annotation mit eindeutigen Namen zu versehen.
                    </li>
                    <li>
                        Nichts, Java erkannt am Klassennamen, welches Objekt gemeint ist.
                    </li>
                    <li>
                        Nichts, dieser Fall ist nicht erlaubt.
                    </li>
                </ol>

                <h2>Aufgabe 4.3: Der EJB-Lebenszyklus</h2>

                <p>
                    a) Ab welchem Zeitpunkt sind die mit <code>@EJB</code> gekennzeichneten Variablen gef√ºllt?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Schon bevor der Konstruktor l√§uft
                    </li>
                    <li>
                        Bereit w√§hrend der Konstruktor l√§uft
                    </li>
                    <li>
                        Sp√§testens wenn die <code>@PostConstruct</code>-Methode l√§uft
                    </li>
                    <li>
                        Sobald die erste Business Methode aufgerufen wird
                    </li>
                </ol>

                <p>
                    b) Was bewirkt eine mit <code>@PreDestroy</code> ausgezeichnete Methode?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Sie sorgt daf√ºr, dass die EJB verschwindet, sobald ein Client sie aufruft.
                    </li>
                    <li>
                        Sie kann f√ºr Aufr√§umarbeiten genutzt werden, bevor eine EJB-Instanz verschwindet.
                    </li>
                    <li>
                        Sie sorgt daf√ºr, dass die komplette Anwendung beendet wird.
                    </li>
                    <li>
                        Sie muss aufgerufen werden, bevor die <code>@Destroy</code>-Methode gerufen wird.
                    </li>
                </ol>

                <p>
                    b) Und was bewirkt eine mit <code>@Remove</code> ausgezeichnete Methode?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Sie sorgt daf√ºr, dass die EJB verschwindet, sobald ein Client sie aufruft.
                    </li>
                    <li>
                        Sie kann f√ºr Aufr√§umarbeiten genutzt werden, bevor eine EJB-Instanz verschwindet.
                    </li>
                    <li>
                        Sie sorgt daf√ºr, dass die komplette Anwendung beendet wird.
                    </li>
                    <li>
                        Sie muss aufgerufen werden, bevor die <code>@PostRemove</code>-Methode gerufen wird.
                    </li>
                </ol>

                <p>
                    c) Welche Beantypen d√ºrfen eine <code>@Remove</code>-Methode besitzen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Alle Enterprise Java Beans
                    </li>
                    <li>
                        Nur Stateless Session Beans
                    </li>
                    <li>
                        Nur Stateful Session Beans
                    </li>
                    <li>
                        Nur Message Driven Beans
                    </li>
                    <li>
                        Stateless und Stateful Session Beans
                    </li>
                </ol>

                <p>
                    d) Eine EJB darf mehr wie eine <code>@Remove</code>-Methode besitzen.
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Wahr
                    </li>
                    <li>
                        Falsch
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>L√∂sung:</b> Aufgabe 4.1: 4, 1, 2, 2; Aufgabe 4.2: 2, 3, 2, 1; Aufgabe 4.3: 3, 2, 1, 3, 1
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Inzwischen solltest du dich schon ganz gut mit der Jakarta Enterprise Edition auskennen.
                    Zur Kontrolle haben wir hier ein paar Fragen f√ºr dich. üë∏üèª
                </p>
                <p style="font-size: 7em;">
                    üè∞
                </p>
            </aside>
        </section>

        <!--
            ====================
            HINWEISE ZUM SCHLUSS
            ====================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Hinweise zum Schluss</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section data-background-color="rgb(153, 190, 137)">
            <h1>Do &amp; Don't</h1>
            <article>
                <h4>Auswahl des richtigen Architekturansatzes</h4>
                <ul>
                    <li>
                        Mache dich mit dem Funktionsumfang von Jakarta&nbsp;EE vertraut.
                    </li>
                    <li>
                        Schaue dich auch nach Alternativen f√ºr andere Programmiersprachen um.
                    </li>
                    <li>
                        Treffe eine bewusste Entscheidung f√ºr oder wider einer rein serverseitigen Webanwendung.
                    </li>
                    <li>
                        √úberlege dir, ob du wirklich ein getrenntes Deployment f√ºr das Webfrontend ben√∂tigst.
                    </li>
                    <li>
                        Fange immer mit der einfachst m√∂glichen L√∂sung an.
                    </li>
                </ul>

                <h4>Strukturierung des Quellcodes</h4>
                <ul>
                    <li>
                        Strukturiere deine Webanwendung immer nach Model-View-Controller.
                    </li>
                    <li>
                        Widerstehe der Versuchung, das Servlet wegzulassen oder Javacode in eine JSP einzubauen.
                    </li>
                    <li>
                        Kapsele alle fachlichen Aufgaben in Enterprise Java Beans.
                    </li>
                    <li>
                        Programmiere fachliche Funktionen niemals in einem Servlet aus.
                    </li>
                    <li>
                        Definiere erst das Datenmodell, bevor die zu Programmieren anf√§ngst.
                    </li>
                    <li>
                        Baue deine Enterprise Java Beans immer um das Datenmodell herum.
                    </li>
                    <li>
                        Sorge f√ºr eine klare Aufgabenteilung zwischen den Enterprise Java Beans.
                    </li>
                </ul>

                <h4>Implementierung der Enterprise Java Beans</h4>
                <ul>
                    <li>
                        Nutze wenn m√∂glich immer nur Stateless Session Beans.
                    </li>
                    <li>
                        Vermeide Stateful Session Beans wo immer du nur kannst.
                    </li>
                    <li>
                        Programmiere deine Servlets und Enterprise Java Beans immer threadsicher.
                    </li>
                    <li>
                        Definiere Local Interfaces und Remote Interfaces, wenn du sie brauchst.
                    </li>
                    <li>
                        Lagere die Local Interfaces und Remote Interfaces immer in ein eigenes Projekt aus.
                    </li>
                    <li>
                        Verwende <code>@PostConstruct</code> anstelle eines Konstruktors in deinen EJB-Klassen.
                    </li>
                </ul>

                <h4>Sonstige Tipps</h4>
                <ul>
                    <li>
                        Mache dich mit dem Benutzer- und Rollenkonzept von Jakarta&nbsp;EE vertraut.
                    </li>
                    <li>
                        Sichere deine Enterprise Java Beans durch Berechtigungsabfragen.
                    </li>
                    <li>
                        Nutze die Java Transaction API, wenn du eine verteilte Transaktion brauchst.
                    </li>
                    <li>
                        √úberlege dir aber erst, ob du den Prozess auch eventuell-konsistent gestalten kannst.
                    </li>
                    <li>
                        Setze dich mit JUnit und Test Driven Development auseinander.
                    </li>
                    <li>
                        Nutze moderne Werkzeuge wie git und Maven f√ºr die Entwicklung.
                    </li>
                    <li>
                        Schreibe sauberen Quellcode mit ordentlicher Formatierung und guten Kommentaren.
                    </li>
                    <li>
                        Mache dir √ºber Deployment und Betrieb deiner Anwendung Gedanken.
                    </li>
                    <li>
                        Versuche, so viele Schritte wie m√∂glich zu automatisieren.
                    </li>
                    <li>
                        Setze f√ºr den Echtbetrieb ein Performance-Monitoring f√ºr deine Anwendung auf.
                    </li>
                </ul>
            </article>
            <aside>
                <p>
                    Dies sind sie: Die ber√ºhmten letzten Worte. üìÑ Auf dieser Folie haben wir ein paar allgemeine
                    Tipps zusammengestellt, worauf du bei der Entwicklung serverseitiger Webanwendungen mit Java
                    achten solltest.
                </p>
                <img src="../../do-dont.svg" class="d-block" style="width: 20em; max-width: 100%; margin-bottom: 0.5em;" />
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/dialog-tip-advice-hint-speaking-148815/" target="_blank" style="color: rgb(25, 68, 49);">Pixabay: OpenClipart-Vectors</a>
                    </small>
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(158, 203, 231)">
            <h1>Rechtshinweise</h1>
            <article>
                <h4>Creative Commons Namensnennung 4.0 International</h4>
                <ul>
                    <li>Beliebiges Teilen ist erlaubt</li>
                    <li>Die Unterlagen d√ºrfen bearbeitet und ver√§ndert werden</li>
                    <li>Wenn die Namens- und Urheberangaben erhalten bleiben</li>
                    <li>Und keine weiteren Einschr√§nkungen auferlegt werden</li>
                </ul>
                <span style="font-size: 400px; color: white;" class="dhbw-text-shadow" >¬ß</span>
            </article>
            <aside style="font-size: 80%">
                <h4>Kontaktdaten</h4>
                <p>
                    Dennis Schulmeister-Zimolong<br/>
                    E-Mail: <a data-email-address>dhbw windows3.de</a><br/>
                </p>

                <h4>Urheberrecht und Lizenzvereinbarung</h4>
                <p>
                    ¬© 2018 ‚Äì 2019 Dennis Schulmeister-Zimolong im Auftrag der DHBW Karlsruhe<br/>
                    <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2018-folien" target="_blank">https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2018-folien</a>
                </p>
                <img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Lizenzvertrag" />
                <p>
                    Das Werk <i>Vorlesung "Verteilte Systeme" im Studiengang Wirtschaftsinformatik an der DHBW Karlsruhe</i>
                    von <a href="http://www.wpvs.de" target="_blank">Dennis Schulmeister-Zimolong im Auftrag der Dualen Hochschule
                    Baden-W√ºrttemberg Karlsruhe</a> ist lizenziert unter
                    <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank"><i>Creative Commons Namensnennung 4.0 International</i></a>.
                </p>
                <p>
                    Du darfst:
                </p>
                <ul>
                    <li>
                        <b>Teilen</b> ‚Äî das Material in jedwedem Format oder Medium vervielf√§ltigen
                        und weiterverbreiten
                    </li>
                    <li>
                        <b>Bearbeiten</b> ‚Äî das Material remixen, ver√§ndern und darauf aufbauen
                        und zwar f√ºr beliebige Zwecke, sogar kommerziell.
                    </li>
                </ul>
                <p>
                    Unter folgenden Bedingungen:
                </p>
                <ul>
                    <li>
                        <b>Namensnennung</b> ‚Äî Du musst angemessene Urheber- und Rechteangaben
                        machen, einen Link zur Lizenz beif√ºgen und angeben, ob √Ñnderungen
                        vorgenommen wurden. Diese Angaben d√ºrfen in jeder angemessenen Art
                        und Weise gemacht werden, allerdings nicht so, dass der Eindruck
                        entsteht, der Lizenzgeber unterst√ºtze gerade dich oder deine Nutzung
                        besonders.
                    </li>
                    <li>
                        <b>Keine weiteren Einschr√§nkungen</b> ‚Äî Du darfst keine zus√§tzlichen Klauseln
                        oder technische Verfahren einsetzen, die anderen rechtlich irgendetwas
                        untersagen, was die Lizenz erlaubt.
                    </li>
                </ul>
                <p>
                    Es werden keine Garantien gegeben und auch keine Gew√§hr geleistet.
                    Die Lizenz verschafft dir m√∂glicherweise nicht alle Erlaubnisse,
                    die du f√ºr die jeweilige Nutzung brauchst. Es k√∂nnen beispielsweise
                    andere Rechte wie Pers√∂nlichkeits- und Datenschutzrechte zu beachten
                    sein, die deine Nutzung des Materials entsprechend beschr√§nken.
                </p>
                <p>
                    <i>
                        Die Erstellung dieser Unterlagen wurde in den Jahren 2017 und 2018 durch
                        das Projekt ‚ÄûDigiTransMoBiL ‚Äì Gestaltungskompetenzen f√ºr die Digitale
                        Transformation durch Modulbausteine mit innovativen Lehrinhalten und
                        Lehrmethoden‚Äù gef√∂rdert.
                    </i>
                </p>
            </aside>
        </section>
    </body>
</html>
