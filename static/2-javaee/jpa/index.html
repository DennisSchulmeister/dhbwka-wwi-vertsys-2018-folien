<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Java Persistence API</title>

        <link rel="shortcut icon" href="../../favicon.svg" />
        <link rel="stylesheet" href="../../style.css" />
        <script src="../../learning-slides.bundle.js"></script>
    </head>
    <body class="slides invisible" data-title="Java Persistence API" tabindex="0">
        <header>
            <h2>Inhaltsverzeichnis</h2>
            <p>
                Das klappt ja schon ganz gut mit Java&nbsp;EE und MVC, wir haben sogar schon
                eigene Webseiten mit Datenbank im Hintergrund geschrieben. Die sch√∂nsten Sachen
                haben wir aber noch gar nicht gesehen. Hier lernst du nun, deine eigenen
                Persistence Entities  und Enterprise Java Beans zu schreiben. üñãÔ∏è
            </p>
        </header>

        <!--
            ========================
            LERNZIELE DIESER EINHEIT
            ========================
        -->
        <section data-chapter data-background-color="rgb(210,190,210)">
            <h1>Lernziele dieser Einheit</h1>
            <article>
                <h3>Nach Abschluss dieser Einheit kannst du ‚Ä¶</h3>
                <ul>
                    <li>
                        erkl√§ren, welche <span class="dhbw-lightblue font-weight-bold">Klassenbibliotheken f√ºr den Datenbankzugriff</span> Java bietet.
                    </li>
                    <li>
                        erkl√§ren, was ein <span class="dhbw-lightblue font-weight-bold">O/R-Mapper</span> ist und welche Vor- und Nachteile er hat.
                    </li>
                    <li>
                        alle Schritte zur Entwicklung einer neuen Anwendung beschreiben.
                    </li>
                    <li>
                        die <span class="dhbw-lightblue font-weight-bold">Datenbankwerkzeuge von Netbeans</span> bedienen.
                    </li>
                    <li>
                        eigene <span class="dhbw-lightblue font-weight-bold">Entity-Klassen</span> entwerfen und ausprogrammieren.
                    </li>
                    <li>
                        einfache und zusammengesetzte <span class="dhbw-lightblue font-weight-bold">Schl√ºsselfelder</span> definieren.
                    </li>
                    <li>
                        die <span class="dhbw-lightblue font-weight-bold">Tabellen- und Feldeigenschaften</span> einer Persistence Entity festlegen.
                    </li>
                    <li>
                        <span class="dhbw-lightblue font-weight-bold">Fremdschl√ºsselbeziehungen</span> zwischen zwei Entities sauber abbilden.
                    </li>
                    <li>
                        beschreiben, was eine <span class="dhbw-lightblue font-weight-bold">Persistence Unit</span> ist und wof√ºr wie sie ben√∂tigen.
                    </li>
                    <li>
                        den <span class="dhbw-lightblue font-weight-bold">Entity Manager</span> zum lesen, schreiben und l√∂schen von Daten benutzen.
                    </li>
                    <li>
                        komplexe <span class="dhbw-lightblue font-weight-bold">Datenabfragen mit JQL</span> fomulieren.
                    </li>
                    <li>
                        <span class="dhbw-lightblue font-weight-bold">datenorientierte Services</span> mit Enterprise Java Beans ausprogrammieren.
                    </li>
                </ul>
                <span style="font-size: 240px; color: white;" class="dhbw-text-shadow" >üèÅ</span>
            </article>
            <aside>
                <p>
                    Die heutige Einheit steh ganz im Zeichen der Datenbank und beendet damit den Zyklus zur serverseitigen
                    Webentwicklung. Denn nachdem du nun die Java Enterprise Edition kennengelernt hast, die serverseitige
                    Erzeugung von HTML-Code mit Servlets und JSP verstehst, eigene Enterprise Java Beans programmieren und
                    das alles zu einer √ºbersichtlichen MVC-Architektur verkn√ºpfen kannst, fehlt dir nur noch eins: Das
                    Datenmodell deiner Anwendung auf Basis einer relationalen Datenbank. üõ¢
                </p>
                <p>
                    Die Programmierung ist dabei gar nicht mal so schwer, ja eigentlich sogar ziemlich einfach üëçüèª, so dass
                    die Java Enterprise Edition ihrem Namen hier alle Ehre macht. Sind die Daten eines Unternehmens doch sein
                    Ein und Alles und liegt auch so einfach viel zu vielen Webanwendungen einer Datenbank zugrunde. Am Anfang
                    werden wir uns daher ein wenig mit den Konzepten besch√§ftigen, welche M√∂glichkeiten Java&nbsp;EE uns bietet
                    (Stichwort ‚ÄûO/R-Mapping‚Äù) und wie Netbeans uns dabei unterst√ºtzt. Danach tauchen wir dann auch schon direkt
                    in den Quellcode ein und definieren unsere eigenen Persistence Entities. Zun√§chst nur ganz einfache mit
                    einer fortlaufenden ID als Schl√ºsselwert und ein paar einfachen Feldern und gleich danach komplexere Entities
                    mit zusammengesetzten Schl√ºsseln und Fremdschl√ºsselbeziehungen.
                </p>
                <p>
                    Danach wenden wir uns dann die Verwendung der Persistence Entities zu und lernen, was der Entity Manager
                    ist, wie wir an ihn herankommen und welche Methoden er zum lesen, schreiben und l√∂schen von Daten bietet.
                    Dabei schauen wir uns dann auch die Java Query Language an, mit der wir komplexe Suchanfragen in einer
                    SQL-√§hnlichen Sprache an jede beliebige Datenbank schicken k√∂nnen. Das alles m√ºndet dann in einer Empfehlung
                    zur Implementierung von Java Enterprise Beans, so dass du deinen Clients eine konsistente und dennoch
                    leistungsf√§hige Schnittstelle zur Nutzung des Datenmodells anbieten kannst.
                </p>
                <p>
                    Das ist unser Fahrplan üöÇüöûüöûüöû f√ºr heute und wir w√ºnschen dir jetzt schon viel Spa√ü!
                </p>
            </aside>
        </section>

        <!--
            ==================================
            ALLGEMEINES ZU DATENBANKEN IN JAVA
            ==================================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Allgemeines zu Datenbanken in Java</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Wie Java mit der Datenbank spricht</h1>
            <article>
                <img src="or-mapping.svg" alt="O/R-Mapping in Java" class="d-block" style="width: 100%; margin-bottom: 1em;" />
                <table>
                    <tr>
                        <td style="padding-right: 0.5em">
                            üõ¢Ô∏è
                        </td>
                        <td>
                            <b>JDBC:</b> Allgemeine API f√ºr den Zugriff auf relationale Datenbanken
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em">
                            üõ¢Ô∏è
                        </td>
                        <td>
                            <b>JPA:</b> Auf JDBC aufbauende API f√ºr O/R-Mapper, die Javaobjekte in Tabelleneintr√§ge und umgekehrt umwandeln
                        </td>
                    </tr>
                </table>
            </article>
            <aside>
                <p>
                    Die Java Enterprise Edition kennt zwei Klassenbibliotheken f√ºr den Datenbankzugriff: JDBC und JPA. JDBC steht dabei
                    f√ºr <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/" target="_blank">Java Database Connection</a>
                    und ist eine allgemeine API, mit der SQL-Befehle an eine Datenbank gesendet werden k√∂nnen. Es handelt sich dabei um die
                    zugrunde liegende Schnittstelle, die immer genutzt wird, wenn auf eine Datenbank zugegriffen wird. Jedoch ist die
                    Programmierung nicht ganz einfach, wie das folgende Beispiel zeigt:
                </p>
                <source-code language="java">
                    @Stateless
                    public class VielZuKompliziert {
                        @Resource(mappedName="jdbc__/default")
                        DataSource dataSource;

                        public Buch findBuchByIsbn(String isbn)
                        throws SQLException {
                            try (Connection con = dataSource.getConnection()) {
                                String select = "SELECT * FROM Buch WHERE isbn = ?";
                                PrepatedStatement statement = con.prepareStatement(select);
                                statement.setString(1, isbn);

                                ResultSet result = statement.executeQuery();
                                Buch buch = new Buch();

                                while (result.next()) {
                                    Buch.setIsbn(result.getString("isbn"));
                                    Buch.setTitel(result.getString("titel"));
                                    break;
                                }

                                result.close();
                                statement.close();

                                return buch;
                            }
                        }

                        // Weitere Methoden ‚Ä¶
                    }
                </source-code>
                <p>
                    Ui, schrecklich! üëπ Bitte nicht! Das ist ja mega aufw√§ndig! Und fehleranf√§llig! Und sonst noch was!
                    Vor Java&nbsp;EE&nbsp;5 im Jahr 2006 war das tats√§chlich die einzige offizielle API, um auf eine
                    Datenbank zuzugreifen. Doch schon damals war das nicht wirklich sch√∂n, so dass sogleich alternative
                    APIs wie <a href="http://hibernate.org/" target="_blank">Hibernate</a> entstanden, die wesentlich
                    einfacher zu nutzen waren. Wir wollen das Ganze daher schnell wieder vergessen. Einzig, dass im
                    Hintergrund immer noch JDBC werkelt, wenn wir mit der Datenbank reden, ist noch ganz interessant
                    zu wissen.¬π
                </p>
                <p>
                    <small>
                        ¬π Tats√§chlich sieht die native API vieler Datenbanken f√ºr irgend eine Programmiersprache oftmals
                        relativ √§hnlich aus. Dies ist einer der Gr√ºnde, warum man als Anwendungsentwickler die nativen
                        APIs niemals direkt verwenden sollte.
                    </small>
                </p>
                <p>
                    Viel angenehmer ist da JPA, was f√ºr <b>Java Persistence API</b> steht. Dabei handelt es sich um eine
                    Klassenbibliothek, die zur Nutzung eines sogenannten O/R-Mappers dient, der zwischen den relationalen
                    Welt der Datenbank und der objektorientierten Welt von Java vermittelt. Dadurch wird es m√∂glich,
                    Code wie folgenden zu schreiben:
                </p>
                <source-code language="java">
                    @Statelss
                    public class GanzEinfach {
                        @PersistenceContext
                        EntityManager em;

                        public Buch findBuchByIsbn(String isbn) {
                            return em.find(Buch.class, isbn);
                        }

                        public void saveNewBuch(Buch buch) {
                            em.persist(buch);
                        }

                        // Weitere Methoden ‚Ä¶
                    }
                </source-code>
                <p>
                    Hm, das sieht schon viel besser aus. Fast zu einfach. üòå Doch ja, es ist wirklich so. Die Grundidee
                    ist schlicht, dass es zu jeder Tabelle eine Javaklasse gibt, deren Objekte den Zeilen der Tabelle
                    entsprechen. Wollen wir eine Zeile auslesen, erzeugt der O/R-Mapper automatisch ein solches Objekt
                    und √ºbergibt ihm die Werte aus der Datenbank. Soll stattdessen ein neuer Datensatz geschrieben werden,
                    erzeugen wir das Objekt einfach selbst und √ºbergeben es dem O/R-Mapper. Die ganzen h√§sslichen Einzelheiten,
                    wie wir sie oben gesehen haben, brauchen wir dabei nicht beachten.Das macht der O/R-Mapper f√ºr uns.
                    Wir m√ºssen lediglich eine Bean¬≤ mit den richtigen Feldern bereitstellen:
                </p>
                <p>
                    <small>
                        ¬≤ Eine Javaklasse, die f√ºr jedes Feld eine Set- und eine Get-Methode besitzt.
                    </small>
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        @Id
                        private String isbn;

                        private String titel;
                        private String untertitel;

                        // Setter und Getter ‚Ä¶
                    }
                </source-code>
                <p>
                    Das ist alles, was der O/R-Mapper braucht. Einfache Methoden wie <src-code language="java">em.find()</src-code> oder
                    <src-code language="java">em.persist()</src-code> dienen dann dem Lesen und Schreiben von Datens√§tzen.
                </p>
            </aside>
        </section>

        <section>
            <h1>Von der Idee zur fertigen Anwendung</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "vorgehen-uebersicht-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#vorgehen-uebersicht"
                                role          = "tab"
                                aria-controls = "vorgehen-uebersicht"
                                aria-expanded = "true"
                            >
                                √úbersicht
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vorgehen-datenmodell-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vorgehen-datenmodell"
                                role          = "tab"
                                aria-controls = "vorgehen-datenmodell"
                            >
                                Datenmodell
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vorgehen-services-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vorgehen-services"
                                role          = "tab"
                                aria-controls = "vorgehen-services"
                            >
                                Services
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vorgehen-benutzeroberflaeche-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vorgehen-benutzeroberflaeche"
                                role          = "tab"
                                aria-controls = "vorgehen-benutzeroberflaeche"
                            >
                                Benutzeroberfl√§che
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- √úbersicht -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "vorgehen-uebersicht"
                            role            = "tabpanel"
                            aria-labelledby = "vorgehen-uebersicht-tab"
                        >
                            <p>
                                Die untenstehende Zeichnung zeigt die wesentlichen Schritte, die bei der Entwicklung einer Java-EE-Anwendung anfallen.
                                Die wichtigsten davon schauen wir uns anhand eines kleinen Fallbeispiels auf den folgenden Reitern etwas genauer an.
                            </p>
                            <img src="vorgehen-uebersicht.svg" alt="Schritte w√§hrend der Entwicklung" class="d-block" style="width: 100%;" />
                        </div>
                        <!-- Datenmodell -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vorgehen-datenmodell"
                            role            = "tabpanel"
                            aria-labelledby = "vorgehen-datenmodell-tab"
                        >
                            <p>
                                Zun√§chst brauchen wir ein gutes Datenmodell, das nicht zu kompliziert aber dennoch flexibel ist. Unsere kleine Anwendung modelliert
                                eine Buchsammlung. Wir haben daher Entit√§ten wie <span class="dhbw-lightblue">Buch</span>, <span class="dhbw-lightblue">Autor</span>
                                oder <span class="dhbw-lightblue">Verlag</span>, die in Beziehung zueinander stehen. Zus√§tzlich hat jeder Autor und jeder Verlag eine
                                <span class="dhbw-lightblue">Adresse</span>.
                            </p>
                            <img
                                src   = "vorgehen-datenmodell.svg"
                                alt   = "Datenmodell mit den Entit√§ten Buch, Autor, Verlag und Adresse"
                                class = "d-block"
                                style = "width: 35em; max-width: 100%; margin: 0 auto; margin-top: 1em; margin-bottom: 1em;"
                            />
                            <p>
                                In Javacode sieht das ganze ungef√§hr so aus. Die Details dazu schauen wir uns nat√ºrlich noch an.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch implements Serializable {
                                    @Id
                                    private String isbn = "";

                                    private String titel = "";
                                    private String untertitel = "";
                                    private BuchKategorie kategorie = BuchKategorie.UNBEKANNT;
                                    private int anzahlSeiten = 0;

                                    @ManyToMany
                                    List&lt;Autor&gt; autoren = new ArrayList&lt;&gt;();

                                    @ManyToOne
                                    private Verlag verlag = null;

                                    // Setter und Getter ‚Ä¶
                                }

                                public enum BuchKategorie {
                                    UNBEKANNT, BELLETRISTIK, FACHBUCH, SAMMELBAND, ZEITSCHRIFT;
                                }

                                @Entity
                                public class Autor implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id;

                                    private String vorname;
                                    private String nachname;
                                    private String titel;

                                    @OneToOne
                                    Adresse adresse = null;

                                    @ManyToMany(mappedBy="autoren")
                                    List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();

                                    // Setter und Getter ‚Ä¶
                                }

                                @Entity
                                public class Verlag implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id;

                                    private String name;
                                    private String rechtsform;

                                    @OneToOne
                                    Adresse adresse = null;

                                    @OneToMany(mappedBy="verlag")
                                    List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();

                                    // Setter und Getter ‚Ä¶
                                }

                                @Entity
                                public class Adresse implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id;

                                    private String strasse = "";
                                    private String hausnummer = "";
                                    private String postleitzahl = "";
                                    private String ort = "";
                                    private String land = "";

                                    // Setter und Getter ‚Ä¶
                                }
                            </source-code>
                        </div>
                        <!-- Services -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vorgehen-services"
                            role            = "tabpanel"
                            aria-labelledby = "vorgehen-services-tab"
                        >
                            <p>
                                Darauf aufbauend k√∂nnen wir nun Services definieren, die sinnvolle Funktionen rund um die Entit√§ten zur Verf√ºgung stellen.
                                Im einfachsten Fall bieten wir hierf√ºr die √ºblichen CRUD-Operationen: <span class="dhbw-lightblue">Create</span>,
                                <span class="dhbw-lightblue">Read</span>, <span class="dhbw-lightblue">Update</span> und <span class="dhbw-lightblue">Delete</span>.
                            </p>

                            <img
                                src   = "vorgehen-services.svg"
                                alt   = "Klassendiagramm der Klassen BuchService, AutorService, VerlagService"
                                class = "d-block"
                                style = "width: 42em; max-width: 100%; margin: 0 auto; margin-top: 1em; margin-bottom: 1em;"
                            />

                            <source-code language="java">
                                @Stateless
                                public class BuchService {
                                    @PersistenceContext
                                    EntityManager em;

                                    // B√ºcher selektieren
                                    public Buch findByIsbn(String isbn) { ‚Ä¶ }
                                    public List&lt;Buch&gt; findByAutor(Autor autor) { ‚Ä¶ }
                                    public List&lt;Buch&gt; findByVerlag(Verlag verlag) { ‚Ä¶ }
                                    public List&lt;Buch&gt; findByTitleContains(String title) { ‚Ä¶ }

                                    // Neue B√ºcher speichern
                                    public Buch saveNew(Buch buch) { ‚Ä¶ }

                                    // B√ºcher Verlage √§ndern
                                    public Buch update(Buch buch) { ‚Ä¶ }
                                    public void delete(Buch buch) { ‚Ä¶ }
                                }

                                @Stateless
                                public class VerlagService {
                                    ‚Ä¶
                                }

                                @Stateless
                                public class AutorService {
                                    ‚Ä¶
                                }
                            </source-code>
                        </div>
                        <!-- Benutzeroberfl√§che -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vorgehen-benutzeroberflaeche"
                            role            = "tabpanel"
                            aria-labelledby = "vorgehen-benutzeroberflaeche-tab"
                        >
                            <p>
                                Und last but not least eine sch√∂ne Benutzeroberfl√§che, entweder als serverseitige MVC-Webanwendung,
                                als clientseitige Webanwendung oder als Native Client. Oder jede beliebige Kombination daraus,
                                ganz wie du willst.
                            </p>
                            <img
                                src   = "vorgehen-ui.png"
                                alt   = "Benutzeroberfl√§chen f√ºr Smartphone, Tablet, Desktop und Notebook"
                                class = "d-block"
                                style = "width: 100%; margin-top: 1em;"
                            />

                            <source-code language="java">
                                @WebServlet(urlPatterns={"/start/"})
                                public class StartPageServlet extends HttpServlet {
                                    @EJB
                                    BuchService buchService;

                                    @EJB
                                    AutorService autorService;

                                    @EJB
                                    VerlagService verlagService;

                                    @Override
                                    public void doGet(HttpServletRequest request, HttpServletResponse)
                                    throws ServletException, IOException {
                                        ‚Ä¶
                                    }
                                }
                            </source-code>

                            <p>
                                <small>
                                    <small>
                                        Bildnachweise:
                                        <a href="https://pixabay.com/de/imac-ipad-iphone-macbook-laptop-1999636/" target="_blank">Pixabay: Nick_H</a>,
                                        <a href="https://pixabay.com/de/buch-rack-regal-m%C3%B6bel-design-holz-2943383/" target="_blank">Pixabay: JuralMin</a>
                                    </small>
                                </small>
                            </p>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Ordnung ist das halbe Leben. Was im Alltag gilt, gilt nat√ºrlich auch bei der Entwicklung gro√üer Anwendungen,
                    wie sie bei Java&nbsp;EE h√§ufig vorkommen. Bevor du also einfach so drauf los programmierst, solltest du eine
                    m√∂glichst genaue Vorstellung davon haben, was f√ºr eine Anwendung du schreiben willst, wie der Quellcode aufgebaut
                    sein muss und wie du hierf√ºr am besten vorgehst. Kurz um: Du brauchst einen Plan, damit du dich nicht in eine Ecke
                    programmierst, aus der du nur schwer wieder herauskommst: üôÉ
                </p>
                <a href="https://xkcd.com/1513/" target="_blank">
                    <img src="https://imgs.xkcd.com/comics/code_quality.png" class="d-block" style="width: 100%;" />
                </a>
                <p>
                    <small>
                        I honestly didn't think you could even USE emoji in variable names. <br />
                        Or that there were so many different crying ones. <br />
                        Bildnachweis: <a href="https://xkcd.com/1513/" target="_blank">Randall Munroe, xkcd 1513</a>
                    </small>
                </p>
                <p>
                    Das Gute daran ist, dass das gar nicht so schwer ist, wie du jetzt vielleicht denken magst. Denn immerhin gibt es
                    die Java Enterprise Edition nun schon so lange, dass reichlich viel Erfahrung in ihre Entwicklung geflossen ist.
                    Ein klein wenig strukturiertes Vorgehen gepaart mit ein paar einfachen Regeln und hier und da bew√§hrten Techniken
                    aus dem Software-Engingeering-Fundus und schon ergibt der Rest fast von alleine. ü¶ã
                </p>
                <p>
                    Anfangen solltest du daher immer mit dem Datenmodell, denn es ist das Fundament, auf dem alles andere aufbaut. Bevor
                    du also auch nur daran denkst, die IDE zu starten, solltest du erst das Datenmodell definieren und so genau wie m√∂glich
                    beschreiben. <a href="https://de.wikipedia.org/wiki/Entity-Relationship-Modell" target="_blank">ER-Diagramme</a> k√∂nnen
                    dabei eine gro√üe Hilfe sein, aber nat√ºrlich tut es auch jede andere Darstellungsform. Wichtig ist nur, dass alle Tabellen
                    mit allen Feldern gut durchdacht sind, es keine Redundanzen gibt und das Datenmodell nicht komplexer als unbedingt n√∂tig
                    ist. Reicht zum Beispiel ein Feld f√ºr die Telefonnummer oder muss sie in ihre einzelnen Bestandteile¬π zerlegt werden?
                    Hat eine Firma nur eine Adresse oder m√ºssen auch ihre Niederlassungen abgespeichert werden? Reicht dabei die aktuelle
                    Adresse oder werden auch historische Adressen ben√∂tigt? Solche Fragen musst du dir stellen und beantworten, bevor zu
                    programmieren anf√§ngst.
                </p>
                <p>
                    <small>
                        ¬π L√§ndervorwahl, Ortsvorwahl, Anschlussnummer, Durchwahl
                    </small>
                </p>
                <p>
                    Als n√§chstes gilt es dann, das Datenmodell im Quellcode abzubilden, also <b>Persistence Entities</b> zu schreiben,
                    wobei du dir aussuchen kannst, ob du erst die Klassen schreibst und daraus dann Tabellen generieren l√§sst, oder
                    ob du erst die Tabellen anlegst und daraus dann die Klassen generierst. Alternativ kannst du nat√ºrlich auch sowohl
                    die Klassen als auch die Tabellen manuell anlegen, je nachdem, was dir lieber ist. In der Vorlesung machen wir es
                    uns jedoch einfach und schreiben nur die Klassen. Den Rest darf Java&nbsp;EE alleine machen. üòã Wie die Klassen
                    hierf√ºr aussehen m√ºssen, schauen wir uns gleich genauer an. F√ºr den Anfang reicht es aber zu wissen, dass es sich
                    um ganz normale Javaklassen handelt, von denen je ein Objekt einer Tabellenzeile entspricht. Die Klassen m√ºssen
                    hierf√ºr lediglich mit <code>@Entity</code> gekennzeichnet werden und f√ºr jedes Tabellenfeld ein Attribut mit
                    Settern und Gettern enthalten:
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        @Id
                        private String isbn;

                        public String getIsbn() {
                            return this.isbn;
                        }

                        public void setIsbn(String isbn) {
                            this.isbn = isbn;
                        }

                        ‚Ä¶
                    }
                </source-code>
                <p>
                    Als n√§chstes folgen <b>Enterprise Java Beans</b>, die sinnvolle Methoden rund um das Datenmodell definieren.
                    Sie bilden sozusagen die Schnittstelle, mit der auf die Daten zugegriffen werden kann. Die Beans sollten daher
                    die √ºblichen CRUD-Methoden zum Anlegen, Lesen, Aktualisieren und L√∂schen von Eintr√§gen beinhalten. Dar√ºber hinaus
                    k√∂nnen Sie nat√ºrlich noch alle m√∂glichen, weiteren Methoden umfassen, die f√ºr den Umgang mit den Daten n√ºtzlich sind.
                </p>
                <source-code language="java">
                    @Stateless
                    public class BuchService {
                        @PersistenceContext
                        EntityManager em;

                        // B√ºcher selektieren
                        public Buch findByIsbn(String isbn) { ‚Ä¶ }
                        public List&lt;Buch&gt; findByTitleContains(String title) { ‚Ä¶ }

                        // Neue B√ºcher speichern
                        public Buch saveNew(Buch buch) { ‚Ä¶ }

                        // B√ºcher Verlage √§ndern
                        public Buch update(Buch buch) { ‚Ä¶ }
                        public void delete(Buch buch) { ‚Ä¶ }
                    }
                </source-code>
                <p>
                    Auf dieser Ebene w√ºrde man dann auch <a href="https://de.wikipedia.org/wiki/Modultest" target="_blank">Unit Tests</a>
                    schreiben, um jederzeit die richtige Funktionsweise der Beans √ºberpr√ºfen zu k√∂nnen. Zus√§tzlich k√∂nnen die Beans mit
                    ganz wenig Aufwand zu Webservices ausgebaut werden, um somit auch von entfernten Clients aufgerufen werden zu k√∂nnen.
                    Die Details dazu schauen wir uns im Webservice-Kapitel an. Um dir zu zeigen, dass es aber wirklich ganz einfach geht,
                    hier ein minimales Beispiel:
                </p>
                <source-code language="java">
                    @Stateless
                    @WebService
                    public class BuchService {
                        @PersistenceContext
                        EntityManager em;

                        @WebMethod
                        @WebResult(name="buch")
                        public Buch findByIsbn(@WebParam(name="isbn") String isbn) {
                            ‚Ä¶
                        }
                    }
                </source-code>
                <p>
                    Fehlt dann nur noch die Benutzeroberfl√§che, wobei dir hier das volle Programm zur Verf√ºgung steht: Serverseitige
                    Webanwendungen, clientseitige Webanwendungen oder Native Clients f√ºr verschiedene Betriebssysteme. Alles ist erlaubt.
                </p>
            </aside>
        </section>

        <section>
            <h1>Welche Datenbank nutzen wir eigentlich?</h1>
            <article>
                <p>
                    Netbeans enth√§lt die Datenbank <a href="https://db.apache.org/derby/" target="_blank">Apache Derby</a>.
                    Selbstverst√§ndlich k√∂nnen wir auch jede andere Datenbank verwenden, wenn wir sie selbst konfigurieren.
                    Aber wozu? Derby funktioniert prima.
                </p>
                <img src="netbeans-derby.png" alt="Netbeans mit gestarteter Derby-Datenbank" class="d-block" style="width: 100%;" />
            </article>
            <aside>
                <p>
                    Tja, das ist eine gute Frage. Dank der weiten Verbreitung von Java und JDBC k√∂nnen wir eigentlich jede beliebige
                    Datenbank verwenden. Jede Datenbank, die etwas auf sich h√§lt, kommt auch mit einem JDBC-Treiber, auf den der
                    Applikationsserver zugreifen kann.
                </p>
                <p>
                    F√ºr den Produktiveinsatz unserer Anwendungen ist das wichtig zu wissen. F√ºr die Entwicklung ist es und jedoch
                    ein St√ºck weit egal, da Netbeans bereits eine Datenbank samt passender Glassfish-Konfiguration mitliefert.
                    Sie h√∂rt auf den Namen <a href="https://db.apache.org/derby/" target="_blank">Apache Derby</a>, ist in Java
                    geschrieben und wird automatisch mitgestartet, wenn wir unsere Anwendungen laufen lassen. Es ist schon alles
                    fix und fertig eingerichtet, wir m√ºssen nichts tun. Wie sch√∂n. ‚ò∫Ô∏è
                </p>
            </aside>
        </section>

        <section>
            <h1>√úber die Datenbankwerkzeuge in Netbeans</h1>
            <article>
                <ul class="dhbw-carousel-links">
                    <li>
                        <a href="#netbeans-dbtools-carousel" role="button" data-slide="next">N√§chstes Bild</a>
                    </li>
                    <li>
                        <a href="#netbeans-dbtools-carousel" role="button" data-slide="prev">Vorheriges Bild</a>
                    </li>
                    <li>
                        <a href="#netbeans-dbtools-carousel" role="button" data-slide-to="0">Nochmal von vorne</a>
                    </li>
                </ul>
                <ul class="dhbw-carousel-links">
                    <li>
                        <small>
                            <a href="#netbeans-dbtools-carousel" role="button" data-slide-to="0">Verbindung herstellen</a>
                        </small>
                    </li>
                    <li>
                        <small>
                            <a href="#netbeans-dbtools-carousel" role="button" data-slide-to="5">Tabellen bearbeiten</a>
                        </small>
                    </li>
                    <li>
                        <small>
                            <a href="#netbeans-dbtools-carousel" role="button" data-slide-to="11">Inhalte anzeigen und √§ndern</a>
                        </small>
                    </li>
                </ul>
                <div id="netbeans-dbtools-carousel" class="carousel slide" style="margin-bottom: 1em;" data-interval="false">
                    <div class="carousel-inner">
                        <div class="carousel-item img-thumbnail active">
                            <p>
                                Bevor die Datenbank genutzt werden kann, muss sie gestartet werden. Am einfachst startest du hierf√ºr
                                eine Webanwendung. Die Datenbank wird dann automatisch mitgestartet.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-01.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Links findest du den Reiter <i>Services</i> mit dem Men√ºpunkt <i>Databases</i>. Dort sollte die Datenbank bereits
                                eingetragen sein, so dass du dich nur noch mit Rechtsklick und <i>Connect‚Ä¶</i> verbinden musst. Benutzername und
                                Passwort lauten jeweils <b>app</b>.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-02.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Fehlt der Eintrag, klappe den Eintrag <i>Drivers</i> auf, mache einen Rechtsklick auf <i>Java DB (Network)</i> und
                                w√§hle den Men√ºpunkt <i>Connect Using‚Ä¶</i> aus.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-03.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Daraufhin √∂ffnet sich folgendes Fenster. √úbernimm die Werte aus dem Screenshot und teste die Verbindung mit
                                <i>Test Connection</i>. Wenn alles in Ordnung ist, klicke auf <i>Finish</i>. Benutzername und Passwort lauten
                                weiterhin jeweils <b>app</b>.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-04.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Sobald die Verbindung hergestellt ist, werden links die vorhandenen Datenbankschemas mit ihren Tabellen
                                angezeigt. Unsere Tabellen befinden sich alle im Schema <i>APP</i>.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-05.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Per Rechtsklick auf den Eintrag <i>Table</i> l√§sst sich eine neue Tabelle anlegen.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-06.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Dadurch √∂ffnet sich ein Fenster, in dem der Name der Tabelle sowie ihre Spalten hinterlegt werden.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-07.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Mit einem Rechtsklick auf eine Tabelle lassen sich nachtr√§glich weitere Felder anh√§ngen.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-08.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                So sieht dann das Fenster zum Anh√§ngen eines weiteren Felds aus.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-09.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Einzelne Felder lassen sich per Rechtsklick und <i>Delete</i> auch wieder l√∂schen.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-10.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Genau wie die ganze Tabelle, wenn es sein muss. Manchmal kannst du dadurch Probleme beim Starten der Anwendung l√∂sen, wenn
                                die Entityklassen nicht mehr zu den Tabellen passen.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-11.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Rechtsklick auf eine Tabelle und dann <i>View Data‚Ä¶</i> dient der Anzeige vorhandener Tabelleneintr√§ge.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-12.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Es √∂ffnet sich ein Reiter, der im oberen Teil die ausgef√ºhrte SQL-Anweisung und unten ihr Ergebnis zeigt.
                                √úber die Toolbar k√∂nnen weitere Eintr√§ge eingef√ºgt oder gel√∂scht werden.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-13.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Das Kontextmen√º enth√§lt ebenfalls ein paar interessante Eintr√§ge.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-14.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Du siehst: Netbeans hat echt m√§chtige Datenbankwerkzeuge an Board. ü¶Ñ
                            </p>
                            <img class="active d-block w-25 m-auto" src="../../finish.svg" />
                        </div>
                    </div>
                </div>

                <p>
                    <small>
                        <small>
                            Bildnachweis f√ºr das Endesymbol: <a href="https://pixabay.com/en/symbol-gui-internet-internet-page-2480163/" target="_blank">Pixabay: janf93</a>
                        </small>
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Nicht nur, dass Netbeans bereits eine fix und fertige Datenbank mitliefert, die wir beim Programmieren unserer
                    Anwendungen benutzen k√∂nnen, es hat auch so noch ein paar Tricks parat, die hin und wieder n√ºtzlich sind.
                    Auf den nachfolgenden Bildern siehst du daher, wie du ‚Ä¶
                </p>
                <ul>
                    <li>
                        eine manuelle Verbindung zu Datenbank herstellen kannst.
                    </li>
                    <li>
                        Tabellen von Hand anlegen und bearbeiten kannst.
                    </li>
                    <li>
                        Tabellen wieder l√∂schen kannst.
                    </li>
                    <li>
                        die Inhalte einer Tabelle anzeigen kannst.
                    </li>
                    <li>
                        sowie Tabellenzeilen einf√ºgen, bearbeiten und l√∂schen kannst.
                    </li>
                </ul>
                <img src="netbeans-databases.png" alt="Men√ºpunkt ‚ÄûDatebases‚Äù in Netbeans" class="d-block" style="max-width: 100%; margin-bottom: 1em;" />
                <p>
                    All dies versteckt sich hinter dem Punkt <i>Databases</i> im Reiter <i>Services</i> sowie den dazugeh√∂rigen
                    Kontextmen√ºs. Wie du in der Folie siehst, bringt ein einfacher Rechtsklick die sch√∂nsten Funktionen zu Tage.
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 1: Ein kleines Datenbank-Quiz</h1>
            <article>
                <h2>Aufgabe 1.1: Datenbankzugriffe mit Java</h2>

                <p>
                    a) Welche beiden Datenbank-APIs kennt die Java Enterprise Edition?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        JPA und JDBB
                    </li>
                    <li>
                        JDK und JDBC
                    </li>
                    <li>
                        JFK und JDCB
                    </li>
                    <li>
                        JPA und JDBC
                    </li>
                </ol>

                <p>
                    b) Welche Funktion erf√ºllen die ‚ÄûJava Database Connection‚Äù-Klassen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Sie legen passende Tabellen f√ºr die Persistence Entities an.
                    </li>
                    <li>
                        Sie dienen als Low-Level API dazu, SQL-Befehle an die Datenbank zu schicken.
                    </li>
                    <li>
                        Sie sprechen einen O/R-Mapper an, der Tabelleneintr√§ge in Javaobjekte umwandeln kann.
                    </li>
                    <li>
                        Sie dienen der Nutzung von Persistence Entities innerhalb der EJBs.
                    </li>
                </ol>

                <p>
                    c) Und welche Funktion erf√ºllt die ‚ÄûJava Persistence API‚Äù?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                   <li>
                        Sie legt passende Tabellen f√ºr die Persistence Entities an.
                    </li>
                    <li>
                        Sie dient als Low-Level API dazu, SQL-Befehle an die Datenbank zu schicken.
                    </li>
                    <li>
                        Sie spricht einen O/R-Mapper an, der Tabelleneintr√§ge in Javaobjekte umwandeln kann.
                    </li>
                    <li>
                        Sie dient der Nutzung von Persistence Entities innerhalb der EJBs.
                    </li>
                </ol>

                <h2>Aufgabe 1.2: Vorgehen bei der Entwicklung</h2>

                <p>
                    a) In welcher Reihenfolge sind die folgenden Schritte w√§hrend der Entwicklung durchzuf√ºhren?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Enterprise Java Beans entwickeln
                    </li>
                    <li>
                        Benutzeroberfl√§che oder Clients entwickeln
                    </li>
                    <li>
                        Datenmodell definieren
                    </li>
                    <li>
                        Tabellen anlegen (falls von Hand erledigt)
                    </li>
                    <li>
                        Serviceschicht definieren
                    </li>
                    <li>
                        Persistence Entities anlegen
                    </li>
                    <li>
                        Webservices anlegen
                    </li>
                </ol>

                <p>
                    b) Entfernte Clients k√∂nnen die Persistence Entities direkt nutzen, um Daten zu lesen oder zu schreiben?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Wahr
                    </li>
                    <li>
                        Falsch
                    </li>
                </ol>

                <p>
                    c) Welche Methoden sollten die Enterprise Java Beans in aller Regel beinhalten?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Create, Read, Unlock, Delete
                    </li>
                    <li>
                        Create, Rest, Update, Dismiss
                    </li>
                    <li>
                        Create, Read, Update, Delete
                    </li>
                    <li>
                        Create, Read, Update, Discard
                    </li>
                </ol>

                <h2>Aufgabe 1.3: Datenkbanken in Netbeans</h2>

                <p>
                    a) Welche Datenbanken werden von Netbeans unterst√ºzt?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Apache Derby
                    </li>
                    <li>
                        PostgreSQL, mySQL und MariaDB
                    </li>
                    <li>
                        Alle Datenbanken, f√ºr die es JDBC-Treiber gibt
                    </li>
                </ol>

                <p>
                    b) Welche Datenbank liefert Netbeans praktischerweise schon mit aus?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Apache Derby
                    </li>
                    <li>
                        MariaDB
                    </li>
                    <li>
                        Microsoft SQL Server
                    </li>
                    <li>
                        Oracle Express Edition
                    </li>
                    <li>
                        Oracle mySQL
                    </li>
                    <li>
                        PostgreSQL
                    </li>
                    <li>
                        SQLite
                    </li>
                    <li>
                        Keine
                    </li>
                </ol>

                <p>
                    c) Welche der folgenden Datenbankoperationen k√∂nnen mit Netbeans ausgef√ºhrt werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Tabellen anlegen
                    </li>
                    <li>
                        Tabellen bearbeiten
                    </li>
                    <li>
                        Tabellen l√∂schen
                    </li>
                    <li>
                        Tabelleninhalte anzeigen
                    </li>
                    <li>
                        Tabelleninhalte einf√ºgen
                    </li>
                    <li>
                        Tabelleninhalte √§ndern
                    </li>
                    <li>
                        Tabelleninhalte l√∂schen
                    </li>
                    <li>
                        SQL-Befehle abschicken
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>L√∂sung:</b> <br />
                        Aufgabe 1.1: 4, 2, 3 <br />
                        Aufgabe 1.2: 3 ‚Üí 4 ‚Üí 6 ‚Üí 5 ‚Üí 1 ‚Üí 7 ‚Üí 2, 2, 3 <br />
                        Aufgabe 1.3: 3, 1, alle
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    So, das erste w√§re geschafft. üëèüèº Zeit f√ºr eine kurze Pause und ein kleines Quiz. üç®
                    Danach schauen wir uns die Programmierung an.
                </p>
            </aside>
        </section>

        <!--
            ===================================
            DEFINITION DER PERSISTENCE ENTITIES
            ===================================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Definition der Persistence Entities</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Anatomie einer Persistence Entity</h1>
            <article>
                <p>
                    Persistence Entities sind einfache Beans, die mit <code>@Entity</code> gekennzeichnet werden.
                    Au√üerdem wird empfohlen, dass sie das <code>Serializable</code>-Interface implementieren.
                </p>
                <source-code language="java">
                    @Entity
                    public class Autor implements Serializable {
                </source-code>
                <div style="margin: 0 0 1em 2em;">
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "anatomie-schluessel-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#anatomie-schluessel"
                                role          = "tab"
                                aria-controls = "anatomie-schluessel"
                                aria-expanded = "true"
                            >
                                Schl√ºssel
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "anatomie-felder-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#anatomie-felder"
                                role          = "tab"
                                aria-controls = "anatomie-felder"
                            >
                                Felder
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "anatomie-konstruktoren-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#anatomie-konstruktoren"
                                role          = "tab"
                                aria-controls = "anatomie-konstruktoren"
                            >
                                Konstruktoren
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "anatomie-setget-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#anatomie-setget"
                                role          = "tab"
                                aria-controls = "anatomie-setget"
                            >
                                Setter und Getter
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "anatomie-alles-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#anatomie-alles"
                                role          = "tab"
                                aria-controls = "anatomie-alles"
                            >
                                Alles zusammen
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Schl√ºssel -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "anatomie-schluessel"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-schluessel-tab"
                        >
                            <p>
                                H√§ufig besitzen sie als einzigen Schl√ºsselwert ein Feld namens <code>id</code>, das automatisch
                                mit einer fortlaufenden Nummer versorgt wird. Dies wird durch die beiden Annotationen <code>@Id</code>
                                und <code>@GeneratedValue</code> ausgedr√ºckt.
                            </p>
                            <source-code language="java">
                                @Id
                                @GeneratedValue
                                private long id = 0;
                            </source-code>
                        </div>
                        <!-- Felder -->
                        <div
                            class           = "tab-pane fade"
                            id              = "anatomie-felder"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-felder-tab"
                        >
                            <p>
                                Alle weiteren Felder sind automatisch Nichtschl√ºsselfelder. Sie ben√∂tigen im einfachsten Fall keine
                                Annotationen, k√∂nnen aber welche besitzen, um die Feldeigenschaften genauer zu spezifizieren.
                                Das schauen wir uns auf <a href="#11">Folie 11</a> nochmal an. Die Felder sollten <code>private</code>
                                oder <code>protected</code> sein.
                            </p>
                            <source-code language="java">
                                private String vorname = "";
                                private String nachname = "";
                                private String titel = "";
                            </source-code>
                        </div>
                        <!-- Konstruktoren -->
                        <div
                            class           = "tab-pane fade"
                            id              = "anatomie-konstruktoren"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-konstruktoren-tab"
                        >
                            <p>
                                Jede Persistence Entity sollte mindestens einen √∂ffentlichen, parameterlosen Konstruktor besitzen, in dem
                                alle Felder mit leeren Werten vorbelegt werden. In diesem Beispiel ist der Konstruktor leer, da den Feldern
                                bereits bei ihrer Deklaration ein Wert zugewiesen wird.
                            </p>
                            <source-code language="java">
                                public Autor() {
                                }
                            </source-code>
                            <p>
                                Dar√ºber hinaus k√∂nnen beliebige weitere Konstruktoren definiert werden, um die Anlage neuer Objekte zu vereinfachen.
                                Vorgaben gibt es hierf√ºr keine, oftmals hat man aber noch einen Konstruktor, der f√ºr jedes Feld einen Parameter besitzt.
                            </p>
                            <source-code language="java">
                                public Autor(String vorname, String nachname, String titel) {
                                    this.vorname = vorname;
                                    this.nachname = nachname;
                                    this.titel = titel;
                                }
                            </source-code>
                        </div>
                        <!-- Setter und Getter -->
                        <div
                            class           = "tab-pane fade"
                            id              = "anatomie-setget"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-setget-tab"
                        >
                            <p>
                                Und damit es eine echte Bean ist, muss es zu jedem Feld mindestens einen Getter  geben. In der Regel gibt
                                es je Feld auch einen Stter, bei berechneten Feldern, deren Wert nicht in der Datenbank gespeichert wird,
                                kann er aber auch ausbleiben.
                            </p>
                            <source-code language="java">
                                //
                                // Normale Felder mit Setter und Getter
                                //
                                public void setId(long id) {
                                    this.id = id;
                                }

                                public long getId() {
                                    return this.id;
                                }

                                public void setVorname(String vorname) {
                                    this.vorname = vorname;
                                }

                                public String getVorname() {
                                    return this.vorname;
                                }

                                public void setNachname(String nachname) {
                                    this.nachname = nachname;
                                }

                                public String getNachname() {
                                    return this.nachname;
                                }

                                public void setTitel(String titel) {
                                    this.titel = titel;
                                }

                                public String getTitel() {
                                    return this.titel;
                                }

                                //
                                // Berechnete Felder ohne Setter
                                //
                                public String getNameKomplett() {
                                    String name = this.titel + " " + this.vorname + " " + this.nachname;
                                    return name.trim();
                                }
                            </source-code>
                        </div>
                        <!-- Alles zusammen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "anatomie-alles"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-alles-tab"
                        >
                            <source-code language="java">
                                //
                                // Schl√ºssel
                                //
                                @Id
                                @GeneratedValue
                                private long id = 0;

                                //
                                // Felder
                                //
                                private String vorname = "";
                                private String nachname = "";
                                private String titel = "";

                                //
                                // Konstruktoren
                                //
                                public Autor() {
                                }

                                public Autor(String vorname, String nachname, String titel) {
                                    this.vorname = vorname;
                                    this.nachname = nachname;
                                    this.titel = titel;
                                }

                                //
                                // Normale Felder mit Setter und Getter
                                //
                                public void setId(long id) {
                                    this.id = id;
                                }

                                public long getId() {
                                    return this.id;
                                }

                                public void setVorname(String vorname) {
                                    this.vorname = vorname;
                                }

                                public String getVorname() {
                                    return this.vorname;
                                }

                                public void setNachname(String nachname) {
                                    this.nachname = nachname;
                                }

                                public String getNachname() {
                                    return this.nachname;
                                }

                                public void setTitel(String titel) {
                                    this.titel = titel;
                                }

                                public String getTitel() {
                                    return this.titel;
                                }

                                //
                                // Berechnete Felder ohne Setter
                                //
                                public String getNameKomplett() {
                                    String name = this.titel + " " + this.vorname + " " + this.nachname;
                                    return name.trim();
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
                <source-code language="java">
                    }
                </source-code>
            </article>
            <aside>
                <p>
                    Persistence Entities zu schreiben ist wirklich einfach, da es sich um ganz normale Javaklassen
                    handelt, die einfach einen Datensatz einer Tabelle abbilden. üìñ Das hei√üt, sie besitzen einfach f√ºr
                    jedes Tabellenfeld ein gleichnamiges Attribut mit dazu passenden Setter- und Getter-Methoden. Hinzu
                    kommen noch ein paar kleine Annotationen, um sie als Entity zu kennzeichnen und die Schl√ºsselwerte
                    zu definieren und das war es auch schon. Zus√§tzlich wird empfohlen, dass sie das Interface
                    <code>Serializable</code> implementieren.
                </p>
                <source-code language="java">
                    @Entity
                    public class Autor
                    implements Serializable {
                        @Id
                        @GeneratesValue
                        private long id = 0;

                        public void setId(long id) {
                            this.id = id;
                        }

                        public long getId() {
                            return this.id;
                        }
                    }
                </source-code>
                <p>
                    Hier sehen wir auch gleich, wie der Tabellenschl√ºssel definiert wird. Die beiden Annotationen <code>@Id</code>
                    und <code>@GeneratedValue</code> legen fest, dass es sich bei dem Feld <code>id</code> um ein Schl√ºsselfeld
                    handelt und dass der Wert beim Speichern automatisch vergeben wird, wenn er leer ist.
                </p>
                <p>
                    Hinzu kommen dann einfach noch ein paar weitere Nichtschl√ºsselfelder (die immer <code>private</code> oder
                    <code>protected</code> sein sollten) samt Settern und Gettern sowie mindestens ein √∂ffentlicher, parameterloser
                    Konstruktor und fertig ist unsere Klasse. Also eigentlich ganz einfach, wie du auf der Folie siehst. üòé
                </p>
            </aside>
        </section>

        <section>
            <h1>Darf's ein bisschen mehr sein?</h1>
            <article>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üê™
                        </td>
                        <td>
                            Ohne weitere Angaben, darf eine Persistence Entity nur ein Schl√ºsselfeld besitzen:
                        </td>
                    </tr>
                </table>
                <source-code language="java">
                    @Entity
                    public class Verlag {
                        @Id
                        @GeneratedValue
                        private long id = 0;

                        ‚Ä¶
                    }
                </source-code>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üê™
                        </td>
                        <td>
                            Mehrere Schl√ºsselwerte m√ºssen in einer eigenen Klasse definiert werden.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üê™
                        </td>
                        <td>
                            Die Klasse muss mit <code>@IdClass</code> der Entity zugeordnet werden.
                        </td>
                    </tr>
                </table>
                <source-code language="java">
                    public class BuchId {
                        private String isbn = "";
                        private int auflage = 0;

                        // Konstruktoren ‚Ä¶
                        // Setter und Getter ‚Ä¶
                    }

                    @Entity
                    @IdClass(BuchId.class)
                    public class Buch {
                        @Id
                        private String isbn = "";

                        @Id
                        private int auflage = 0;

                        // Der ganze Rest ‚Ä¶
                    }
                </source-code>
            </article>
            <aside>
                <p>
                    So, wie es in der vorherigen Folie gezeigt wurde, kann eine Persistence Entity immer nur ein
                    Schl√ºsselfeld besitzen:
                </p>
                <source-code language="java">
                    @Entity
                    public class Verlag {
                        @Id
                        @GeneratedValue
                        private long id = 0;

                        ‚Ä¶
                    }
                </source-code>
                <p>
                    H√§ufiger als man denkt, reicht das auch v√∂llig aus. Manchmal kommt man aber um einen zusammengesetzten
                    Schl√ºssel mit mehreren Feldern nicht herum. Im Prinzip muss man daf√ºr einfach nur mehrere Felder mit
                    <code>@Id</code> auszeichnen, zus√§tzlich braucht man aber noch eine weitere Klasse, die nur den Schl√ºssel üóùÔ∏è
                    definiert.
                </p>
                <p>
                    Im Beispiel auf der Folie sieht man sch√∂n, wie das Klasse <code>BuchId</code> die beiden Felder <code>isbn</code>
                    und <code>auflage</code> definiert. Es handelt sich um die beiden Schl√ºsselfelder, mit denen eine ganz bestimmte
                    Auflage eines Buchs identifiziert wird. Vor der Klasse <code>Buch</code> steht daher die Annotation
                    <src-code language="java">@IdClass(BuchId.class)</src-code>, um zu definieren, dass die Klasse <code>BuchId</code>
                    die Schl√ºsselfelder vorschreibt. Zus√§tzlich befinden sich innerhalb von <code>Buch</code> ebenfalls die beiden Werte
                    <code>isbn</code> und <code>auflage</code>, jeweils mit <code>@Id</code> ausgestattet, damit sie auch tats√§chlich in
                    der Datenbank gespeichert werden.
                </p>

                <h2>Warum so kompliziert?</h2>
                <p>
                    Warum das so kompliziert ist, h√∂re ich dich fragen? Warum man nicht einfach auf die zweite Klasse verzichten kann? ü§î
                    Das sehen wir sp√§ter, wenn wir einzelne Objekte aus der Datenbank auslesen wollen. Hier brauchen wir dann die neue
                    Klasse, um die Schl√ºsselwerte des zu lesenden Datensatzes zu √ºbergeben.
                </p>
            </aside>
        </section>

        <section>
            <h1>Definition der Tabellen- und Feldeigenschaften</h1>
            <article>
                <h4>Ben√∂tigte Annotationen</h4>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üìé
                        </td>
                        <td>
                            <code>@Table</code>
                        </td>
                        <td>
                            Steht vor der Klasse und definiert weitere Tabelleneigenschaften.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üìé
                        </td>
                        <td>
                            <code>@Index</code>
                        </td>
                        <td>
                            Definiert die Felder eines Index auf die Tabelle.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üìé
                        </td>
                        <td>
                            <code>@Column</code>
                        </td>
                        <td>
                            Steht vor einem Feld und definiert weitere Feldeigenschaften.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üìé
                        </td>
                        <td>
                            <code>@Lob</code>
                        </td>
                        <td>
                            Kennzeichnet eine Feld als <i>Large Object</i> mit unbegrenzter L√§nge.
                        </td>
                    </tr>
                </table>

                <hr />

                <h4>Praktisches Beispiel</h4>
                <source-code language="java">
                    @Entity
                    @Table(
                        name    = "T_BUCH",
                        schema  = "BUCHSAMMLUNG",
                        indexes = {
                            @Index(
                                name       = "I_AUTOR_JAHR",
                                columnList = "autor, jahr DESC"
                            ),
                            @Index(
                                name       = "I_JAHR",
                                columnList = "jahr DESC"
                            )
                        }
                    )
                    public class Buch implements Serializable {
                        @Id
                        @Column(length=30)
                        private String isbn = "";

                        @Column(nullable=false, length=50)
                        private String autor;

                        @Column(nullable=false, precision=4)
                        private long jahr;

                        @Column(nullable=false, precision=7, scale=2)
                        private long preis;

                        @Lob
                        private String klappentext = "";

                        // Und so weiter ‚Ä¶
                    }
                </source-code>
            </article>
            <aside>
                <p>
                    In vielen F√§llen kann Java aus dem Namen einer Klasse und ihrer Felder sowie den dazugeh√∂rigen Datentypen genug
                    herauslesen, um sinnvolle Tabellen in der Datenbank anzulegen. L√§sst man die Tabellen jedoch nicht automatisch
                    anlegen, sondern schreibt Entities zu bereits vorhandenen Tabellen, muss man Java hier und da ein wenig auf die
                    Spr√ºnge helfen, üèá damit beides auch wirklich zusammen passt. Dasselbe gilt auch, wenn man Sachen definieren
                    will, die sich aus dem Javacode alleine nicht ableiten lassen, beispielsweise die maximale L√§nge eines Stringfelds. üìè
                </p>
                <p>
                    Der allgemeinen Logik von Java&nbsp;EE folgenden m√ºssen hierf√ºr nur ein paar mehr Annotationen in die Klassen
                    eingebaut werden. Ein etwas gr√∂√üeres Beispiel k√∂nnte daher wie auf der Folie dargestellt aussehen. Die Annotationen
                    haben dabei folgende Bedeutung:
                </p>
                <dl>
                    <dt>
                        <code>@Table</code>
                    </dt>
                    <dd>
                        <p>
                            Steht vor einer Klasse und definiert weitere Eigenschaften zur Tabelle:
                        </p>
                        <ul>
                            <li>
                                <b>name:</b> Name der Tabelle
                            </li>
                            <li>
                                <b>schama:</b> Datenbankschema, in dem die Tabelle angelegt wird (wenn die Datenbank mehrere Schemas
                                besitzt und nicht das Standardschema verwendet werden soll)
                            </li>
                            <li>
                                <b>indexes:</b> Mit <code>@Index</code> definierte Indizes zur Beschleunigung h√§ufiger Lesezugriffe
                            </li>
                        </ul>
                    </dd>

                    <dt>
                        <code>@Index</code>
                    </dt>
                    <dd>
                        <p>
                            Definiert die Feldes eines anzulegenden Index. Die Felder werden durch Komma getrennt und k√∂nnen wahlweise
                            mit <code>ASC</code> und <code>DESC</code> auf- oder absteigend sortiert werden. Ohne diese Angabe werden
                            die Felder aufsteigend sortiert.
                        </p>
                    </dd>
                    <dt>
                        <code>@Column</code>
                    </dt>
                    <dd>
                        <p>
                            Steht vor einem einzelnen Feld und definiert weiter Eigenschaften des Felds.
                        </p>
                        <ul>
                            <li>
                                <b>name:</b> Name des Felds
                            </li>
                            <li>
                                <b>length:</b> Maximale Feldl√§nge
                            </li>
                            <li>
                                <b>precision:</b> Anzahl Ziffern bei numerischen Feldern (inkl. Nachkommastellen!)
                            </li>
                            <li>
                                <b>scale:</b> Anzahl der Nachkommastellen bei nummerischen Feldern
                            </li>
                            <li>
                                <b>nullable:</b> Boolean, ob das Feld Null-Werte beinhalten darf
                            </li>
                            <li>
                                <b>insertable:</b> Boolean, ob das Feld beim Einf√ºgen neuer S√§tze ber√ºcksichtigt wird
                            </li>
                        </ul>
                    </tdd>

                    <dt>
                        <code>@Lob</code>
                    </dt>
                    <dd>
                        Steht vor einem Feld und legt fest, dass das Feld ein <i>Large Object</i> mit unbegrenzter
                        L√§nge ist. Dies ist wichtig, da Strings standardm√§√üig als <code>VARCHR(255)</code> und eben
                        nicht als unbegrenzt lange Felder angelegt werden. Allerdings reduzieren solche Felder die
                        Performance der Datenbank erheblich und sollten daher nur sehr sparsam üí∏ benutzt werden.
                        Auch kann man nicht nach ihnen selektieren.
                    </dd>
                </dl>
            </aside>
        </section>

        <section>
            <h1>Fremdschl√ºsselbeziehungen richtig abbilden</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-uebersicht-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-uebersicht"
                                role          = "tab"
                                aria-controls = "fremdschluessel-uebersicht"
                                aria-expanded = "true"
                            >
                                √úbersicht
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-1zu1-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-1zu1"
                                role          = "tab"
                                aria-controls = "fremdschluessel-1zu1"
                            >
                                1:1-Beziehungen
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-1zuN-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-1zuN"
                                role          = "tab"
                                aria-controls = "fremdschluessel-1zuN"
                            >
                                1:n-Beziehungen
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-Nzu1-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-Nzu1"
                                role          = "tab"
                                aria-controls = "fremdschluessel-Nzu1"
                            >
                                n:1-Beziehungen
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-NzuM-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-NzuM"
                                role          = "tab"
                                aria-controls = "fremdschluessel-NzuM"
                            >
                                n:m-Beziehungen
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- √úbersicht -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "fremdschluessel-uebersicht"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-uebersicht-tab"
                        >
                            <table style="margin-bottom: 1em;">
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        üîë
                                    </td>
                                    <td>
                                        Fremdschl√ºssel werden als Objektreferenzen in Java abgebildet.
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        üîë
                                    </td>
                                    <td>
                                        Eine Beziehung kann dabei die Kardinalit√§ten 1:1, 1:n, n:1 oder n:m besitzen.
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        ‚û°Ô∏è
                                    </td>
                                    <td>
                                        Unidirektionale Beziehungen verweisen einfach von einer Klasse auf eine andere.
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        ‚ÜîÔ∏è
                                    </td>
                                    <td>
                                        Bei bidirektionalen Beziehungen verweisen beide Klassen gegenseitig aufeinander.
                                    </td>
                                </tr>
                            </table>

                            <table style="margin-bottom: 2em;">
                                <thead>
                                    <tr>
                                        <th>
                                            Kardinalit√§t
                                        </th>
                                        <th>
                                            Einfache Verkn√ºpfung
                                        </th>
                                        <th>
                                            Optionale R√ºckverkn√ºpfung
                                        </th>
                                    </tr>
                                </thead>
                                <tr>
                                    <td>
                                        1:1
                                    </td>
                                    <td>
                                        <code>@OneToOne</code>
                                    </td>
                                    <td>
                                        <code>@OneToOne(mappedBy="feldname")</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        1:n
                                    </td>
                                    <td>
                                        <code>@OneToMany</code>
                                    </td>
                                    <td>
                                        <code>@ManyToOne(mappedBy="feldname")</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        n:1
                                    </td>
                                    <td>
                                        <code>@ManyToOne</code>
                                    </td>
                                    <td>
                                        <code>@OneToMany(mappedBy="feldname")</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        n:m
                                    </td>
                                    <td>
                                        <code>@ManyToMany</code>
                                    </td>
                                    <td>
                                        <code>@ManyToMany(mappedBy="feldname")</code>
                                    </td>
                                </tr>
                            </table>

                            <h4 style="margin-bottom: 0.5em;">Beispiel</h4>

                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    ‚Ä¶
                                    @ManyToOne(                      // Viele B√ºcher haben einen Verlag
                                        optional = false,            // Es muss immer einen Verlag geben
                                        fetch    = FetchType.LAZY    // Daten erst bei einem Zugriff darauf laden
                                    )
                                    Verlag verlag = null;

                                    @ManoToOne(
                                        optional = false,
                                        fetch    = FetchType.EAGER   // Daten so fr√ºh wie m√∂glich laden
                                    )
                                    Autor autor = null;
                                }
                            </source-code>
                        </div>
                        <!-- 1:1-Beziehungen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fremdschluessel-1zu1"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-1zu1-tab"
                        >
                            <h3>Unidirektionale Verkn√ºpfung</h3>
                            <p>
                                Eine Entity kann mit <code>@OneToOne</code> auf eine beliebige andere Entity verweisen, um einen Fremdschl√ºssel
                                mit 1:1-Kardinalit√§t abzubilden. In der Tabelle entsteht dadurch ein <b>Fremdschl√ºsselfeld</b>.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Autor {
                                    ‚Ä¶
                                    @OneToOne
                                    Adresse adresse = null;
                                }

                                @Entity
                                public class Adresse {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;
                                    ‚Ä¶
                                }
                            </source-code>

                            <h3>Verkn√ºpfung √ºber dieselben Schl√ºsselfelder</h3>
                            <p>
                                Das Fremdschl√ºsselfeld in der Tabelle kann entfallen, wenn beide Tabellen <b>identische Schl√ºsselwerte</b>
                                besitzen. In diesem Fall kommt zu <code>@OneToOne</code> noch die Annotation <code>@MapsId</code> hinzu.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Autor {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    @OneToOne
                                    @MapsId
                                    Adresse adresse = null;
                                }

                                @Entity
                                public class Adresse {
                                    @Id
                                    private long autorId = 0;
                                    ‚Ä¶
                                }
                            </source-code>

                            <h3>Bidirektionale Verkn√ºpfung</h3>
                            <p>
                                Eine bidirektionale Verkn√ºpfung entsteht, indem zus√§tzlich zur Verkn√ºpfung von der einen Klasse auf die andere,
                                die zweite Klasse mit <code>@OneToOne(mappedBy="‚Ä¶")</code> auf das Feld der ersten Klasse zur√ºckverweist.
                                In der Datenbank entsteht dadurch <b>kein zweiter Fremdschl√ºssel</b>.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Autor {
                                    ‚Ä¶
                                    @OneToOne
                                    Adresse adresse = null;
                                }

                                @Entity
                                public class Adresse {
                                    ‚Ä¶
                                    @OneToOne(mappedBy="adresse")
                                    Autor autor = null;
                                }
                            </source-code>
                        </div>
                        <!-- 1:n -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fremdschluessel-1zuN"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-1zuN-tab"
                        >
                            <h3>Unidirektionale Verkn√ºpfung</h3>
                            <p>
                                1:n-Beziehungen funktionieren grunds√§tzlich nicht anders als 1:1-Beziehungen. Doch anstelle einer
                                einfachen Referenz gibt es nun eine ganze Liste, auf die eine Entity verweisen kann. In der Datenbank
                                wird dies durch ein <b>Fremdschl√ºsselfeld in der Zieltabelle</b> abgebildet.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    ‚Ä¶
                                    @OneToMany
                                    List&lt;Bewertung&gt; bewertungen = new ArrayList&lt;&gt;();
                                }

                                @Entity
                                public class Bewertung {
                                    ‚Ä¶
                                }
                            </source-code>

                            <h3>Bidirektionale Verkn√ºpfung</h3>
                            <p>
                                Durch <code>@ManyToOne(mappedBy="‚Ä¶")</code> kann die Zielklasse wieder eine r√ºckw√§rtsgerichtete
                                Beziehung zur Quellklasse herstellen, ohne dass diese in der Datenbank abgelegt wird. Der Verweis
                                zeigt auf eine einzelne Referenz.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    ‚Ä¶
                                    @OneToMany
                                    List&lt;Bewertung&gt; bewertungen = new ArrayList&lt;&gt;();
                                }

                                @Entity
                                public class Bewertung {
                                    ‚Ä¶
                                    @ManyToOne(mappedBy="bewertungen")
                                    Buch buch = null;
                                }
                            </source-code>
                        </div>
                        <!-- n:1-Beziehungen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fremdschluessel-Nzu1"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-Nzu1-tab"
                        >
                            <h3>Unidirektionale Verkn√ºpfung</h3>
                            <p>
                                n:1 ist das Gegenteil von 1:n, logisch. Technisch gesehen ist es aber mehr mit 1:1 verwandt,
                                da auch hier einfach <b>ein Fremdschl√ºsselfeld in der Quelltabelle</b> entsteht. Allerdings
                                ist es hier erlaubt, dass mehrere Datens√§tze auf dieselbe Zielentit√§t verweisen.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    ‚Ä¶
                                    @ManyToOne
                                    Verlag verlag = null:
                                }

                                @Entity
                                public class Verlag {
                                    ‚Ä¶
                                }
                            </source-code>

                            <h3>Bidirektionale Verkn√ºpfung</h3>
                            <p>
                                Und auch hier gibt es die M√∂glichkeit, mit <code>@OneToMany(mappedBy="‚Ä¶")</code> eine inverse
                                Verkn√ºpfung zu definieren. Die Annotation muss dabei vor einer Liste stehen.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    ‚Ä¶
                                    @ManyToOne
                                    Verlag verlag = null:
                                }

                                @Entity
                                public class Verlag {
                                    ‚Ä¶
                                    @OneToMany(mappedBy="verlag")
                                    List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();
                                }
                            </source-code>
                        </div>
                        <!-- n:m-Beziehungen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fremdschluessel-NzuM"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-NzuM-tab"
                        >
                            <h3>Unidirektionale Verkn√ºpfung</h3>
                            <p>
                                Nach all den vorherigen Beispielen, wie wird da wohl eine n:m-Beziehung aussehen? Richtig, wir verwenden
                                <code>@ManyToMany</code> vor einer Liste. In der Datenbank entsteht dadurch eine <b>Verkn√ºpfungstabelle</b>.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    ‚Ä¶
                                    @ManyToMany
                                    List&lt;Autor&gt; autoren = new ArrayList&lt;&gt;();
                                }

                                @Entity
                                public class Autor {
                                    ‚Ä¶
                                }
                            </source-code>

                            <h3>Bidirektionale Verkn√ºpfung</h3>
                            <p>
                                Und wie immer auch mit R√ºckfahrticket, in diesem Fall <code>@ManyToMany(mappendBy="‚Ä¶")</code> ebenfalls
                                vor einer Liste.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    ‚Ä¶
                                    @ManyToMany
                                    List&lt;Autor&gt; autoren = new ArrayList&lt;&gt;();
                                }

                                @Entity
                                public class Autor {
                                    ‚Ä¶
                                    @ManyToMany(mappedBy="autoren")
                                    List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Fremdschl√ºsselbeziehungen geh√∂ren zu den gro√üen St√§rken relationaler Datenbanken und nat√ºrlich kann auch
                    die Java Persistence API damit umgehen. Doch im Gegensatz zu den Datenbanken legt JPA hier noch eine Schippe
                    an Komfort drauf und bildet die Beziehungen zwischen zwei Entities nicht einfach durch √úbernehmen der
                    Schl√ºsselwerte der einen Entity in die andere Entity ab. Kurz, so l√§uft es nicht: üôÉ
                </p>
                <source-code language="java">
                    @Entity
                    public class Verlag {
                        @Id
                        @GeneratedValue
                        private long id = 0;
                        ‚Ä¶
                    }

                    @Entity
                    public class Buch {
                        @Id
                        private String isbn = "";

                        // Vermeintlicher Fremdschl√ºssel
                        private long verlagId = 0;
                        ‚Ä¶
                    }
                </source-code>
                <p>
                    Stattdessen werden die Beziehungen √ºber Objektreferenzen abgebildet, so dass im obigen Beispiel ein <code>Buch</code>
                    einen direkten Verweis auf seinen <code>Verlag</code> h√§tte. Zus√§tzlich kommt eine spezielle Annotation zum Einsatz,
                    die besagt, um was f√ºr eine Verkn√ºpfung (1:1, 1:n, n:1 oder n:m) es sich handelt:
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        @Id
                        private String isbn = "";

                        // Richtiger Fremdschl√ºssel
                        @ManyToOne
                        private Verlag verlag = null;
                        ‚Ä¶
                    }
                </source-code>
                <p>
                    Das ist wirklich elegant! üëí Wir brauchen n√§mlich nur ein Objekt vom Typ <code>Buch</code> aus der Datenbank lesen
                    und bekommen alle Daten zum <code>Verlag</code> kostenlos mit dazu, ohne eine zweite Datenbankabfrage absetzen
                    zu m√ºssen. Das macht der O/R-Mapper bereits im Hintergrund, ohne dass wir uns darum k√ºmmern m√ºssen. Allerdings sollten
                    wir ihm deshalb auch sagen, wenn der die Daten vorerst nicht zu laden braucht, da sie ohnehin nicht immer ben√∂tigt
                    werden:
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        @Id
                        private String isbn = "";

                        // Richtiger Fremdschl√ºssel
                        @ManyToOne(fetchType=FetchType.LAZY)
                        private Verlag verlag = null;
                        ‚Ä¶
                    }
                </source-code>
                <p>
                    In diesem Fall w√ºrden die meisten O/R-Mapper die Daten zum Verlag erst nachladen, wenn wir wirklich auf das Attribut
                    <code>verlag</code> des Buchs zugreifen.
                </p>
                <p>
                    Des weiteren k√∂nnen wir in Java auch sogenannte <b>bidirektionale Beziehungen</b> herstellen, was es so in der
                    Datenbankwelt nicht gibt. Damit ist gemeint, dass nicht nur die Entit√§t A auf B verweisen sondern auch B zur√ºck
                    auf A verweisen kann. Ohne dass dieser zus√§tzliche Verweis in der Datenbank abgelegt wird. M√∂glich macht das das
                    Attribut <code>mappedBy</code> der verwendeten Annotationen, das immer den Feldnamen innerhalb der Quellentit√§t
                    enth√§lt.
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        ‚Ä¶
                        @ManyToOne
                        Verlag verlag = null;
                    }

                    @Entity
                    public class Verlag {
                        ‚Ä¶
                        @OneToMany(mappedBy="verlag")
                        List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();
                    }
                </source-code>
                <p>
                    Wenn dir das soweit klar ist, hast du bereits alles Wesentliche verstanden. ü§ù Auf der Folie findest du dann
                    weitere Beispiele und Erkl√§rungen dar√ºber, wie die verschiedenen Beziehungstypen in Java nachgebaut werden.
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)" id="aufgabe2">
            <h1>Aufgabe 2: Wir er√∂ffnen ein Kino</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "aufgabe2-diagramm-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#aufgabe2-diagramm"
                                role          = "tab"
                                aria-controls = "aufgabe2-diagramm"
                                aria-expanded = "true"
                            >
                                E/R-Diagramm
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe2-standort-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe2-standort"
                                role          = "tab"
                                aria-controls = "aufgabe2-standort"
                            >
                                Standort &amp; Co.
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe2-spielplan-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe2-spielplan"
                                role          = "tab"
                                aria-controls = "aufgabe2-spielplan"
                            >
                                Spielplan &amp; Co.
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe2-loesung-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe2-loesung"
                                role          = "tab"
                                aria-controls = "aufgabe2-loesung"
                            >
                                L√∂sung
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- E/R-Diagramm -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "aufgabe2-diagramm"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe2-diagramm-tab"
                        >
                            <p>
                                Hier ist es: Unser Datenmodell in seiner vollen Pracht. üåÖ Um die Aufgabe etwas leichter zu machen, haben wir den
                                Beziehungen eine Richtung gegeben und kleine Bezeichnungen hinzugef√ºgt. Schaue dir das Modell in aller Ruhe an und
                                versuche, so viel wie m√∂glich nachzuvollziehen. ü§î
                                <br />
                                <small>
                                    <small>
                                        Falls du dich wunderst, warum es eine Tabelle mit Standorten gibt: Der ehemalige Besitzer der
                                        <a href="http://www.schauburg.de" target="_blank">Schauburg</a>,
                                        <a href="https://ka.stadtwiki.net/Georg_Fricker" target="_blank">Georg Fricker</a>,
                                        war bis zum Schluss auch Gesch√§ftsf√ºhrer vom
                                        <a href="http://www.filmpalast.net/" target="_blank">Filmpalast am ZKM</a>.
                                    </small>
                                </small>
                            </p>
                            <img src="aufgabe2-komplett.svg" alt="Komplettes E/R-Diagramm unseres Kinobeispiels" class="d-block" style="width: 100%; margin-top: 1em;" />
                        </div>
                        <!-- Standort & Co. -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe2-standort"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe2-standort-tab"
                        >
                            <p>
                                Als kleine Anschubfinanzierung haben wir den oberen Teil rund um die Standorte des Kinos üéûÔ∏è bereits in Java umgesetzt. Unten findest
                                du den Quellcode.
                            </p>
                            <img src="aufgabe2-standort.svg" alt="Entit√§ten Standort, Mitarbeiter, Adresse und √ñffnungszeit" class="d-block" style="width: 100%; margin-top: 1em;" />
                            <source-code language="java">
                                @Entity
                                public class Standort implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String name = "";

                                    @OneToMany
                                    List&lt;Oeffnungszeit&gt; oeffnungszeiten = new ArrayList&lt;&gt;();

                                    @OneToOne
                                    Adresse adresse = new Adresse();

                                    @OneToMany(mappedBy="standort")
                                    List&lt;Mitarbeiter&gt; mitarbeiter = new ArrayList&lt;&gt;();

                                    @OneToMany
                                    List&lt;Spielplan&gt; = spielplaene new ArrayList&lt;&gt;();

                                    // Konstruktoren ‚Ä¶
                                    // Setter und Getter ‚Ä¶
                                }

                                @Entity
                                public class Oeffnungszeit implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private Wochentag wochentag = Wochentag.UNBEKANNT;
                                    private Time vonUhrzeit = new Time();
                                    private Time bisUhrzeit = new Time();

                                    @ManyToOne(mappedBy="oeffnungszeiten")
                                    Standort standort = new Standort();

                                    // Konstrukturen ‚Ä¶
                                    // Setter und Getter ‚Ä¶
                                }

                                public enum Wochentag {
                                    UNBEKANNT, MONTAG, DIENSTAG, MITTWOCH,
                                    DONNERSTAG, FREITAG, SAMSTAG, SONNTAG;
                                }

                                @Entity
                                public class Adresse implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String strasse = "";
                                    private String hausnummer = "";
                                    private String postleitzahl = "";
                                    private String ort = "";
                                    private String land = "";

                                    // Konstruktoren
                                    // Setter und Getter
                                }

                                @Entity
                                public class Mitarbeiter implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String vorname = "";
                                    private String nachname = "";
                                    private Geschlecht geschlecht = Geschlecht.UNBEKANNT;
                                    private int durchwahl = 0;
                                    private String email = "";

                                    @Column(precision=7, scale=2)
                                    private long monatsgehalt = 1000.00;

                                    @OneToOne
                                    Adresse adresse = new Addresse();

                                    @ManyToOne
                                    Standort standort = new Standort();

                                    // Konstruktoren ‚Ä¶
                                    // Setter und Getter ‚Ä¶
                                }

                                public enum GESCHLECHT {
                                    UNBEKANNT, MAENNLICH, WEIBLICH;
                                }
                            </source-code>
                        </div>
                        <!-- Spielplan & Co. -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe2-spielplan"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe2-spielplan-tab"
                        >
                            <p>
                                Jetzt bist du dran. üëâüèΩ Erg√§nze den Javacode um die fehlenden Entit√§ten rund im den Spielplan. Die Beziehungen zwischen
                                den Klassen sollen bidirektional umgesetzt werden und <a href="https://de.wikipedia.org/wiki/Filmgenre" target="_blank">Filmgenres</a>
                                k√∂nnen sein: <i>Action</i>, <i>Drama</i>, <i>Fantasy</i>, <i>SciFi</i>, <i>Kom√∂die</i> oder <i>Animation</i>.
                            </p>
                            <img src="aufgabe2-spielplan.svg" alt="Entit√§ten Spieplan, Vorf√ºhrung, Film und Mitwirkender" class="d-block" style="width: 100%; margin-top: 1em;" />
                        </div>
                        <!-- L√∂sung -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe2-loesung"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe2-loesung-tab"
                        >
                            <p>
                                Hier die Musterl√∂sung f√ºr die Persistence Entities rund um den Spielplan:
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Spielplan implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String name = "";

                                    @Lob
                                    private String webseitentext = "";

                                    @ManyToOne(mappedBy="spielplaene")
                                    Standort standort = new Standort();

                                    @OneToMany
                                    List&lt;Voerfuerhung&gt; vorfuehrungen = new ArrayList&lt;&gt;();

                                    // Konstruktoren
                                    // Setter und Getter ‚Ä¶
                                }

                                @Entity
                                public class Vorfuehrung implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private Wochentag wochentag = Wochentag.UNBEKANNT;
                                    private Time vonUhrzeit = new Time();
                                    private Time bisUhrzeit = new Time();
                                    private String kinosaal = "";

                                    @ManyToOne(mappedBy="vorfuehrungen")
                                    Spielplan spielplan = new Spielplan();

                                    @ManyToOne
                                    Film film = new Film();

                                    // Konstruktoren ‚Ä¶
                                    // Setter und Getter ‚Ä¶
                                }

                                @Entity
                                public class Film implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String name = "";
                                    private int jahr = 0;
                                    private Genre genre = Genre.UNBEKANNT;
                                    private String verleiher = "";

                                    @Lob
                                    private String webseitentext = "";

                                    @OneToMany(mappedBy="film")
                                    List&lt;Vorfuehrung&gt; vorfuehrungen = new ArrayList&lt;&gt;();

                                    @ManyToMany
                                    List&lt;Mitwirkender&gt; mitwirkende = new ArrayList&lt;&gt;();

                                    // Konstruktoren ‚Ä¶
                                    // Setter und Getter ‚Ä¶
                                }

                                public enum Genre {
                                    UNBEKANNT, ACTION, DRAMA, FANTASY, SCIFI, COMEDY, ANIMATION;
                                }

                                @Entity
                                public class Mitwirkender implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String vorname = "";
                                    private String nachname = "";
                                    private String artDerMitwirkung = "";
                                    private String nameImFilm = "";

                                    @ManyToMany(mappedBy="mitwirkende")
                                    Lilst&lt;Film&gt; filme = new ArrayList&lt;&gt;();

                                    // Konstruktoren ‚Ä¶
                                    // Setter und Getter ‚Ä¶
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Nach so vielen neuen Informationen wollen wir unser neu erworbenes Wissen doch gleich mal anwenden.
                    Auf dieser Folie siehst du daher ein gr√∂√üeres Beispiel √ºber ein
                    <a href="http://www.schauburg.de/">nicht ganz unbekanntes Kino hier in Karlsruhe</a>. üìΩÔ∏è
                    Denn B√ºcher üìö haben jetzt wahrlich genug gesehen. üòõ
                </p>
                <img src="schauburg.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://ka.stadtwiki.net/Datei:Schauburg_-_Frontal_20131222-121940.hk.jpg" target="_blank">Stadtwiki Karlsruhe: Kucharek</a>
                        <!-- Vorsicht: CC-BY-NC-SA Lizenz -->
                    </small>
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 3: Ein kleines Persistence-Entity-Quiz</h1>
            <article>
                <h2>Aufgabe 3.1: Schl√ºsselwerte definieren</h2>

                <p>
                    a) Persistence Entities besitzen immer nur ein Schl√ºsselfeld.
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Wahr
                    </li>
                    <li>
                        Falsch
                    </li>
                </ol>

                <p>
                    b) Persistence Entities k√∂nnen auch nicht-automatisch vergebene Schl√ºsselfelder besitzen.
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Wahr
                    </li>
                    <li>
                        Falsch
                    </li>
                </ol>

                <p>
                    c) Welche Annotation kennzeichnet die Schl√ºsselfelder einer Persistence Entity?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <code>@Key</code>
                    </li>
                    <li>
                        <code>@Id</code>
                    </li>
                    <li>
                        <code>@IdClass</code>
                    </li>
                    <li>
                        <code>@IdField</code>
                    </li>
                </ol>

                <p>
                    d) Wie muss man vorgehen, um eine Entity mit mehr als einem Schl√ºsselfeld zu definieren?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Das geht nicht, siehe Frage a).
                    </li>
                    <li>
                        Einfach alle Felder mit <code>@IdField</code> kennzeichnen.
                    </li>
                    <li>
                        Alle Felder mit <code>@Id</code> kennzeichnen und mit <code>@IdClass</code> auf eine
                        Klasse mit nur den Schl√ºsselfeldern verweisen.
                    </li>
                    <li>
                        Alle Schl√ºsselfelder in einer eigenen Klasse definieren und dann eine Referenz
                        auf die Klasse mit <code>@IdClass</code> kennzeichnen.
                    </li>
                </ol>

                <h2>Aufgabe 3.2: Tabellen- und Feldeigenschaften</h2>

                <p>
                    a) Wie oft kann die Annotation <code>@Table</code> in einer Persistence Entity verwendet werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Gar nicht, es handelt sich um eine Annotation f√ºr EJBs
                    </li>
                    <li>
                        H√∂chstens einmal
                    </li>
                    <li>
                        Genau einmal
                    </li>
                    <li>
                        H√∂chstens drei mal
                    </li>
                    <li>
                        Beliebig oft
                    </li>
                </ol>

                <p>
                    b) An welcher Stelle muss die Annotation <code>@Column</code> in einer Persistence Entity stehen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Irgendwo vor der Klasse
                    </li>
                    <li>
                        Immer vor der Annotation <code>@Entity</code>
                    </li>
                    <li>
                        Immer nach der Annotation <code>@Entity</code>
                    </li>
                    <li>
                        In jeder beliebigen Stelle innerhalb der Klasse
                    </li>
                    <li>
                        Vor beliebig vielen Attributen der Klasse
                    </li>
                    <li>
                        Vor beliebig vielen Methodenparametern
                    </li>
                </ol>

                <p>
                    c) Wozu dienen die Indizes, die mit <code>@Table</code> definiert werden k√∂nnen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Der Beschleunigung h√§ufig ben√∂tigter Datenselektionen
                    </li>
                    <li>
                        Der Beschleunigung h√§ufig ben√∂tigter Einf√ºgeoperationen
                    </li>
                    <li>
                        Der Vorsortierung h√§ufig geschriebener Datens√§tze
                    </li>
                    <li>
                        Der Kompatibilit√§t mit anderen O/R-Mappern
                    </li>
                </ol>

                <p>
                    d) Was dr√ºcken die Werte <b>precision</b> und <b>scale</b> der Annotation <code>@Column</code> aus?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Die Mindest- und Maximall√§nge zeichenartiger Felder
                    </li>
                    <li>
                        Wie genau eine Fremdschl√ºsselbeziehung spezifiziert ist
                    </li>
                    <li>
                        Die maximale Anzahl Ziffern einer Kommazahl sowie wie viele davon Nachkommastellen sind
                    </li>
                    <li>
                        Die Anzahl, wie oft ein Boolean auf <code>false</code> umschalten darf
                    </li>
                    <li>
                        Die Genauigkeit, mit der du diese Antworten liest
                    </li>
                    <li>
                        Das maximale Gesamtgewicht aller Entities in Kilogramm oder Pfund
                    </li>
                </ol>

                <p>
                    e) Wie kann der Name einer Tabelle oder eines Felds in der Datenbank √ºberschrieben werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Mit der Annotation <code>@Name</code> vor der Klasse oder dem Feld
                    </li>
                    <li>
                        Mit dem Attribut <b>name</b> der Annotationen <code>@Table</code> und <code>@Column</code>
                    </li>
                    <li>
                        Mit der Annotation <code>@BeanName</code> innerhalb der rufenden EJBs
                    </li>
                </ol>

                <p>
                    f) Welche Vor- und Nachteile ergeben sich aus der Annotation <code>@Lob</code>?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Die dadurch gekennzeichneten Stringfelder k√∂nnen jede beliebige Gr√∂√üe annehmen, dr√ºcken
                        daf√ºr aber die Performance nach unten.
                    </li>
                    <li>
                        Die dadurch gekennzeichneten Integerfelder k√∂nnen beliebig gro√üe Zahlen annehmen, daf√ºr
                        kann nach ihnen nicht selektiert werden.
                    </li>
                    <li>
                        Man lobt den Entwickler f√ºr seine gute Arbeit, es gibt aber keine Annotation f√ºr <code>@Tadel</code>.
                    </li>
                </ol>

                <h2>Aufgabe 3.3: Fremdschl√ºsselbeziehungen</h2>

                <p>
                    a) Welche der folgenden Beziehungstypen k√∂nnen nicht mit JPA abgebildet werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        1:1-Beziehungen
                    </li>
                    <li>
                        1:n-Beziehungen
                    </li>
                    <li>
                        n:1-Beziehungen
                    </li>
                    <li>
                        n:m-Beziehungen
                    </li>
                </ol>

                <p>
                    b) Wie werden 16:9-Beziehungen mit der Java Persistence API abgebildet?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Gar nicht, du warst wohl zu oft im Kino!
                    </li>
                    <li>
                        Mit der Annotation <code>@Widescreen</code>
                    </li>
                    <li>
                        Mit den Annotationen <code>@HdReady</code> und <code>@FullHD</code>
                    </li>
                </ol>

                <p>
                    c) Was sind bidirektionale Beziehungen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Einfache Beziehungen von einer Entit√§t zu einer anderen
                    </li>
                    <li>
                        Beziehungen mit mehr als einer Zielentit√§t
                    </li>
                    <li>
                        Beziehungen in beide Richtungen zwischen zwei Entit√§ten
                    </li>
                    <li>
                        Beziehungen mit mehr als einer Startidentit√§t
                    </li>
                </ol>

                <p>
                    d) Welche Anpassung muss bei einer unidirektionalen Beziehungen an der Zielentit√§t vorgenommen werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Keine, das ist nur bei bidirektionalen Beziehungen erforderlich.
                    </li>
                    <li>
                        Es muss eine passende Annotation mit der Eigenschaft <b>mappedBy</b> hinzugef√ºgt werden.
                    </li>
                    <li>
                        Es muss eine gegenl√§ufige Annotation ohne besondere Eigenschaften hinzugef√ºgt werden.
                    </li>
                    <li>
                        Es muss mit <code>@ForeignKey</code> ein r√ºckw√§rtsgerichteter Fremdschl√ºssel hinzugef√ºgt werden.
                    </li>
                </ol>

                <p>
                    e) Und welche Anpassung muss bei einer bidirektionalen Beziehung an der Zielentit√§t vorgenommen werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Keine, das ist nur bei unidirektionalen Beziehungen erforderlich.
                    </li>
                    <li>
                        Es muss eine passende Annotation mit der Eigenschaft <b>mappedBy</b> hinzugef√ºgt werden.
                    </li>
                    <li>
                        Es muss eine gegenl√§ufige Annotation ohne besondere Eigenschaften hinzugef√ºgt werden.
                    </li>
                    <li>
                        Es muss mit <code>@ForeignKey</code> ein r√ºckw√§rtsgerichteter Fremdschl√ºssel hinzugef√ºgt werden.
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>L√∂sung:</b> <br />
                        Aufgabe 3.1: 2, 1, 2, 3 <br />
                        Aufgabe 3.2: 4, 5, 1, 3, 2, 1 <br />
                        Aufgabe 3.3: alle, 1, 3, 1, 2
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Hier dann noch ein paar Wiederholungsfragen, um auch die weniger h√§ufigen Annotationen
                    abzuklopfen. Wenn du die kannst, bist du echt gut. ü•â
                </p>
            </aside>
        </section>

        <!--
            ==============================
            DATEN LESEN, SCHREIBEN, √ÑNDERN
            ==============================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Daten lesen, schreiben, √§ndern</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Ohne Persistence Unit geht es nicht</h1>
            <article>
                <ul class="dhbw-carousel-links">
                    <li>
                        <a href="#persistence-unit-carousel" role="button" data-slide="next">N√§chstes Bild</a>
                    </li>
                    <li>
                        <a href="#persistence-unit-carousel" role="button" data-slide="prev">Vorheriges Bild</a>
                    </li>
                    <li>
                        <a href="#persistence-unit-carousel" role="button" data-slide-to="0">Nochmal von vorne</a>
                    </li>
                </ul>
                <div id="persistence-unit-carousel" class="carousel slide" style="margin-bottom: 1em;" data-interval="false">
                    <div class="carousel-inner">
                        <div class="carousel-item img-thumbnail active">
                            <p>
                                Angenommen, du hast gerade ein neues Webprojekt in Netbeans erstellt.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-01.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Dann sieht das Projekt am Anfang nat√ºrlich noch ziemlich leer aus. Vor allem fehlt uns eine
                                <b>Persistence Unit</b>, die definiert, mit welcher Datenbank wir arbeiten.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-02.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Per Rechtsklick auf den Namen des Projekts l√§sst sie sich ganz einfach anlegen.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-03.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Im darauf folgenden Fenster musst du die folgenden Werte √ºbernehmen, damit hinterher alles
                                so l√§uft, wie es soll. üö∂üèø
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-04.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Im Men√º links taucht nun die Datei <tt>persistence.xml</tt> auf. Netbeans bietet hierf√ºr
                                auch gleich einen praktischen Editor.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-05.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                So sieht der XML-Code der Datei aus. Der grafische Editor ist aber einfacher zu bedienen.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-06.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Jetzt kann es los gehen. üèÅ Lass uns ein paar Daten selektieren.
                            </p>
                            <img class="active d-block w-25 m-auto" src="../../finish.svg" />
                        </div>
                    </div>
                </div>

                <p>
                    <small>
                        <small>
                            Bildnachweis f√ºr das Endesymbol: <a href="https://pixabay.com/en/symbol-gui-internet-internet-page-2480163/" target="_blank">Pixabay: janf93</a>
                        </small>
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Bisher sind wir immer davon ausgegangen, dass der Applikationsserver mit nur einer Datenbank verbunden ist und daher
                    einfach alles seinen richtigen Weg l√§uft. Das muss aber nicht so sein, ein Applikationsserver kann durchaus mit mehreren
                    Datenbanken verbunden sein, so dass jede darauf laufende Anwendung seine eigene Datenbank nutzt. Ja, das ist sogar der
                    Normalfall, selbst wenn die Datenbanken alle vom selben Datenbankserver verwaltet werden.¬π üêÑ
                </p>
                <p>
                    <small>
                        ¬π Typische Datenbankserver wie <a href="https://mariadb.org/" target="_blank">MariaDB</a> oder
                        <a href="https://www.postgresql.org/" target="_blank">PostgreSQL</a> k√∂nnen mehrere, logische Datenbanken verwalten,
                        um somit mehrere Anwendungen sauber zu isolieren. Dadurch ist es dann auch kein Problem, wenn zwei Datenbanken
                        gleichnamige Tabellen beinhalten.
                    </small>
                </p>
                <p>
                    Aus diesem Grund ben√∂tigt jede Java-EE-Anwendung mindestens eine sogenannte <b>Persistence Unit</b>, die definiert,
                    welche Datenbank sie verwendet. Technisch gesehen bedeutet das, dass Anwendung eine Datei mit dem Namen
                    <tt>persistence.xml</tt> beinhalten muss, in der mindestens eine solche Persistence Unit definiert ist.
                    Doch anstatt jetzt die XML-Syntax zu erkl√§ren, zeigen dir die Bilder auf der Folie, wie die Datei mit Netbeans
                    angelegt und bearbeitet werden kann.
                </p>
                <p>
                    Die Felder im Anlagewizard haben dabei folgende Bedeutung:
                </p>
                <ul>
                    <li>
                        <b>Persistence Unit Name:</b> Name der Persistence Unit, unter der sie im Quellcode angesprochen wird.
                        Der Name sollte daher kurz und einpr√§gsam sein, auch wenn er bei vorliegen von nur einer Persistence
                        Unit nicht weiter ben√∂tigt wird.
                    </li>
                    <li>
                        <b>Persistence Provider:</b> Die verwendete O/R-Mapper-Implementierung. Die Vorauswahl <i>EclipseLink</i>
                        geht v√∂llig in Ordnung. Wie an den meisten Stellen erlaubt Java eben, dass es mehrere Implementierungen
                        zu einer API gibt.
                    </li>
                    <li>
                        <b>Data Source:</b> Der Name der Datenbank, so wie sie im Applikationsserver konfiguriert wurde. Im
                        Echtbetrieb m√ºssten wir die Konfiguration erst anlegen, f√ºr die √úbungen reicht aber die von Netbeans
                        bereitgestellte Konfiguration <tt>jdbc/__default</tt>.
                    </li>
                    <li>
                        <b>Table Generation Strategy:</b> Wer legt die Tabellen an und wie oft geschieht dies? Legst du die
                        Tabellen selbst an (None) oder sollen sie beim ersten Start der Anwendung automatisch angelegt werden?
                        Falls ja, soll dies nur einmalig erfolgen (Create) oder bei jedem Start der Anwendung erneut (Drop and Create)?
                    </li>
                </ul>
                <p>
                    F√ºr die √úbungen bietet es sich an, als Anlagestrategie <i>Create</i> zu w√§hlen, damit die Inhalte der Tabellen
                    nicht verloren gehen. Jedoch musst du dann hin und wieder die Tabellen von Hand l√∂schen, da nicht jede √Ñnderung
                    an den Persistence Entities immer in den Tabellen nachgezogen wird. Komischen Fehlermeldungen beim Lesen oder
                    Schreiben, beispielsweise dass die Tabelle ein bestimmtes Feld nicht enth√§lt, k√∂nnen hier ein Hinweis sein. üîî
                </p>
            </aside>
        </section>

        <section>
            <h1>Der Entity Manager stellt sich vor</h1>
            <article>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üóÑÔ∏è
                        </td>
                        <td>
                            S√§mtliche Datenbankzugriffe werden von einem <code>EntityManager</code>-Objekt durchgef√ºhrt.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üóÑÔ∏è
                        </td>
                        <td>
                            Dieses Objekt stellt aus Anwendungssicht den O/R-Mapper dar, der Daten lesen und schreiben kann.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üóÑÔ∏è
                        </td>
                        <td>
                            Mit der Annotation <code>@PersistenceContext</code> k√∂nnen wir uns das Objekt geben lassen.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üóÑÔ∏è
                        </td>
                        <td>
                            Die Annotation funktioniert in Serlvets und in EJBs, sollte aber nur in EJBs verwendet werden.
                        </td>
                    </tr>
                </table>

                <source-code language="java">
                    @Stateless
                    public class KinoBean {
                        @PersistenceContext
                        EntityManager em;
                        ‚Ä¶
                    }
                </source-code>

                <div style="margin-top: 1em;">
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "entitymanager-methoden-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#entitymanager-methoden"
                                role          = "tab"
                                aria-controls = "entitymanager-methoden"
                                aria-expanded = "true"
                            >
                                H√§ufig ben√∂tigte Methoden
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "entitymanager-beispiel-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#entitymanager-beispiel"
                                role          = "tab"
                                aria-controls = "entitymanager-beispiel"
                            >
                                Beispiel
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- H√§ufig ben√∂tigte Methoden -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "entitymanager-methoden"
                            role            = "tabpanel"
                            aria-labelledby = "entitymanager-methoden-tab"
                        >
                            <p>
                                <src-code language="java">
                                    &lt;T&gt; T find(Class&lt;T&gt; entityClass, Object primaryKey)
                                </src-code>
                                <br />
                                Auslesen eines Objekts anhand seines Prim√§rschl√ºssels
                            </p>

                            <p>
                                <src-code language="java">
                                    void persist(Object entity)
                                </src-code>
                                <br />
                                Speichern eines <b>neuen</b> Datensatzes.
                            </p>

                            <p>
                                <src-code language="java">
                                    &lt;T&gt; T merge(&lt;T&gt; entity)
                                </src-code>
                                <br />
                                Aktualisieren eines <b>vorhandenen</b> Datensatzes.
                            </p>

                            <p>
                                <src-code language="java">
                                    void remove(Object entity)
                                </src-code>
                                <br />
                                L√∂schen eines vorhandenen Datensatzes.
                            </p>

                            <hr />

                            <p>
                                <src-code language="java">
                                    Query createQuery(String qlString)
                                </src-code>
                                <br />
                                Erzeugen einer neuen Datenbankanfrage (vgl. <a href="#18">n√§chste Folie</a>)
                            </p>
                        </div>
                        <!-- Beispiel -->
                        <div
                            class           = "tab-pane fade"
                            id              = "entitymanager-beispiel"
                            role            = "tabpanel"
                            aria-labelledby = "entitymanager-beispiel-tab"
                        >
                            <source-code language="java">
                                @Stateless
                                public class MitarbeiterBean {
                                    @PersistenceContext
                                    EntityManager em;

                                    /**
                                     * Auslesen eines einzelnen Mitarbeiters
                                     */
                                    public Mitarbeiter findById(long id) {
                                        return this.em.find(Mitarbeiter.class, id);
                                    }

                                    /**
                                     * Speichern eines neuen Mitarbeiters und den gespeicherten
                                     * Satz zur√ºckgeben, damit der Aufrufer die ID erf√§hrt.
                                     */
                                    public Mitarbeiter saveNew(Mitarbeiter mitarbeiter) {
                                        em.persist(mitarbeiter);
                                        return em.merge(mitarbeiter);
                                    }

                                    /**
                                     * √Ñnderungen an einem vorhandenen Mitarbeiter speichern.
                                     */
                                    public Mitarbeiter update(Mitarbeiter mitarbeiter) {
                                        return em.merge(mitarbeiter);
                                    }

                                    /**
                                     * Wie lange arbeiten Sie schon hier, morgen nicht mehr
                                     * mitgerechnet? üôá
                                     */
                                    public void delete(Mitarbeiter mitarbeiter) {
                                        return em.remove(mitarbeiter);
                                    }
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    <i>Guten Tag, Manager mein Name. Entity Manager. Ich bediene Sie heute. Was w√ºrden Sie denn gerne bestellen?
                    Ah, einmal den Film Nummer 7, sehr gern. </i> So oder so √§hnlich w√ºrde es klingen, wenn wir uns wirklich mit
                    Java unterhalten k√∂nnten. üìû Denn der Entity Manager ist das Objekt, das uns die ganze schreckliche
                    JDBC-Programmierung aus <a href="#3">Folie 3</a> vom Hals h√§lt. Oder anders gesagt: Er ist der O/R-Mapper,
                    der wei√ü, wie man Javaobjekte zu Tabellenzeilen konvertiert und umgekehrt. ‚ÜïÔ∏è
                </p>
                <p>
                    Doch bevor es losgehen kann, brauchen wir erst mal eine Referenz, die wir uns innerhalb jedes Servlets und
                    jeder Enterprise Java Bean mit folgenden Zeilen besorgen k√∂nnen. Innerhalb eines Servlets sollte das aber
                    eigentlich vermieden werden.
                </p>
                <source-code language="java">
                    @Stateless
                    public class MisterBean {
                        @PersistenceContext
                        EntityManager em;
                        ‚Ä¶
                    }
                </source-code>
                <p>
                    Ist das einmal geschafft, k√∂nnen wir die auf der Folie dargestellten Methoden verwenden, um Datens√§tze
                    auszulesen, zu schreiben oder zu l√∂schen. Es ist wirklich ziemlich einfach, wie das folgende Beispiel zeigt:
                </p>
                <source-code language="java">
                    @Stateless
                    public class MitarbeiterBean {
                        @PersistenceContext
                        EntityManager em;

                        /**
                         * Auslesen eines einzelnen Mitarbeiters
                         */
                        public Mitarbeiter findById(long id) {
                            // Sucht einen Mitarbeiter anhand seiner Schl√ºsselwerte
                            return this.em.find(Mitarbeiter.class, id);
                        }

                        /**
                         * Gehaltserh√∂hung f√ºr einen Mitarbeiter vornhehmen
                         */
                        public Mitarbeiter gehaltErhoehen(long id, long faktor) {
                            // Auslesen des Mitarbeiters
                            Mitarbeiter ma = this.em.find(Mitarbeiter.class, id);

                            // Abbruch, wenn er nicht gefunden wurde
                            if (ma == null) return;

                            // Neues Gehalt berechnen
                            ma.setGehalt(ma.getGehalt() * faktor);

                            // Mitarbeiter speichern
                            return this.em.merge(ma);
                        }

                        /**
                         * Neuen Mitarbeiter anlegen
                         */
                        public Mitarbeiter saveNew(Mitarbeiter ma) {
                            // Neuen Mitarbeiter speichern
                            this.em.persist(ma);

                            // Mitarbeiter aktualisieren, so dass das ID-Feld
                            // gef√ºllt ist
                            return this.em.merge(ma);
                        }
                    }
                </source-code>
                <p>
                    Wollten wir nun einen neuen Mitarbeiter anlegen, m√ºssten wir nur eine neues Objekt erzeugen,
                    es mit Werten f√ºllen und die Methode <code>saveNew</code> der obigen EJB aufrufen. Ungef√§hr so:
                </p>
                <source-code language="java">
                    @WebServet(urlPatterns={"/neuer-mitarbeiter/"})
                    public class NeuerMitarbeiterServlet extends HttpServlet {
                        @EJB
                        MitarbeiterBean mitarbeiterBean

                        public void doGet(‚Ä¶) {
                            // Neuen Mitarbeiter erzeugen
                            Mitarbeiter ma = new Mitarbeiter();
                            ma.setVorname("Frank");
                            ma.setNachname("Columbo");
                            ma.setGehalt(2500.00);

                            // Datensatz speichern
                            ma = this.mitarbeiterBean.saveNew(ma);
                        }
                    }
                </source-code>
                <p>
                    Den Rest √ºbernimmt dann der Entity Manager f√ºr uns, ohne dass wir auch nur in die N√§he eines
                    SQL-Statements kommen. Das ist wirklich klasse! üí´
                </p>
            </aside>
        </section>

        <section>
            <h1>Komplexe Anfragen formulieren</h1>
            <article>
                <div class="container-fluid">
                    <!-- Bilder -->
                    <div class="row">
                        <div class="col-md">
                            <img src="jql1.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                            Jede Datenbank hat ihren eigenen SQL-Dialekt, was oftmals ziemlich verwirrend sein kann.
                        </div>
                        <div class="col-md">
                            <img src="jql2.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                            JQL hilft uns deshalb und definiert neutrale Anweisungen, die immer funktionieren.
                        </div>
                    </div>

                    <!-- Beispielselektionen -->
                    <div class="row">
                        <div class="col-md">
                            <p class="dhbw-lightblue">
                                Selektion mit Parametern in SQL:
                            </p>
                            <source-code language="sql">
                                SELECT * FROM Film
                                    WHERE filmname = ?
                                      AND jahr BETWEEN ? AND ?
                                      AND genre = ?
                            </source-code>
                        </div>
                        <div class="col-md">
                            <p class="dhbw-lightblue">
                                Selektion mit Parametern in JQL:
                            </p>
                            <source-code language="sql">
                                SELECT f FROM Film f
                                    WHERE f.name = :name
                                      AND f.jahr BETWEEN :von AND :bis
                                      AND f.genre = :genre
                            </source-code>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md">
                            <hr />
                            <h4 class="dhbw-lightblue" style="margin-bottom: 1em;">Vollst√§ndiges Beispiel</h4>

                            <source-code language="java">
                                @Statless
                                public class JqlSelectBeispiel {
                                    @PersistenceContext
                                    EntityManager em;

                                    public List&lt;Film&gt; sucheFilm(String name, int vonJahr, int bisJahr, Genre genre) {
                                            return em.createQuery(
                                                        "SELECT f FROM Film f"
                                                      + "    WHERE f.name LIKE :name"
                                                      + "      AND f.jahr BETWEEN :von AND :bis"
                                                      + "      AND g.genre = :genre"
                                                     )
                                                     .setParameter("name", name)
                                                     .setParameter("von", vonJahr)
                                                     .setParameter("bis", bisJahr)
                                                     .setParameter("genre", genre)
                                                     .getResultList();
                                        }
                                }
                            </source-code>
                        </div>
                    </div>

                    <!-- Bildnachweise -->
                    <div class="row">
                        <div class="col-md">
                            <small>
                                <small>
                                    Bildnachweise:
                                    <a href="https://pixabay.com/de/kinder-m%C3%A4dchen-wei%C3%9F-kind-attraktiv-3041378/" target="_blank">Pixabay: Khamkhor</a>,
                                    <a href="https://pixabay.com/de/im-freien-kinder-natur-hund-3067805/" target="_blank">Pixabay: tohidabbasy</a>
                                </small>
                            </small>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Manchmal macht es nat√ºrlich Sinn, nicht einfach nur einzelne Datens√§tze aus der Datenbank zu lesen
                    oder zu schreiben, sondern gleich mehrere S√§tze auf einen Schlag. Zum Beispiel, wenn der Anwender
                    einen Suchbegriff eingibt und wir ihm eine Liste der m√∂glichen Kandidaten zur√ºckliefern wollen.
                    Oder wenn wir an tausenden Eintr√§gen dieselbe √Ñnderung vornehmen wollten. Da w√§re es nat√ºrlich pure
                    Zeitverschwendung, jeden Datensatz einzeln zu lesen, zu ver√§ndern und dann zu speichern.
                </p>
                <p>
                    In diesem F√§llen w√ºrde man normalerweise anfangen, auf den jeweiligen Anwendungsfall optimierte
                    SQL-Befehle zu verwenden, doch leider gibt es da ein Problem: Die SQL-Anweisungen unterscheiden sich
                    von Hersteller zu Hersteller. Zwar sind die meisten Statements im Kern normiert, jeder Hersteller
                    bietet aber eigene Spracherweiterungen, die nur mit seinen Produkten funktionieren. Komplexe
                    SQL-Anfragen k√∂nnen daher nur bedingt datenbankneutral formuliert werden. ü§¶
                </p>
                <p>
                    Die Java Persistence API l√∂st dieses Problem, indem sie eine eigene, an SQL angelehnte Query Language
                    namens <b>Java Persistence Query Language</b>, kurz JQL, zur Verf√ºgung stellt und die so formulierten
                    Anfragen zur Laufzeit in herstellerspezifische SQL-Anweisungen umwandelt.
                    Auf <a href="https://en.wikibooks.org/wiki/Java_Persistence/JPQL" target="_blank">Wikibooks</a> gibt
                    es eine ziemlich umfangreiche Sammlung mit Beispielen. Hier sollen uns ein paar einfache Selektionen
                    gen√ºgen.
                </p>
                <p>
                    √Ñhnlich wie in SQL gibt es auch in JQL ein <code>SELECT</code>-Statement. Die Syntax ist allerdings
                    leicht anders. Hier siehst du gleich den vollen Aufruf, so wie die Anfrage an den Entity Manager
                    √ºbergeben werden muss, um alle Ergebnisse zur√ºck zu bekommen:
                </p>
                <source-code language="java">
                    @Statless
                    public class SelectBeispiel1 {
                        @PersistenceContext
                        EntityManager em;

                        public List&lt;Film&gt; sucheNameUndJahr(
                            String name, int vonJahr, int bisJahr) {

                                return em.createQuery(
                                            "SELECT f FROM Film f"
                                          + "  WHERE f.name LIKE :name"
                                          + "    AND f.jahr BETWEEN :von AND :bis"
                                         )
                                         .setParameter("name", name)
                                         .setParameter("von", vonJahr)
                                         .setParameter("bis", bisJahr)
                                         .getResultList();
                            }
                    }
                </source-code>
                <p>
                    Mit der Punktsyntax k√∂nnen sogar die Felder aus den Beziehungen abgefragt werden:
                </p>
                <source-code language="java">
                    @Statless
                    public class SelectBeispiel2 {
                        @PersistenceContext
                        EntityManager em;

                        public List&lt;Film&gt; filmeAnWochentag(Wochentag wochentag) {
                            return em.createQuery(
                                        "SELECT f FROM Film f"
                                      + "  WHERE f.vorfuehrungen.wochentag = :wochentag"
                                     )
                                     .setParameter("wochentag", wochentag)
                                     .getResultList();
                        }
                    }
                </source-code>
                <p>
                    Und so weiter und sofort. Schau dir den Link auf
                    <a href="https://en.wikibooks.org/wiki/Java_Persistence/JPQL" target="_blank">Wikibooks</a>
                    an, wenn du weitere Beispiele insbesondere auch zum Aktualisieren und L√∂schen sehen willst.
                    <span style="font-weight: bold; color: darkgreen; text-shadow: 1px 1px 1px rgba(0,0,0,0.5);">‚úÖ</span>
                </p>
            </aside>
        </section>

        <section>
            <h1>Sinnvolle Methoden f√ºr die EJBs</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "ejb-methoden-uebersicht-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#ejb-methoden-uebersicht"
                                role          = "tab"
                                aria-controls = "ejb-methoden-uebersicht"
                                aria-expanded = "true"
                            >
                                √úbersicht
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "ejb-methoden-copypaste-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#ejb-methoden-copypaste"
                                role          = "tab"
                                aria-controls = "ejb-methoden-copypaste"
                            >
                                Copy&amp;Paste-Version
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "ejb-methoden-vererbung-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#ejb-methoden-vererbung"
                                role          = "tab"
                                aria-controls = "ejb-methoden-vererbung"
                            >
                                Vererbung und Generics
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- √úbersicht -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "ejb-methoden-uebersicht"
                            role            = "tabpanel"
                            aria-labelledby = "ejb-methoden-uebersicht-tab"
                        >
                            <p>
                                Gute Enterprise Java Beans zu definieren, ist oftmals gar nicht so leicht. F√ºr viele Anwendungen
                                reicht es jedoch, wenn du je Entity eine Bean mit folgenden Methoden anbietest. Dadurch k√∂nnen
                                die Clients ganz einfach Dantes√§tze suchen, anlegen, √§ndern und l√∂schen. Die Typen <code>Entity</code>
                                und <code>EntityId</code> musst du nat√ºrlich durch eigene Klassen ersetzen.
                            </p>

                            <div style="display: flex; justify-content: center;">
                                <ul>
                                    <li>
                                        <src-code language="java">Entity findById(EntityId id)</src-code>
                                    </li>
                                    <li>
                                        <src-code language="java">List&lt;Entity&gt; findByXYZ(‚Ä¶)</src-code>
                                    </li>
                                    <li>
                                        <src-code language="java">List&lt;Entity&gt; findAll()</src-code>
                                    </li>
                                </ul>
                                <ul>
                                    <li>
                                        <src-code language="java">Entity saveNew(Entity entity)</src-code>
                                    </li>
                                    <li>
                                        <src-code language="java">Entity update(Entity entity)</src-code>
                                    </li>
                                    <li>
                                        <src-code language="java">void delete(Entity entity)</src-code>
                                    </li>
                                </ul>
                            </div>

                            <hr />

                            <h4 class="dhbw-lightblue">Vorhandene Datens√§tze finden</h4>
                            <p>
                                <src-code language="java">Entity findById(EntityId id)</src-code>
                                <br />
                                Auslesen eines einzelnen Datensatzes anhand seiner ID
                            </p>
                            <p>
                                <src-code language="java">List&lt;Entity&gt; findByXYZ(‚Ä¶)</src-code>
                                <br />
                                Spezielle Suchmethoden nach Datens√§tzen anhand irgendwelcher Kriterien
                            </p>
                            <p>
                                <src-code language="java">List&lt;Entity&gt; findAll()</src-code>
                                <br />
                                Einache Methode zum Auslesen aller Datens√§tze (nur, wenn es nicht zu viele werden k√∂nnen!)
                            </p>

                            <hr />

                            <h4 class="dhbw-lightblue">Datens√§tze speichern, √§ndern, l√∂schen</h4>
                            <p>
                                <src-code language="java">Entity saveNew(Entity entity)</src-code>
                                <br />
                                Speichern eines komplett neuen Datensatzes, des es zuvor nocht nicht gab
                            </p>
                            <p>
                                <src-code language="java">Entity update(Entity entity)</src-code>
                                <br />
                                √Ñnderungen an einem zuvor ausgelesenen Datensatz speichern
                            </p>
                            <p>
                                <src-code language="java">void delete(Entity entity)</src-code>
                                <br />
                                L√∂schen eines zuvor ausgelesenen Datensatzes
                            </p>

                            <hr />

                            <p>
                                Dar√ºber hinaus kannst du nat√ºrlich noch beliebige, weitere Methoden definieren.
                            </p>
                        </div>
                        <!-- Copy&Paste-Version -->
                        <div
                            class           = "tab-pane fade"
                            id              = "ejb-methoden-copypaste"
                            role            = "tabpanel"
                            aria-labelledby = "ejb-methoden-copypaste-tab"
                        >
                            <p>
                                Das nachfolgende Beispiel zeigt f√ºr jede Methode eine einfache Implementierung.
                            </p>
                            <source-code language="java">
                                @Stateless
                                public class StandortBean {
                                    @PersistenceContext
                                    EntityManager em;

                                    //
                                    // Vorhandene Datens√§tze finden
                                    //
                                    public Standort findById(long id) {
                                        return em.find(Standort.class, id);
                                    }

                                    public List&lt;Standort&gt; findByOrt(String ort) {
                                        return em.createQuery("SELECT s FROM Standort s WHERE s.adresse.ort = :ort")
                                                 .setParameter("ort", ort)
                                                 .getResultList();
                                    }

                                    public List&lt;Standort&gt; findAll() {
                                        return em.createQuery("SELECT s FROM Standort s")
                                                 .getResultList();
                                    }

                                    //
                                    // Datens√§tze speichern, √§ndern, l√∂schen
                                    //
                                    public Standort saveNew(Standort standort) {
                                        em.persist(standort);
                                        return em.merge(standort);
                                    }

                                    public Standort update(Standort standort) {
                                        return em.merge(standort);
                                    }

                                    public void delete(Standort standort) {
                                        em.remove(standort);
                                    }
                                }
                            </source-code>
                        </div>
                        <!-- Vererbung und Generics -->
                        <div
                            class           = "tab-pane fade"
                            id              = "ejb-methoden-vererbung"
                            role            = "tabpanel"
                            aria-labelledby = "ejb-methoden-vererbung-tab"
                        >
                            <p>
                                Ein wenig Zauberei ‚ú® mit Vererbung und Generics k√∂nnen dir helfen, dass du nicht immer und immer
                                wieder dieselben Methoden ausprogrammieren musst. Denn das ganze Lesen, Schreiben und L√∂schen
                                einzelner Entities unterscheidet sich doch im Grunde genommen nur durch den Namen der Entity.
                                So k√∂nnte die Basisklasse daher aussehen:
                            </p>
                            <source-code language="java">
                                /**
                                 * Abstrakte Basisklasse f√ºr EJBs, die einfach nur Standardmethoden zum Lesen
                                 * und Schreiben eines Entity-Typs bietet.
                                 *
                                 * @param &lt;Entity&gt; Basisklasse der Entit√§t
                                 * @param &lt;EntityId&gt; Datentyp oder Klasse f√ºr die Schl√ºsselwerte
                                 */
                                public abstract class EntityBean&lt;Entity, EntityId&gt; {

                                    @PersistenceContext
                                    EntityManager em;

                                    private final Class&lt;Entity&gt; entityClass;

                                    public EntityBean(Class&lt;Entity&gt; entityClass) {
                                        this.entityClass = entityClass;
                                    }

                                    //
                                    // Vorhandene Datens√§tze finden
                                    //
                                    public Entity findById(EntityId id) {
                                        return em.find(entityClass, id);
                                    }

                                    public List&lt;Entity&gt; findAll() {
                                        String select = "SELECT s FROM $C s".replace("$C", this.entityClass.getName());
                                        return em.createQuery(select).getResultList();
                                    }

                                    //
                                    // Datens√§tze speichern, √§ndern, l√∂schen
                                    //
                                    public Entity saveNew(Entity entity) {
                                        em.persist(entity);
                                        return em.merge(entity);
                                    }

                                    public Entity update(Entity entity) {
                                        return em.merge(entity);
                                    }

                                    public void delete(Entity entity) {
                                        em.remove(entity);
                                    }
                                }
                            </source-code>
                            <p>
                                Okay, durch die Generics ist die Klasse nicht ganz so einfach. Eine neue EJB f√ºr eine bestimmte
                                Entity zu definieren, wird damit aber echt zum Kinderspiel. üéé <code>Vorfuehrung</code> ist hier
                                der Name der Entit√§t und <code>Long</code> der Datentyp ihres Prim√§rschl√ºssels.
                            </p>
                            <source-code language="java">
                                @Stateless
                                public class VorfuehrungBean extends EntityBean&lt;Vorfuehrung, Long&gt; {

                                    public VorfuehrungBean() {
                                        super(Vorfuehrung.class);
                                    }

                                    public List&lt;Vorfuehrung&gt; findByWochentag(Wochentag wochentag) {
                                        return em.createQuery("SELECT v FROM Vorfuehrung v WHERE v.wochentag = :wochentag")
                                                 .setParameter("wochentag", wochentag)
                                                 .getResultList();
                                    }

                                    // Alle anderen Methoden sind automatisch vorhanden!
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Enterprise Java Beans beinhalten die fachliche Logik einer Anwendung und stellen den Clients
                    daher Services zur Verf√ºgung, die diese aufrufen k√∂nnen. Diesen Satz haben wir jetzt schon so
                    oft geh√∂hrt. Doch wonach soll man die EJBs unterscheiden und welche Methoden sollen sie
                    besitzen? üòì Das ist gar nicht so leicht zu beantworten, wenn man noch nicht so viel Erfahrung
                    mit Java&nbsp;EE oder √§hnlichen Plattformen hat und ein gutes St√ºck weit l√§sst sich auch gar
                    keine allgemeing√ºltige Antwort auf diese Frage finden. Dennoch hat es sich in der Praxis bew√§hrt,
                    einen gewissen Grundstock an EJBs anzubieten, der sich einfach an den vorhandenen Persistence
                    Entities orientiert.  Die √úberlegung dahinter ist, dass sehr viele Benutzeroberfl√§chen und
                    Clients eigentlich nur folgende Dinge tun:
                </p>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üìÑ
                        </td>
                        <td>
                            Sie zeigen eine Liste aller Datens√§tze an.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üîé
                        </td>
                        <td>
                            Sie erlauben die Suche nach Datens√§tzen anhand einzelner Felder.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üñäÔ∏è
                        </td>
                        <td>
                            Sie besitzen ein Formular zum Anlegen und Bearbeiten von Datens√§tzen.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            üóëÔ∏è
                        </td>
                        <td>
                            Sie l√∂schen einzelne Datens√§tze.
                        </td>
                    </tr>
                </table>
                <p>
                    Also genau die vier CRUD-Operationen aller datenzentrischer Anwendungen: Create, Read, Update
                    und Delete. Wie wir schon gesehen haben, lassen sich diese Operationen danke dem Entity Manager
                    relativ einfach ausprogrammieren. Unser Vorschlag ist daher, zu jeder Persistence Entity eine
                    gleichlautende EJB zu entwickeln, welche die auf der Folie gezeigten Methoden beinhaltet:
                </p>
                <ul>
                    <li>
                        <src-code language="java">Entity findById(EntityId id)</src-code>
                    </li>
                    <li>
                        <src-code language="java">List&lt;Entity&gt; findByXYZ(‚Ä¶)</src-code>
                    </li>
                    <li>
                        <src-code language="java">List&lt;Entity&gt; findAll()</src-code>
                    </li>
                    <li>
                        <src-code language="java">Entity saveNew(Entity entity)</src-code>
                    </li>
                    <li>
                        <src-code language="java">Entity update(Entity entity)</src-code>
                    </li>
                    <li>
                        <src-code language="java">void delete(Entity entity)</src-code>
                    </li>
                </ul>
                <p>
                    Die Folie zeigt dabei zwei M√∂glichkeiten sie auszuprogrammieren. Einmal durch Copy&amp;Paste f√ºr
                    jede einzelne EJB oder mit etwas Zauberei als abstrakte Basisklasse. Letzterer Weg spart nat√ºrlich
                    eine ganze Menge Schreibarbeit.
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 4: Geht eine EJB ins Kino</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "aufgabe4-aufgabe-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#aufgabe4-aufgabe"
                                role          = "tab"
                                aria-controls = "aufgabe4-aufgabe"
                                aria-expanded = "true"
                            >
                                Aufgabe
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe4-loesung1-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe4-loesung1"
                                role          = "tab"
                                aria-controls = "aufgabe4-loesung1"
                            >
                                L√∂sung 1
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe4-loesung2-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe4-loesung2"
                                role          = "tab"
                                aria-controls = "aufgabe4-loesung2"
                            >
                                L√∂sung 2
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Aufgabe -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "aufgabe4-aufgabe"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe4-aufgabe-tab"
                        >
                            <p>
                                Nimm die beiden Entit√§ten <i>Film</i> und <i>Mitwirkender</i> von <a href="#aufgabe2">Aufgabe 2</a>
                                und schreibe je eine Enterprise Java Bean, mit folgenden Methoden.
                            </p>

                            <h4 class="dhbw-lightblue">Klasse FilmBean</h4>
                            <ul>
                                <li>
                                    <src-code language="java">Film findById(long id)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">List&lt;Film&gt; findByJahr(int jahr)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">List&lt;Film&gt; findAll()</src-code>
                                </li>
                                <li>
                                    <src-code language="java">Film saveNew(Film film)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">Film update(Film film)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">void delete(Film film)</src-code>
                                </li>
                            </ul>

                            <h4 class="dhbw-lightblue">Klasse MitwirkenderBean</h4>
                            <ul>
                                <li>
                                    <src-code language="java">Mitwirkender findById(long id)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">List&lt;Mitwirkender&gt; findAll()</src-code>
                                </li>
                                <li>
                                    <src-code language="java">Mitwirkender saveNew(Mitwirkender mitwirkender)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">Mitwirkender update(Mitwirkender mitwirkender)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">void delete(Mitwirkender mitwirkender)</src-code>
                                </li>
                            </ul>

                            <p>
                                Programmiere die beiden Klassen erst komplett von Hand aus, bevor du eine zweite Version auf
                                Grundlage der eben gezeigten, abstrakten <a href="#19">EntityBean</a> schreibst.
                            </p>
                        </div>
                        <!-- L√∂sung 1 -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe4-loesung1"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe4-loesung1-tab"
                        >
                            <p>
                                Hier die Musterl√∂sung f√ºr die Version mit Copy&amp;Paste.
                            </p>
                            <source-code language="java">
                                @Stateless
                                public class FilmBean {
                                    @PersistenceContext
                                    EntityManager em;

                                    //
                                    // Vorhandene Datens√§tze finden
                                    //
                                    public Standort findById(long id) {
                                        return em.find(Film.class, id);
                                    }

                                    public List&lt;Film&gt; findByJahr(int jahr) {
                                        return em.createQuery("SELECT f FROM Film f WHERE f.jahr = :jahr")
                                                 .setParameter("jahr", jahr)
                                                 .getResultList();
                                    }

                                    public List&lt;Film&gt; findAll() {
                                        return em.createQuery("SELECT f FROM Film f")
                                                 .getResultList();
                                    }

                                    //
                                    // Datens√§tze speichern, √§ndern, l√∂schen
                                    //
                                    public Film saveNew(Film film) {
                                        em.persist(film);
                                        return em.merge(film);
                                    }

                                    public Film update(Film film) {
                                        return em.merge(film);
                                    }

                                    public void delete(Film film) {
                                        em.remove(film);
                                    }
                                }

                                @Stateless
                                public class MitwirkenderBean {
                                    @PersistenceContext
                                    EntityManager em;

                                    //
                                    // Vorhandene Datens√§tze finden
                                    //
                                    public Mitwirkender findById(long id) {
                                        return em.find(Mitwirkender.class, id);
                                    }

                                    public List&lt;Mitwirkender&gt; findAll() {
                                        return em.createQuery("SELECT m FROM Mitwirkender m")
                                                 .getResultList();
                                    }

                                    //
                                    // Datens√§tze speichern, √§ndern, l√∂schen
                                    //
                                    public Mitwirkender saveNew(Mitwirkender mitwirkender) {
                                        em.persist(mitwirkender);
                                        return em.merge(mitwirkender);
                                    }

                                    public Mitwirkender update(Mitwirkender mitwirkender) {
                                        return em.merge(mitwirkender);
                                    }

                                    public void delete(Mitwirkender mitwirkender) {
                                        em.remove(mitwirkender);
                                    }
                                }
                            </source-code>
                        </div>
                        <!-- L√∂sung 2 -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe4-loesung2"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe4-loesung2-tab"
                        >
                            <p>
                                Und hier die vereinfachte Version auf Basis unserer selbst-entworfenen <a href="#19">EntityBean</a>.
                            </p>
                            <source-code language="java">
                                @Stateless
                                public class FilmBean extends EntityBean&lt;Film, Long&gt; {
                                    @PersistenceContext
                                    EntityManager em;

                                    public FilmBean {
                                        super(Film.class);
                                    }

                                    public List&lt;Film&gt; findByJahr(int jahr) {
                                        return em.createQuery("SELECT f FROM Film f WHERE f.jahr = :jahr")
                                                 .setParameter("jahr", jahr)
                                                 .getResultList();
                                    }
                                }

                                @Stateless
                                public class MitwirkenderBean extends EntityBean&lt;Mitwirkender, Long&gt; {

                                    public MitwirkenderBean {
                                        super(Mitwirkender.class);
                                    }
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Hier kannst du das eben gelernte gleich praktisch Anwenden, indem du ein paar Enterprise
                    Java Beans zum Lesen und Schreiben von Datens√§tzen definierst. Gerne in Netbeans, wenn du
                    willst aber auch gerne einfach auf Papier. üìÉ
                </p>
                <img src="../../github_atom.png" class="img-fluid d-block"/>
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://atom.io/" target="_blank">Atom Webseite</a>
                    </small>
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 5: Ein kleines Entity-Manager-Quiz</h1>
            <article>
                <p>
                    a) Was ist eine Persistence Unit?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Ein alter Name f√ºr Persistence Entities
                    </li>
                    <li>
                        Eine Ma√üeinheit f√ºr die Dauer der Speicherung
                    </li>
                    <li>
                        Eine Konfiguration der zu nutzenden Datenbank
                    </li>
                </ol>

                <p>
                    b) Wie kannst du eine Referenz auf den Entity Manager bekommen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <source-code language="java">
                            @EntityManager
                            PersistenceContext pc;
                        </source-code>
                    </li>
                    <li>
                        <source-code language="java">
                            @PersistenceContext
                            EntityManager em;
                        </source-code>
                    </li>
                    <li>
                        <source-code language="java">
                            @DataSource("jdbc/__default")
                            @EntityManager em;
                        </source-code>
                    </li>
                    <li>
                        <source-code language="java">
                            @PersistenceUnit
                            ObjectMapper om;
                        </source-code>
                    </li>
                </ol>

                <p>
                    c) Welche der folgenden Methoden bietet der Entity Manager f√ºr die √ºblichen CRUD-Operationen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        find(), persist(), update(), delete()
                    </li>
                    <li>
                        find(), persist(), merge(), remove()
                    </li>
                    <li>
                        select(), exist(), update(), delete()
                    </li>
                    <li>
                        find(), persist(), search(), complete()
                    </li>
                </ol>

                <p>
                    d) Welche Vorteile hat die Java Persistence Query Language gegen√ºber SQL?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Keine, da JQL nur eine spezieller SQL-Dialekt ist.
                    </li>
                    <li>
                        Die Selektionen laufen schneller als mit nativem SQL.
                    </li>
                    <li>
                        Es bietet eine √ºber alle Datenbankhersteller einheitliche Syntax.
                    </li>
                </ol>

                <p>
                    e) Und welche Nachteile hat die Java Persistence Query Language gegen√ºber SQL?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Es ist nicht ganz so schnellt wie natives SQL.
                    </li>
                    <li>
                        Es gibt kein <code>UPDATE</code> und <code>DELETE</code>.
                    </li>
                    <li>
                        Es funktioniert nicht mit jeder Datenbank.
                    </li>
                </ol>

                <p>
                    f) Welches ist keine g√ºltige JQL-Anfrage?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <source-code language="sql">
                            SELECT * FROM Film f
                                WHERE f.name LIKE ?
                                  AND f.jahr BETWEEN ? AND ?
                        </source-code>
                    </li>
                    <li>
                        <source-code language="sql">
                            SELECT f FROM Film f
                                WHERE f.genre = :genre
                                  AND f.vorfuehrung.wochentag = :wochentag
                        </source-code>
                    </li>
                </ol>

                <p>
                    g) Welche der folgenden Methoden sollte die EJB zu einer Entity mindestens besitzen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <src-code language="java">Entity findById(EntityId id)</src-code>
                    </li>
                    <li>
                        <src-code language="java">List&lt;Entity&gt; findByXYZ(‚Ä¶)</src-code>
                    </li>
                    <li>
                        <src-code language="java">List&lt;Entity&gt; findAll()</src-code>
                    </li>
                    <li>
                        <src-code language="java">Entity saveNew(Entity entity)</src-code>
                    </li>
                    <li>
                        <src-code language="java">Entity update(Entity entity)</src-code>
                    </li>
                    <li>
                        <src-code language="java">void delete(Entity entity)</src-code>
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>L√∂sung:</b> 3, 2, 2, 3, 1, 1, alle bis auf 2 und 3
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Puh, endlich geschafft! üå¨Ô∏è Letzte Folie, oder so. Wie immer zum Abschluss einer Einheit gibt
                    es hier ein paar Wiederholungsfragen f√ºr dich.
                </p>
            </aside>
        </section>

        <!--
            ====================
            HINWEISE ZUM SCHLUSS
            ====================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Hinweise zum Schluss</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section data-background-color="rgb(153, 190, 137)">
            <h1>Do &amp; Don't</h1>
            <article>
                <h4>Erstellung des Datenmodells</h4>
                <ul>
                    <li>
                        Nutze E/R-Diagramme und andere Techniken zur Modellierung des Datenmodells.
                    </li>
                    <li>
                        Achte darauf, das Datenmodell zu normalisieren und Redundanzen zu vermeiden.
                    </li>
                    <li>
                        Gestalte das Datenmodell so einfach wie m√∂glich, so komplex wie n√∂tig.
                    </li>
                    <li>
                        Bilde Fremdschl√ºssel immer als Objektreferenz in Java ab.
                    </li>
                    <li>
                        Vermeide bidirektionale Beziehungen, wenn du sie nicht wirklich brauchst.
                    </li>
                    <li>
                        Nutze Lzay Loading f√ºr Beziehungen, wenn ihre Daten nicht bei jedem Aufruf ben√∂tigt werden.
                    </li>
                    <li>
                        Mache regen Gebrauch von <code>@Column</code> zur Spezifizierung der Tabellenfelder.
                    </li>
                    <li>
                        Versuche <code>@Lob</code>-Felder immer zu vermeiden, wenn du sie nicht brauchst.
                    </li>
                    <li>
                        Definiere Indizies f√ºr sehr h√§ufg gebrauchte Selektionen.
                    </li>
                    <li>
                        Lege komplexe oder an mehreren Stellen ben√∂tigte Selektionen in der Entityklasse als <code>@NamedQuery</code> an.
                    </li>
                    <li>
                        Belege alle Attribute mit einem sinnvollen Startwert vor.
                    </li>
                    <li>
                        Vermeide es, Tabellenfelder mit <b>nullable=True</b> zu definieren.
                    </li>
                    <li>
                        Spendiere jeder Persistence Entity mehrere Konstruktoren, um ihre Benutzung zu vereinfachen.
                    </li>
                    <li>
                        √úbergabe die Id nicht an den Konstruktor, wenn sie automatisch generiert werden soll.
                    </li>
                </ul>

                <h4>Konfiguration des O/R-Mappers</h4>
                <ul>
                    <li>
                        √úberlege dir, die Tabellen im Produktivbetrieb von Hand anzulegen, um sie zu optimieren.
                    </li>
                    <li>
                        Auf jeden Fall achte darauf, die richtige <b>Table Generation Strategy</b> zu w√§hlen.
                    </li>
                    <li>
                        Nutze <code>@Table</code> und <code>@Column</code>, um die Namen von Tabellen und Feldern anzupassen.
                    </li>
                </ul>

                <h4>Nutzung der Persistence Entities</h4>
                <ul>
                    <li>
                        Definiere gute Enterprise Java Beans zur Verwendung der Persistence Entities.
                    </li>
                    <li>
                        Lagere sich h√§ufig wiederholenden Code in einer allgemeinen Basisklasse aus.
                    </li>
                    <li>
                        Nutze immer <code>addParameter()</code>, um Feldwerte in eine <code>WHERE</code>-Bedingung einzubauen.
                    </li>
                    <li>
                        Biete spezielle Suchmethoden f√ºr h√§ufiger ben√∂tigte Selektionen.
                    </li>
                    <li>
                        √úberlege dir, die maximale Anzahl r√ºckgegebener S√§tze zu begrenzen und die S√§tze vorzusortieren.
                    </li>
                    <li>
                        Programmiere besonders performancekritische Sachen mit Native SQL.
                    </li>
                    <li>
                        Biete gleichzeitig aber immer auch eine JQL-Version f√ºr nicht-kompatible Datenbanken.
                    </li>
                </ul>
            </article>
            <aside>
                <p>
                    Dies sind sie: Die zehn Gebote. üìÑ Auf dieser Folie haben wir ein paar allgemeine Tipps
                    zusammengestellt, worauf du bei bei der Programmierung mit der Java Persistence API
                    achten solltest.
                </p>
                <img src="../../do-dont.svg" class="d-block" style="width: 20em; max-width: 100%; margin-bottom: 0.5em;" />
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/dialog-tip-advice-hint-speaking-148815/" target="_blank" style="color: rgb(25, 68, 49);">Pixabay: OpenClipart-Vectors</a>
                    </small>
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(158, 203, 231)">
            <h1>Rechtshinweise</h1>
            <article>
                <h4>Creative Commons Namensnennung 4.0 International</h4>
                <ul>
                    <li>Beliebiges Teilen ist erlaubt</li>
                    <li>Die Unterlagen d√ºrfen bearbeitet und ver√§ndert werden</li>
                    <li>Wenn die Namens- und Urheberangaben erhalten bleiben</li>
                    <li>Und keine weiteren Einschr√§nkungen auferlegt werden</li>
                </ul>
                <span style="font-size: 400px; color: white;" class="dhbw-text-shadow" >¬ß</span>
            </article>
            <aside style="font-size: 80%">
                <h4>Kontaktdaten</h4>
                <p>
                    Dennis Schulmeister-Zimolong<br/>
                    E-Mail: <a data-email-address>dhbw windows3.de</a><br/>
                </p>

                <h4>Urheberrecht und Lizenzvereinbarung</h4>
                <p>
                    ¬© 2018 Dennis Schulmeister-Zimolong <br/>
                    <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-folien" target="_blank">https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-folien</a>
                </p>
                <img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Lizenzvertrag" />
                <p>
                    Das Werk <i>Vorlesung "Verteilte Systeme" im Studiengang Wirtschaftsinformatik
                    an der DHBW Karlsruhe</i> von <a href="http://www.windows3.de" target="_blank">Dennis Schulmeister-Zimolong</a>
                    ist lizenziert unter <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank"><i>Creative Commons
                    Namensnennung 4.0 International</i></a>.
                </p>
                <p>
                    Du darfst:
                </p>
                <ul>
                    <li>
                        <b>Teilen</b> ‚Äî das Material in jedwedem Format oder Medium vervielf√§ltigen
                        und weiterverbreiten
                    </li>
                    <li>
                        <b>Bearbeiten</b> ‚Äî das Material remixen, ver√§ndern und darauf aufbauen
                        und zwar f√ºr beliebige Zwecke, sogar kommerziell.
                    </li>
                </ul>
                <p>
                    Unter folgenden Bedingungen:
                </p>
                <ul>
                    <li>
                        <b>Namensnennung</b> ‚Äî Du musst angemessene Urheber- und Rechteangaben
                        machen, einen Link zur Lizenz beif√ºgen und angeben, ob √Ñnderungen
                        vorgenommen wurden. Diese Angaben d√ºrfen in jeder angemessenen Art
                        und Weise gemacht werden, allerdings nicht so, dass der Eindruck
                        entsteht, der Lizenzgeber unterst√ºtze gerade dich oder deine Nutzung
                        besonders.
                    </li>
                    <li>
                        <b>Keine weiteren Einschr√§nkungen</b> ‚Äî Du darfst keine zus√§tzlichen Klauseln
                        oder technische Verfahren einsetzen, die anderen rechtlich irgendetwas
                        untersagen, was die Lizenz erlaubt.
                    </li>
                </ul>
                <p>
                    Es werden keine Garantien gegeben und auch keine Gew√§hr geleistet.
                    Die Lizenz verschafft dir m√∂glicherweise nicht alle Erlaubnisse,
                    die du f√ºr die jeweilige Nutzung brauchst. Es k√∂nnen beispielsweise
                    andere Rechte wie Pers√∂nlichkeits- und Datenschutzrechte zu beachten
                    sein, die deine Nutzung des Materials entsprechend beschr√§nken.
                </p>
            </aside>
        </section>
    </body>
</html>
