<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Java Persistence API</title>

        <link rel="shortcut icon" href="../../favicon.svg" />
        <link rel="stylesheet" href="../../style.css" />
        <script src="../../learning-slides.bundle.js"></script>
    </head>
    <body class="slides invisible" data-title="Java Persistence API" tabindex="0">
        <header>
            <h2>Inhaltsverzeichnis</h2>
            <p>
                Das klappt ja schon ganz gut mit Java&nbsp;EE und MVC, wir haben sogar schon
                eigene Webseiten mit Datenbank im Hintergrund geschrieben. Die schönsten Sachen
                haben wir aber noch gar nicht gesehen. Hier lernst du nun, deine eigenen
                Persistence Entities  und Enterprise Java Beans zu schreiben. 🖋️
            </p>
        </header>

        <!--
            ========================
            LERNZIELE DIESER EINHEIT
            ========================
        -->
        <section data-chapter data-background-color="rgb(210,190,210)">
            <h1>Lernziele dieser Einheit</h1>
            <article>
                <h3>Nach Abschluss dieser Einheit kannst du …</h3>
                <ul>
                    <li>
                        erklären, welche <span class="dhbw-lightblue font-weight-bold">Klassenbibliotheken für den Datenbankzugriff</span> Java bietet.
                    </li>
                    <li>
                        erklären, was ein <span class="dhbw-lightblue font-weight-bold">O/R-Mapper</span> ist und welche Vor- und Nachteile er hat.
                    </li>
                    <li>
                        alle Schritte zur Entwicklung einer neuen Anwendung beschreiben.
                    </li>
                    <li>
                        die <span class="dhbw-lightblue font-weight-bold">Datenbankwerkzeuge von Netbeans</span> bedienen.
                    </li>
                    <li>
                        eigene <span class="dhbw-lightblue font-weight-bold">Entity-Klassen</span> entwerfen und ausprogrammieren.
                    </li>
                    <li>
                        einfache und zusammengesetzte <span class="dhbw-lightblue font-weight-bold">Schlüsselfelder</span> definieren.
                    </li>
                    <li>
                        die <span class="dhbw-lightblue font-weight-bold">Tabellen- und Feldeigenschaften</span> einer Persistence Entity festlegen.
                    </li>
                    <li>
                        <span class="dhbw-lightblue font-weight-bold">Fremdschlüsselbeziehungen</span> zwischen zwei Entities sauber abbilden.
                    </li>
                    <li>
                        beschreiben, was eine <span class="dhbw-lightblue font-weight-bold">Persistence Unit</span> ist und wofür wie sie benötigen.
                    </li>
                    <li>
                        den <span class="dhbw-lightblue font-weight-bold">Entity Manager</span> zum lesen, schreiben und löschen von Daten benutzen.
                    </li>
                    <li>
                        komplexe <span class="dhbw-lightblue font-weight-bold">Datenabfragen mit JQL</span> fomulieren.
                    </li>
                    <li>
                        <span class="dhbw-lightblue font-weight-bold">datenorientierte Services</span> mit Enterprise Java Beans ausprogrammieren.
                    </li>
                </ul>
                <span style="font-size: 240px; color: white;" class="dhbw-text-shadow" >🏁</span>
            </article>
            <aside>
                <p>
                    Die heutige Einheit steh ganz im Zeichen der Datenbank und beendet damit den Zyklus zur serverseitigen
                    Webentwicklung. Denn nachdem du nun die Java Enterprise Edition kennengelernt hast, die serverseitige
                    Erzeugung von HTML-Code mit Servlets und JSP verstehst, eigene Enterprise Java Beans programmieren und
                    das alles zu einer übersichtlichen MVC-Architektur verknüpfen kannst, fehlt dir nur noch eins: Das
                    Datenmodell deiner Anwendung auf Basis einer relationalen Datenbank. 🛢
                </p>
                <p>
                    Die Programmierung ist dabei gar nicht mal so schwer, ja eigentlich sogar ziemlich einfach 👍🏻, so dass
                    die Java Enterprise Edition ihrem Namen hier alle Ehre macht. Sind die Daten eines Unternehmens doch sein
                    Ein und Alles und liegt auch so einfach viel zu vielen Webanwendungen einer Datenbank zugrunde. Am Anfang
                    werden wir uns daher ein wenig mit den Konzepten beschäftigen, welche Möglichkeiten Java&nbsp;EE uns bietet
                    (Stichwort „O/R-Mapping”) und wie Netbeans uns dabei unterstützt. Danach tauchen wir dann auch schon direkt
                    in den Quellcode ein und definieren unsere eigenen Persistence Entities. Zunächst nur ganz einfache mit
                    einer fortlaufenden ID als Schlüsselwert und ein paar einfachen Feldern und gleich danach komplexere Entities
                    mit zusammengesetzten Schlüsseln und Fremdschlüsselbeziehungen.
                </p>
                <p>
                    Danach wenden wir uns dann die Verwendung der Persistence Entities zu und lernen, was der Entity Manager
                    ist, wie wir an ihn herankommen und welche Methoden er zum lesen, schreiben und löschen von Daten bietet.
                    Dabei schauen wir uns dann auch die Java Query Language an, mit der wir komplexe Suchanfragen in einer
                    SQL-ähnlichen Sprache an jede beliebige Datenbank schicken können. Das alles mündet dann in einer Empfehlung
                    zur Implementierung von Java Enterprise Beans, so dass du deinen Clients eine konsistente und dennoch
                    leistungsfähige Schnittstelle zur Nutzung des Datenmodells anbieten kannst.
                </p>
                <p>
                    Das ist unser Fahrplan 🚂🚞🚞🚞 für heute und wir wünschen dir jetzt schon viel Spaß!
                </p>
            </aside>
        </section>

        <!--
            ==================================
            ALLGEMEINES ZU DATENBANKEN IN JAVA
            ==================================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Allgemeines zu Datenbanken in Java</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Wie Java mit der Datenbank spricht</h1>
            <article>
                <img src="or-mapping.svg" alt="O/R-Mapping in Java" class="d-block" style="width: 100%; margin-bottom: 1em;" />
                <table>
                    <tr>
                        <td style="padding-right: 0.5em">
                            🛢️
                        </td>
                        <td>
                            <b>JDBC:</b> Allgemeine API für den Zugriff auf relationale Datenbanken
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em">
                            🛢️
                        </td>
                        <td>
                            <b>JPA:</b> Auf JDBC aufbauende API für O/R-Mapper, die Javaobjekte in Tabelleneinträge und umgekehrt umwandeln
                        </td>
                    </tr>
                </table>
            </article>
            <aside>
                <p>
                    Die Java Enterprise Edition kennt zwei Klassenbibliotheken für den Datenbankzugriff: JDBC und JPA. JDBC steht dabei
                    für <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/" target="_blank">Java Database Connection</a>
                    und ist eine allgemeine API, mit der SQL-Befehle an eine Datenbank gesendet werden können. Es handelt sich dabei um die
                    zugrunde liegende Schnittstelle, die immer genutzt wird, wenn auf eine Datenbank zugegriffen wird. Jedoch ist die
                    Programmierung nicht ganz einfach, wie das folgende Beispiel zeigt:
                </p>
                <source-code language="java">
                    @Stateless
                    public class VielZuKompliziert {
                        @Resource(mappedName="jdbc__/default")
                        DataSource dataSource;

                        public Buch findBuchByIsbn(String isbn)
                        throws SQLException {
                            try (Connection con = dataSource.getConnection()) {
                                String select = "SELECT * FROM Buch WHERE isbn = ?";
                                PrepatedStatement statement = con.prepareStatement(select);
                                statement.setString(1, isbn);

                                ResultSet result = statement.executeQuery();
                                Buch buch = new Buch();

                                while (result.next()) {
                                    Buch.setIsbn(result.getString("isbn"));
                                    Buch.setTitel(result.getString("titel"));
                                    break;
                                }

                                result.close();
                                statement.close();

                                return buch;
                            }
                        }

                        // Weitere Methoden …
                    }
                </source-code>
                <p>
                    Ui, schrecklich! 👹 Bitte nicht! Das ist ja mega aufwändig! Und fehleranfällig! Und sonst noch was!
                    Vor Java&nbsp;EE&nbsp;5 im Jahr 2006 war das tatsächlich die einzige offizielle API, um auf eine
                    Datenbank zuzugreifen. Doch schon damals war das nicht wirklich schön, so dass sogleich alternative
                    APIs wie <a href="http://hibernate.org/" target="_blank">Hibernate</a> entstanden, die wesentlich
                    einfacher zu nutzen waren. Wir wollen das Ganze daher schnell wieder vergessen. Einzig, dass im
                    Hintergrund immer noch JDBC werkelt, wenn wir mit der Datenbank reden, ist noch ganz interessant
                    zu wissen.¹
                </p>
                <p>
                    <small>
                        ¹ Tatsächlich sieht die native API vieler Datenbanken für irgend eine Programmiersprache oftmals
                        relativ ähnlich aus. Dies ist einer der Gründe, warum man als Anwendungsentwickler die nativen
                        APIs niemals direkt verwenden sollte.
                    </small>
                </p>
                <p>
                    Viel angenehmer ist da JPA, was für <b>Java Persistence API</b> steht. Dabei handelt es sich um eine
                    Klassenbibliothek, die zur Nutzung eines sogenannten O/R-Mappers dient, der zwischen den relationalen
                    Welt der Datenbank und der objektorientierten Welt von Java vermittelt. Dadurch wird es möglich,
                    Code wie folgenden zu schreiben:
                </p>
                <source-code language="java">
                    @Statelss
                    public class GanzEinfach {
                        @PersistenceContext
                        EntityManager em;

                        public Buch findBuchByIsbn(String isbn) {
                            return em.find(Buch.class, isbn);
                        }

                        public void saveNewBuch(Buch buch) {
                            em.persist(buch);
                        }

                        // Weitere Methoden …
                    }
                </source-code>
                <p>
                    Hm, das sieht schon viel besser aus. Fast zu einfach. 😌 Doch ja, es ist wirklich so. Die Grundidee
                    ist schlicht, dass es zu jeder Tabelle eine Javaklasse gibt, deren Objekte den Zeilen der Tabelle
                    entsprechen. Wollen wir eine Zeile auslesen, erzeugt der O/R-Mapper automatisch ein solches Objekt
                    und übergibt ihm die Werte aus der Datenbank. Soll stattdessen ein neuer Datensatz geschrieben werden,
                    erzeugen wir das Objekt einfach selbst und übergeben es dem O/R-Mapper. Die ganzen hässlichen Einzelheiten,
                    wie wir sie oben gesehen haben, brauchen wir dabei nicht beachten.Das macht der O/R-Mapper für uns.
                    Wir müssen lediglich eine Bean² mit den richtigen Feldern bereitstellen:
                </p>
                <p>
                    <small>
                        ² Eine Javaklasse, die für jedes Feld eine Set- und eine Get-Methode besitzt.
                    </small>
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        @Id
                        private String isbn;

                        private String titel;
                        private String untertitel;

                        // Setter und Getter …
                    }
                </source-code>
                <p>
                    Das ist alles, was der O/R-Mapper braucht. Einfache Methoden wie <src-code language="java">em.find()</src-code> oder
                    <src-code language="java">em.persist()</src-code> dienen dann dem Lesen und Schreiben von Datensätzen.
                </p>
            </aside>
        </section>

        <section>
            <h1>Von der Idee zur fertigen Anwendung</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "vorgehen-uebersicht-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#vorgehen-uebersicht"
                                role          = "tab"
                                aria-controls = "vorgehen-uebersicht"
                                aria-expanded = "true"
                            >
                                Übersicht
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vorgehen-datenmodell-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vorgehen-datenmodell"
                                role          = "tab"
                                aria-controls = "vorgehen-datenmodell"
                            >
                                Datenmodell
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vorgehen-services-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vorgehen-services"
                                role          = "tab"
                                aria-controls = "vorgehen-services"
                            >
                                Services
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vorgehen-benutzeroberflaeche-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vorgehen-benutzeroberflaeche"
                                role          = "tab"
                                aria-controls = "vorgehen-benutzeroberflaeche"
                            >
                                Benutzeroberfläche
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Übersicht -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "vorgehen-uebersicht"
                            role            = "tabpanel"
                            aria-labelledby = "vorgehen-uebersicht-tab"
                        >
                            <p>
                                Die untenstehende Zeichnung zeigt die wesentlichen Schritte, die bei der Entwicklung einer Java-EE-Anwendung anfallen.
                                Die wichtigsten davon schauen wir uns anhand eines kleinen Fallbeispiels auf den folgenden Reitern etwas genauer an.
                            </p>
                            <img src="vorgehen-uebersicht.svg" alt="Schritte während der Entwicklung" class="d-block" style="width: 100%;" />
                        </div>
                        <!-- Datenmodell -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vorgehen-datenmodell"
                            role            = "tabpanel"
                            aria-labelledby = "vorgehen-datenmodell-tab"
                        >
                            <p>
                                Zunächst brauchen wir ein gutes Datenmodell, das nicht zu kompliziert aber dennoch flexibel ist. Unsere kleine Anwendung modelliert
                                eine Buchsammlung. Wir haben daher Entitäten wie <span class="dhbw-lightblue">Buch</span>, <span class="dhbw-lightblue">Autor</span>
                                oder <span class="dhbw-lightblue">Verlag</span>, die in Beziehung zueinander stehen. Zusätzlich hat jeder Autor und jeder Verlag eine
                                <span class="dhbw-lightblue">Adresse</span>.
                            </p>
                            <img
                                src   = "vorgehen-datenmodell.svg"
                                alt   = "Datenmodell mit den Entitäten Buch, Autor, Verlag und Adresse"
                                class = "d-block"
                                style = "width: 35em; max-width: 100%; margin: 0 auto; margin-top: 1em; margin-bottom: 1em;"
                            />
                            <p>
                                In Javacode sieht das ganze ungefähr so aus. Die Details dazu schauen wir uns natürlich noch an.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch implements Serializable {
                                    @Id
                                    private String isbn = "";

                                    private String titel = "";
                                    private String untertitel = "";
                                    private BuchKategorie kategorie = BuchKategorie.UNBEKANNT;
                                    private int anzahlSeiten = 0;

                                    @ManyToMany
                                    List&lt;Autor&gt; autoren = new ArrayList&lt;&gt;();

                                    @ManyToOne
                                    private Verlag verlag = null;

                                    // Setter und Getter …
                                }

                                public enum BuchKategorie {
                                    UNBEKANNT, BELLETRISTIK, FACHBUCH, SAMMELBAND, ZEITSCHRIFT;
                                }

                                @Entity
                                public class Autor implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id;

                                    private String vorname;
                                    private String nachname;
                                    private String titel;

                                    @OneToOne
                                    Adresse adresse = null;

                                    @ManyToMany(mappedBy="autoren")
                                    List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();

                                    // Setter und Getter …
                                }

                                @Entity
                                public class Verlag implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id;

                                    private String name;
                                    private String rechtsform;

                                    @OneToOne
                                    Adresse adresse = null;

                                    @OneToMany(mappedBy="verlag")
                                    List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();

                                    // Setter und Getter …
                                }

                                @Entity
                                public class Adresse implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id;

                                    private String strasse = "";
                                    private String hausnummer = "";
                                    private String postleitzahl = "";
                                    private String ort = "";
                                    private String land = "";

                                    // Setter und Getter …
                                }
                            </source-code>
                        </div>
                        <!-- Services -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vorgehen-services"
                            role            = "tabpanel"
                            aria-labelledby = "vorgehen-services-tab"
                        >
                            <p>
                                Darauf aufbauend können wir nun Services definieren, die sinnvolle Funktionen rund um die Entitäten zur Verfügung stellen.
                                Im einfachsten Fall bieten wir hierfür die üblichen CRUD-Operationen: <span class="dhbw-lightblue">Create</span>,
                                <span class="dhbw-lightblue">Read</span>, <span class="dhbw-lightblue">Update</span> und <span class="dhbw-lightblue">Delete</span>.
                            </p>

                            <img
                                src   = "vorgehen-services.svg"
                                alt   = "Klassendiagramm der Klassen BuchService, AutorService, VerlagService"
                                class = "d-block"
                                style = "width: 42em; max-width: 100%; margin: 0 auto; margin-top: 1em; margin-bottom: 1em;"
                            />

                            <source-code language="java">
                                @Stateless
                                public class BuchService {
                                    @PersistenceContext
                                    EntityManager em;

                                    // Bücher selektieren
                                    public Buch findByIsbn(String isbn) { … }
                                    public List&lt;Buch&gt; findByAutor(Autor autor) { … }
                                    public List&lt;Buch&gt; findByVerlag(Verlag verlag) { … }
                                    public List&lt;Buch&gt; findByTitleContains(String title) { … }

                                    // Neue Bücher speichern
                                    public Buch saveNew(Buch buch) { … }

                                    // Bücher Verlage ändern
                                    public Buch update(Buch buch) { … }
                                    public void delete(Buch buch) { … }
                                }

                                @Stateless
                                public class VerlagService {
                                    …
                                }

                                @Stateless
                                public class AutorService {
                                    …
                                }
                            </source-code>
                        </div>
                        <!-- Benutzeroberfläche -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vorgehen-benutzeroberflaeche"
                            role            = "tabpanel"
                            aria-labelledby = "vorgehen-benutzeroberflaeche-tab"
                        >
                            <p>
                                Und last but not least eine schöne Benutzeroberfläche, entweder als serverseitige MVC-Webanwendung,
                                als clientseitige Webanwendung oder als Native Client. Oder jede beliebige Kombination daraus,
                                ganz wie du willst.
                            </p>
                            <img
                                src   = "vorgehen-ui.png"
                                alt   = "Benutzeroberflächen für Smartphone, Tablet, Desktop und Notebook"
                                class = "d-block"
                                style = "width: 100%; margin-top: 1em;"
                            />

                            <source-code language="java">
                                @WebServlet(urlPatterns={"/start/"})
                                public class StartPageServlet extends HttpServlet {
                                    @EJB
                                    BuchService buchService;

                                    @EJB
                                    AutorService autorService;

                                    @EJB
                                    VerlagService verlagService;

                                    @Override
                                    public void doGet(HttpServletRequest request, HttpServletResponse)
                                    throws ServletException, IOException {
                                        …
                                    }
                                }
                            </source-code>

                            <p>
                                <small>
                                    <small>
                                        Bildnachweise:
                                        <a href="https://pixabay.com/de/imac-ipad-iphone-macbook-laptop-1999636/" target="_blank">Pixabay: Nick_H</a>,
                                        <a href="https://pixabay.com/de/buch-rack-regal-m%C3%B6bel-design-holz-2943383/" target="_blank">Pixabay: JuralMin</a>
                                    </small>
                                </small>
                            </p>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Ordnung ist das halbe Leben. Was im Alltag gilt, gilt natürlich auch bei der Entwicklung großer Anwendungen,
                    wie sie bei Java&nbsp;EE häufig vorkommen. Bevor du also einfach so drauf los programmierst, solltest du eine
                    möglichst genaue Vorstellung davon haben, was für eine Anwendung du schreiben willst, wie der Quellcode aufgebaut
                    sein muss und wie du hierfür am besten vorgehst. Kurz um: Du brauchst einen Plan, damit du dich nicht in eine Ecke
                    programmierst, aus der du nur schwer wieder herauskommst: 🙃
                </p>
                <a href="https://xkcd.com/1513/" target="_blank">
                    <img src="https://imgs.xkcd.com/comics/code_quality.png" class="d-block" style="width: 100%;" />
                </a>
                <p>
                    <small>
                        I honestly didn't think you could even USE emoji in variable names. <br />
                        Or that there were so many different crying ones. <br />
                        Bildnachweis: <a href="https://xkcd.com/1513/" target="_blank">Randall Munroe, xkcd 1513</a>
                    </small>
                </p>
                <p>
                    Das Gute daran ist, dass das gar nicht so schwer ist, wie du jetzt vielleicht denken magst. Denn immerhin gibt es
                    die Java Enterprise Edition nun schon so lange, dass reichlich viel Erfahrung in ihre Entwicklung geflossen ist.
                    Ein klein wenig strukturiertes Vorgehen gepaart mit ein paar einfachen Regeln und hier und da bewährten Techniken
                    aus dem Software-Engingeering-Fundus und schon ergibt der Rest fast von alleine. 🦋
                </p>
                <p>
                    Anfangen solltest du daher immer mit dem Datenmodell, denn es ist das Fundament, auf dem alles andere aufbaut. Bevor
                    du also auch nur daran denkst, die IDE zu starten, solltest du erst das Datenmodell definieren und so genau wie möglich
                    beschreiben. <a href="https://de.wikipedia.org/wiki/Entity-Relationship-Modell" target="_blank">ER-Diagramme</a> können
                    dabei eine große Hilfe sein, aber natürlich tut es auch jede andere Darstellungsform. Wichtig ist nur, dass alle Tabellen
                    mit allen Feldern gut durchdacht sind, es keine Redundanzen gibt und das Datenmodell nicht komplexer als unbedingt nötig
                    ist. Reicht zum Beispiel ein Feld für die Telefonnummer oder muss sie in ihre einzelnen Bestandteile¹ zerlegt werden?
                    Hat eine Firma nur eine Adresse oder müssen auch ihre Niederlassungen abgespeichert werden? Reicht dabei die aktuelle
                    Adresse oder werden auch historische Adressen benötigt? Solche Fragen musst du dir stellen und beantworten, bevor zu
                    programmieren anfängst.
                </p>
                <p>
                    <small>
                        ¹ Ländervorwahl, Ortsvorwahl, Anschlussnummer, Durchwahl
                    </small>
                </p>
                <p>
                    Als nächstes gilt es dann, das Datenmodell im Quellcode abzubilden, also <b>Persistence Entities</b> zu schreiben,
                    wobei du dir aussuchen kannst, ob du erst die Klassen schreibst und daraus dann Tabellen generieren lässt, oder
                    ob du erst die Tabellen anlegst und daraus dann die Klassen generierst. Alternativ kannst du natürlich auch sowohl
                    die Klassen als auch die Tabellen manuell anlegen, je nachdem, was dir lieber ist. In der Vorlesung machen wir es
                    uns jedoch einfach und schreiben nur die Klassen. Den Rest darf Java&nbsp;EE alleine machen. 😋 Wie die Klassen
                    hierfür aussehen müssen, schauen wir uns gleich genauer an. Für den Anfang reicht es aber zu wissen, dass es sich
                    um ganz normale Javaklassen handelt, von denen je ein Objekt einer Tabellenzeile entspricht. Die Klassen müssen
                    hierfür lediglich mit <code>@Entity</code> gekennzeichnet werden und für jedes Tabellenfeld ein Attribut mit
                    Settern und Gettern enthalten:
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        @Id
                        private String isbn;

                        public String getIsbn() {
                            return this.isbn;
                        }

                        public void setIsbn(String isbn) {
                            this.isbn = isbn;
                        }

                        …
                    }
                </source-code>
                <p>
                    Als nächstes folgen <b>Enterprise Java Beans</b>, die sinnvolle Methoden rund um das Datenmodell definieren.
                    Sie bilden sozusagen die Schnittstelle, mit der auf die Daten zugegriffen werden kann. Die Beans sollten daher
                    die üblichen CRUD-Methoden zum Anlegen, Lesen, Aktualisieren und Löschen von Einträgen beinhalten. Darüber hinaus
                    können Sie natürlich noch alle möglichen, weiteren Methoden umfassen, die für den Umgang mit den Daten nützlich sind.
                </p>
                <source-code language="java">
                    @Stateless
                    public class BuchService {
                        @PersistenceContext
                        EntityManager em;

                        // Bücher selektieren
                        public Buch findByIsbn(String isbn) { … }
                        public List&lt;Buch&gt; findByTitleContains(String title) { … }

                        // Neue Bücher speichern
                        public Buch saveNew(Buch buch) { … }

                        // Bücher Verlage ändern
                        public Buch update(Buch buch) { … }
                        public void delete(Buch buch) { … }
                    }
                </source-code>
                <p>
                    Auf dieser Ebene würde man dann auch <a href="https://de.wikipedia.org/wiki/Modultest" target="_blank">Unit Tests</a>
                    schreiben, um jederzeit die richtige Funktionsweise der Beans überprüfen zu können. Zusätzlich können die Beans mit
                    ganz wenig Aufwand zu Webservices ausgebaut werden, um somit auch von entfernten Clients aufgerufen werden zu können.
                    Die Details dazu schauen wir uns im Webservice-Kapitel an. Um dir zu zeigen, dass es aber wirklich ganz einfach geht,
                    hier ein minimales Beispiel:
                </p>
                <source-code language="java">
                    @Stateless
                    @WebService
                    public class BuchService {
                        @PersistenceContext
                        EntityManager em;

                        @WebMethod
                        @WebResult(name="buch")
                        public Buch findByIsbn(@WebParam(name="isbn") String isbn) {
                            …
                        }
                    }
                </source-code>
                <p>
                    Fehlt dann nur noch die Benutzeroberfläche, wobei dir hier das volle Programm zur Verfügung steht: Serverseitige
                    Webanwendungen, clientseitige Webanwendungen oder Native Clients für verschiedene Betriebssysteme. Alles ist erlaubt.
                </p>
            </aside>
        </section>

        <section>
            <h1>Welche Datenbank nutzen wir eigentlich?</h1>
            <article>
                <p>
                    Netbeans enthält die Datenbank <a href="https://db.apache.org/derby/" target="_blank">Apache Derby</a>.
                    Selbstverständlich können wir auch jede andere Datenbank verwenden, wenn wir sie selbst konfigurieren.
                    Aber wozu? Derby funktioniert prima.
                </p>
                <img src="netbeans-derby.png" alt="Netbeans mit gestarteter Derby-Datenbank" class="d-block" style="width: 100%;" />
            </article>
            <aside>
                <p>
                    Tja, das ist eine gute Frage. Dank der weiten Verbreitung von Java und JDBC können wir eigentlich jede beliebige
                    Datenbank verwenden. Jede Datenbank, die etwas auf sich hält, kommt auch mit einem JDBC-Treiber, auf den der
                    Applikationsserver zugreifen kann.
                </p>
                <p>
                    Für den Produktiveinsatz unserer Anwendungen ist das wichtig zu wissen. Für die Entwicklung ist es und jedoch
                    ein Stück weit egal, da Netbeans bereits eine Datenbank samt passender Glassfish-Konfiguration mitliefert.
                    Sie hört auf den Namen <a href="https://db.apache.org/derby/" target="_blank">Apache Derby</a>, ist in Java
                    geschrieben und wird automatisch mitgestartet, wenn wir unsere Anwendungen laufen lassen. Es ist schon alles
                    fix und fertig eingerichtet, wir müssen nichts tun. Wie schön. ☺️
                </p>
            </aside>
        </section>

        <section>
            <h1>Über die Datenbankwerkzeuge in Netbeans</h1>
            <article>
                <ul class="dhbw-carousel-links">
                    <li>
                        <a href="#netbeans-dbtools-carousel" role="button" data-slide="next">Nächstes Bild</a>
                    </li>
                    <li>
                        <a href="#netbeans-dbtools-carousel" role="button" data-slide="prev">Vorheriges Bild</a>
                    </li>
                    <li>
                        <a href="#netbeans-dbtools-carousel" role="button" data-slide-to="0">Nochmal von vorne</a>
                    </li>
                </ul>
                <ul class="dhbw-carousel-links">
                    <li>
                        <small>
                            <a href="#netbeans-dbtools-carousel" role="button" data-slide-to="0">Verbindung herstellen</a>
                        </small>
                    </li>
                    <li>
                        <small>
                            <a href="#netbeans-dbtools-carousel" role="button" data-slide-to="5">Tabellen bearbeiten</a>
                        </small>
                    </li>
                    <li>
                        <small>
                            <a href="#netbeans-dbtools-carousel" role="button" data-slide-to="11">Inhalte anzeigen und ändern</a>
                        </small>
                    </li>
                </ul>
                <div id="netbeans-dbtools-carousel" class="carousel slide" style="margin-bottom: 1em;" data-interval="false">
                    <div class="carousel-inner">
                        <div class="carousel-item img-thumbnail active">
                            <p>
                                Bevor die Datenbank genutzt werden kann, muss sie gestartet werden. Am einfachst startest du hierfür
                                eine Webanwendung. Die Datenbank wird dann automatisch mitgestartet.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-01.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Links findest du den Reiter <i>Services</i> mit dem Menüpunkt <i>Databases</i>. Dort sollte die Datenbank bereits
                                eingetragen sein, so dass du dich nur noch mit Rechtsklick und <i>Connect…</i> verbinden musst. Benutzername und
                                Passwort lauten jeweils <b>app</b>.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-02.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Fehlt der Eintrag, klappe den Eintrag <i>Drivers</i> auf, mache einen Rechtsklick auf <i>Java DB (Network)</i> und
                                wähle den Menüpunkt <i>Connect Using…</i> aus.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-03.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Daraufhin öffnet sich folgendes Fenster. Übernimm die Werte aus dem Screenshot und teste die Verbindung mit
                                <i>Test Connection</i>. Wenn alles in Ordnung ist, klicke auf <i>Finish</i>. Benutzername und Passwort lauten
                                weiterhin jeweils <b>app</b>.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-04.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Sobald die Verbindung hergestellt ist, werden links die vorhandenen Datenbankschemas mit ihren Tabellen
                                angezeigt. Unsere Tabellen befinden sich alle im Schema <i>APP</i>.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-05.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Per Rechtsklick auf den Eintrag <i>Table</i> lässt sich eine neue Tabelle anlegen.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-06.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Dadurch öffnet sich ein Fenster, in dem der Name der Tabelle sowie ihre Spalten hinterlegt werden.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-07.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Mit einem Rechtsklick auf eine Tabelle lassen sich nachträglich weitere Felder anhängen.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-08.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                So sieht dann das Fenster zum Anhängen eines weiteren Felds aus.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-09.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Einzelne Felder lassen sich per Rechtsklick und <i>Delete</i> auch wieder löschen.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-10.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Genau wie die ganze Tabelle, wenn es sein muss. Manchmal kannst du dadurch Probleme beim Starten der Anwendung lösen, wenn
                                die Entityklassen nicht mehr zu den Tabellen passen.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-11.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Rechtsklick auf eine Tabelle und dann <i>View Data…</i> dient der Anzeige vorhandener Tabelleneinträge.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-12.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Es öffnet sich ein Reiter, der im oberen Teil die ausgeführte SQL-Anweisung und unten ihr Ergebnis zeigt.
                                Über die Toolbar können weitere Einträge eingefügt oder gelöscht werden.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-13.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Das Kontextmenü enthält ebenfalls ein paar interessante Einträge.
                            </p>
                            <img class="active d-block w-100" src="netbeans-dbtools-14.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Du siehst: Netbeans hat echt mächtige Datenbankwerkzeuge an Board. 🦄
                            </p>
                            <img class="active d-block w-25 m-auto" src="../../finish.svg" />
                        </div>
                    </div>
                </div>

                <p>
                    <small>
                        <small>
                            Bildnachweis für das Endesymbol: <a href="https://pixabay.com/en/symbol-gui-internet-internet-page-2480163/" target="_blank">Pixabay: janf93</a>
                        </small>
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Nicht nur, dass Netbeans bereits eine fix und fertige Datenbank mitliefert, die wir beim Programmieren unserer
                    Anwendungen benutzen können, es hat auch so noch ein paar Tricks parat, die hin und wieder nützlich sind.
                    Auf den nachfolgenden Bildern siehst du daher, wie du …
                </p>
                <ul>
                    <li>
                        eine manuelle Verbindung zu Datenbank herstellen kannst.
                    </li>
                    <li>
                        Tabellen von Hand anlegen und bearbeiten kannst.
                    </li>
                    <li>
                        Tabellen wieder löschen kannst.
                    </li>
                    <li>
                        die Inhalte einer Tabelle anzeigen kannst.
                    </li>
                    <li>
                        sowie Tabellenzeilen einfügen, bearbeiten und löschen kannst.
                    </li>
                </ul>
                <img src="netbeans-databases.png" alt="Menüpunkt „Datebases” in Netbeans" class="d-block" style="max-width: 100%; margin-bottom: 1em;" />
                <p>
                    All dies versteckt sich hinter dem Punkt <i>Databases</i> im Reiter <i>Services</i> sowie den dazugehörigen
                    Kontextmenüs. Wie du in der Folie siehst, bringt ein einfacher Rechtsklick die schönsten Funktionen zu Tage.
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 1: Ein kleines Datenbank-Quiz</h1>
            <article>
                <h2>Aufgabe 1.1: Datenbankzugriffe mit Java</h2>

                <p>
                    a) Welche beiden Datenbank-APIs kennt die Java Enterprise Edition?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        JPA und JDBB
                    </li>
                    <li>
                        JDK und JDBC
                    </li>
                    <li>
                        JFK und JDCB
                    </li>
                    <li>
                        JPA und JDBC
                    </li>
                </ol>

                <p>
                    b) Welche Funktion erfüllen die „Java Database Connection”-Klassen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Sie legen passende Tabellen für die Persistence Entities an.
                    </li>
                    <li>
                        Sie dienen als Low-Level API dazu, SQL-Befehle an die Datenbank zu schicken.
                    </li>
                    <li>
                        Sie sprechen einen O/R-Mapper an, der Tabelleneinträge in Javaobjekte umwandeln kann.
                    </li>
                    <li>
                        Sie dienen der Nutzung von Persistence Entities innerhalb der EJBs.
                    </li>
                </ol>

                <p>
                    c) Und welche Funktion erfüllt die „Java Persistence API”?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                   <li>
                        Sie legt passende Tabellen für die Persistence Entities an.
                    </li>
                    <li>
                        Sie dient als Low-Level API dazu, SQL-Befehle an die Datenbank zu schicken.
                    </li>
                    <li>
                        Sie spricht einen O/R-Mapper an, der Tabelleneinträge in Javaobjekte umwandeln kann.
                    </li>
                    <li>
                        Sie dient der Nutzung von Persistence Entities innerhalb der EJBs.
                    </li>
                </ol>

                <h2>Aufgabe 1.2: Vorgehen bei der Entwicklung</h2>

                <p>
                    a) In welcher Reihenfolge sind die folgenden Schritte während der Entwicklung durchzuführen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Enterprise Java Beans entwickeln
                    </li>
                    <li>
                        Benutzeroberfläche oder Clients entwickeln
                    </li>
                    <li>
                        Datenmodell definieren
                    </li>
                    <li>
                        Tabellen anlegen (falls von Hand erledigt)
                    </li>
                    <li>
                        Serviceschicht definieren
                    </li>
                    <li>
                        Persistence Entities anlegen
                    </li>
                    <li>
                        Webservices anlegen
                    </li>
                </ol>

                <p>
                    b) Entfernte Clients können die Persistence Entities direkt nutzen, um Daten zu lesen oder zu schreiben?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Wahr
                    </li>
                    <li>
                        Falsch
                    </li>
                </ol>

                <p>
                    c) Welche Methoden sollten die Enterprise Java Beans in aller Regel beinhalten?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Create, Read, Unlock, Delete
                    </li>
                    <li>
                        Create, Rest, Update, Dismiss
                    </li>
                    <li>
                        Create, Read, Update, Delete
                    </li>
                    <li>
                        Create, Read, Update, Discard
                    </li>
                </ol>

                <h2>Aufgabe 1.3: Datenkbanken in Netbeans</h2>

                <p>
                    a) Welche Datenbanken werden von Netbeans unterstüzt?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Apache Derby
                    </li>
                    <li>
                        PostgreSQL, mySQL und MariaDB
                    </li>
                    <li>
                        Alle Datenbanken, für die es JDBC-Treiber gibt
                    </li>
                </ol>

                <p>
                    b) Welche Datenbank liefert Netbeans praktischerweise schon mit aus?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Apache Derby
                    </li>
                    <li>
                        MariaDB
                    </li>
                    <li>
                        Microsoft SQL Server
                    </li>
                    <li>
                        Oracle Express Edition
                    </li>
                    <li>
                        Oracle mySQL
                    </li>
                    <li>
                        PostgreSQL
                    </li>
                    <li>
                        SQLite
                    </li>
                    <li>
                        Keine
                    </li>
                </ol>

                <p>
                    c) Welche der folgenden Datenbankoperationen können mit Netbeans ausgeführt werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Tabellen anlegen
                    </li>
                    <li>
                        Tabellen bearbeiten
                    </li>
                    <li>
                        Tabellen löschen
                    </li>
                    <li>
                        Tabelleninhalte anzeigen
                    </li>
                    <li>
                        Tabelleninhalte einfügen
                    </li>
                    <li>
                        Tabelleninhalte ändern
                    </li>
                    <li>
                        Tabelleninhalte löschen
                    </li>
                    <li>
                        SQL-Befehle abschicken
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>Lösung:</b> <br />
                        Aufgabe 1.1: 4, 2, 3 <br />
                        Aufgabe 1.2: 3 → 4 → 6 → 5 → 1 → 7 → 2, 2, 3 <br />
                        Aufgabe 1.3: 3, 1, alle
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    So, das erste wäre geschafft. 👏🏼 Zeit für eine kurze Pause und ein kleines Quiz. 🍨
                    Danach schauen wir uns die Programmierung an.
                </p>
            </aside>
        </section>

        <!--
            ===================================
            DEFINITION DER PERSISTENCE ENTITIES
            ===================================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Definition der Persistence Entities</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Anatomie einer Persistence Entity</h1>
            <article>
                <p>
                    Persistence Entities sind einfache Beans, die mit <code>@Entity</code> gekennzeichnet werden.
                    Außerdem wird empfohlen, dass sie das <code>Serializable</code>-Interface implementieren.
                </p>
                <source-code language="java">
                    @Entity
                    public class Autor implements Serializable {
                </source-code>
                <div style="margin: 0 0 1em 2em;">
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "anatomie-schluessel-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#anatomie-schluessel"
                                role          = "tab"
                                aria-controls = "anatomie-schluessel"
                                aria-expanded = "true"
                            >
                                Schlüssel
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "anatomie-felder-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#anatomie-felder"
                                role          = "tab"
                                aria-controls = "anatomie-felder"
                            >
                                Felder
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "anatomie-konstruktoren-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#anatomie-konstruktoren"
                                role          = "tab"
                                aria-controls = "anatomie-konstruktoren"
                            >
                                Konstruktoren
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "anatomie-setget-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#anatomie-setget"
                                role          = "tab"
                                aria-controls = "anatomie-setget"
                            >
                                Setter und Getter
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "anatomie-alles-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#anatomie-alles"
                                role          = "tab"
                                aria-controls = "anatomie-alles"
                            >
                                Alles zusammen
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Schlüssel -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "anatomie-schluessel"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-schluessel-tab"
                        >
                            <p>
                                Häufig besitzen sie als einzigen Schlüsselwert ein Feld namens <code>id</code>, das automatisch
                                mit einer fortlaufenden Nummer versorgt wird. Dies wird durch die beiden Annotationen <code>@Id</code>
                                und <code>@GeneratedValue</code> ausgedrückt.
                            </p>
                            <source-code language="java">
                                @Id
                                @GeneratedValue
                                private long id = 0;
                            </source-code>
                        </div>
                        <!-- Felder -->
                        <div
                            class           = "tab-pane fade"
                            id              = "anatomie-felder"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-felder-tab"
                        >
                            <p>
                                Alle weiteren Felder sind automatisch Nichtschlüsselfelder. Sie benötigen im einfachsten Fall keine
                                Annotationen, können aber welche besitzen, um die Feldeigenschaften genauer zu spezifizieren.
                                Das schauen wir uns auf <a href="#11">Folie 11</a> nochmal an. Die Felder sollten <code>private</code>
                                oder <code>protected</code> sein.
                            </p>
                            <source-code language="java">
                                private String vorname = "";
                                private String nachname = "";
                                private String titel = "";
                            </source-code>
                        </div>
                        <!-- Konstruktoren -->
                        <div
                            class           = "tab-pane fade"
                            id              = "anatomie-konstruktoren"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-konstruktoren-tab"
                        >
                            <p>
                                Jede Persistence Entity sollte mindestens einen öffentlichen, parameterlosen Konstruktor besitzen, in dem
                                alle Felder mit leeren Werten vorbelegt werden. In diesem Beispiel ist der Konstruktor leer, da den Feldern
                                bereits bei ihrer Deklaration ein Wert zugewiesen wird.
                            </p>
                            <source-code language="java">
                                public Autor() {
                                }
                            </source-code>
                            <p>
                                Darüber hinaus können beliebige weitere Konstruktoren definiert werden, um die Anlage neuer Objekte zu vereinfachen.
                                Vorgaben gibt es hierfür keine, oftmals hat man aber noch einen Konstruktor, der für jedes Feld einen Parameter besitzt.
                            </p>
                            <source-code language="java">
                                public Autor(String vorname, String nachname, String titel) {
                                    this.vorname = vorname;
                                    this.nachname = nachname;
                                    this.titel = titel;
                                }
                            </source-code>
                        </div>
                        <!-- Setter und Getter -->
                        <div
                            class           = "tab-pane fade"
                            id              = "anatomie-setget"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-setget-tab"
                        >
                            <p>
                                Und damit es eine echte Bean ist, muss es zu jedem Feld mindestens einen Getter  geben. In der Regel gibt
                                es je Feld auch einen Stter, bei berechneten Feldern, deren Wert nicht in der Datenbank gespeichert wird,
                                kann er aber auch ausbleiben.
                            </p>
                            <source-code language="java">
                                //
                                // Normale Felder mit Setter und Getter
                                //
                                public void setId(long id) {
                                    this.id = id;
                                }

                                public long getId() {
                                    return this.id;
                                }

                                public void setVorname(String vorname) {
                                    this.vorname = vorname;
                                }

                                public String getVorname() {
                                    return this.vorname;
                                }

                                public void setNachname(String nachname) {
                                    this.nachname = nachname;
                                }

                                public String getNachname() {
                                    return this.nachname;
                                }

                                public void setTitel(String titel) {
                                    this.titel = titel;
                                }

                                public String getTitel() {
                                    return this.titel;
                                }

                                //
                                // Berechnete Felder ohne Setter
                                //
                                public String getNameKomplett() {
                                    String name = this.titel + " " + this.vorname + " " + this.nachname;
                                    return name.trim();
                                }
                            </source-code>
                        </div>
                        <!-- Alles zusammen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "anatomie-alles"
                            role            = "tabpanel"
                            aria-labelledby = "anatomie-alles-tab"
                        >
                            <source-code language="java">
                                //
                                // Schlüssel
                                //
                                @Id
                                @GeneratedValue
                                private long id = 0;

                                //
                                // Felder
                                //
                                private String vorname = "";
                                private String nachname = "";
                                private String titel = "";

                                //
                                // Konstruktoren
                                //
                                public Autor() {
                                }

                                public Autor(String vorname, String nachname, String titel) {
                                    this.vorname = vorname;
                                    this.nachname = nachname;
                                    this.titel = titel;
                                }

                                //
                                // Normale Felder mit Setter und Getter
                                //
                                public void setId(long id) {
                                    this.id = id;
                                }

                                public long getId() {
                                    return this.id;
                                }

                                public void setVorname(String vorname) {
                                    this.vorname = vorname;
                                }

                                public String getVorname() {
                                    return this.vorname;
                                }

                                public void setNachname(String nachname) {
                                    this.nachname = nachname;
                                }

                                public String getNachname() {
                                    return this.nachname;
                                }

                                public void setTitel(String titel) {
                                    this.titel = titel;
                                }

                                public String getTitel() {
                                    return this.titel;
                                }

                                //
                                // Berechnete Felder ohne Setter
                                //
                                public String getNameKomplett() {
                                    String name = this.titel + " " + this.vorname + " " + this.nachname;
                                    return name.trim();
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
                <source-code language="java">
                    }
                </source-code>
            </article>
            <aside>
                <p>
                    Persistence Entities zu schreiben ist wirklich einfach, da es sich um ganz normale Javaklassen
                    handelt, die einfach einen Datensatz einer Tabelle abbilden. 📖 Das heißt, sie besitzen einfach für
                    jedes Tabellenfeld ein gleichnamiges Attribut mit dazu passenden Setter- und Getter-Methoden. Hinzu
                    kommen noch ein paar kleine Annotationen, um sie als Entity zu kennzeichnen und die Schlüsselwerte
                    zu definieren und das war es auch schon. Zusätzlich wird empfohlen, dass sie das Interface
                    <code>Serializable</code> implementieren.
                </p>
                <source-code language="java">
                    @Entity
                    public class Autor
                    implements Serializable {
                        @Id
                        @GeneratesValue
                        private long id = 0;

                        public void setId(long id) {
                            this.id = id;
                        }

                        public long getId() {
                            return this.id;
                        }
                    }
                </source-code>
                <p>
                    Hier sehen wir auch gleich, wie der Tabellenschlüssel definiert wird. Die beiden Annotationen <code>@Id</code>
                    und <code>@GeneratedValue</code> legen fest, dass es sich bei dem Feld <code>id</code> um ein Schlüsselfeld
                    handelt und dass der Wert beim Speichern automatisch vergeben wird, wenn er leer ist.
                </p>
                <p>
                    Hinzu kommen dann einfach noch ein paar weitere Nichtschlüsselfelder (die immer <code>private</code> oder
                    <code>protected</code> sein sollten) samt Settern und Gettern sowie mindestens ein öffentlicher, parameterloser
                    Konstruktor und fertig ist unsere Klasse. Also eigentlich ganz einfach, wie du auf der Folie siehst. 😎
                </p>
            </aside>
        </section>

        <section>
            <h1>Darf's ein bisschen mehr sein?</h1>
            <article>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🐪
                        </td>
                        <td>
                            Ohne weitere Angaben, darf eine Persistence Entity nur ein Schlüsselfeld besitzen:
                        </td>
                    </tr>
                </table>
                <source-code language="java">
                    @Entity
                    public class Verlag {
                        @Id
                        @GeneratedValue
                        private long id = 0;

                        …
                    }
                </source-code>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🐪
                        </td>
                        <td>
                            Mehrere Schlüsselwerte müssen in einer eigenen Klasse definiert werden.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🐪
                        </td>
                        <td>
                            Die Klasse muss mit <code>@IdClass</code> der Entity zugeordnet werden.
                        </td>
                    </tr>
                </table>
                <source-code language="java">
                    public class BuchId {
                        private String isbn = "";
                        private int auflage = 0;

                        // Konstruktoren …
                        // Setter und Getter …
                    }

                    @Entity
                    @IdClass(BuchId.class)
                    public class Buch {
                        @Id
                        private String isbn = "";

                        @Id
                        private int auflage = 0;

                        // Der ganze Rest …
                    }
                </source-code>
            </article>
            <aside>
                <p>
                    So, wie es in der vorherigen Folie gezeigt wurde, kann eine Persistence Entity immer nur ein
                    Schlüsselfeld besitzen:
                </p>
                <source-code language="java">
                    @Entity
                    public class Verlag {
                        @Id
                        @GeneratedValue
                        private long id = 0;

                        …
                    }
                </source-code>
                <p>
                    Häufiger als man denkt, reicht das auch völlig aus. Manchmal kommt man aber um einen zusammengesetzten
                    Schlüssel mit mehreren Feldern nicht herum. Im Prinzip muss man dafür einfach nur mehrere Felder mit
                    <code>@Id</code> auszeichnen, zusätzlich braucht man aber noch eine weitere Klasse, die nur den Schlüssel 🗝️
                    definiert.
                </p>
                <p>
                    Im Beispiel auf der Folie sieht man schön, wie das Klasse <code>BuchId</code> die beiden Felder <code>isbn</code>
                    und <code>auflage</code> definiert. Es handelt sich um die beiden Schlüsselfelder, mit denen eine ganz bestimmte
                    Auflage eines Buchs identifiziert wird. Vor der Klasse <code>Buch</code> steht daher die Annotation
                    <src-code language="java">@IdClass(BuchId.class)</src-code>, um zu definieren, dass die Klasse <code>BuchId</code>
                    die Schlüsselfelder vorschreibt. Zusätzlich befinden sich innerhalb von <code>Buch</code> ebenfalls die beiden Werte
                    <code>isbn</code> und <code>auflage</code>, jeweils mit <code>@Id</code> ausgestattet, damit sie auch tatsächlich in
                    der Datenbank gespeichert werden.
                </p>

                <h2>Warum so kompliziert?</h2>
                <p>
                    Warum das so kompliziert ist, höre ich dich fragen? Warum man nicht einfach auf die zweite Klasse verzichten kann? 🤔
                    Das sehen wir später, wenn wir einzelne Objekte aus der Datenbank auslesen wollen. Hier brauchen wir dann die neue
                    Klasse, um die Schlüsselwerte des zu lesenden Datensatzes zu übergeben.
                </p>
            </aside>
        </section>

        <section>
            <h1>Definition der Tabellen- und Feldeigenschaften</h1>
            <article>
                <h4>Benötigte Annotationen</h4>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            📎
                        </td>
                        <td>
                            <code>@Table</code>
                        </td>
                        <td>
                            Steht vor der Klasse und definiert weitere Tabelleneigenschaften.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            📎
                        </td>
                        <td>
                            <code>@Index</code>
                        </td>
                        <td>
                            Definiert die Felder eines Index auf die Tabelle.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            📎
                        </td>
                        <td>
                            <code>@Column</code>
                        </td>
                        <td>
                            Steht vor einem Feld und definiert weitere Feldeigenschaften.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            📎
                        </td>
                        <td>
                            <code>@Lob</code>
                        </td>
                        <td>
                            Kennzeichnet eine Feld als <i>Large Object</i> mit unbegrenzter Länge.
                        </td>
                    </tr>
                </table>

                <hr />

                <h4>Praktisches Beispiel</h4>
                <source-code language="java">
                    @Entity
                    @Table(
                        name    = "T_BUCH",
                        schema  = "BUCHSAMMLUNG",
                        indexes = {
                            @Index(
                                name       = "I_AUTOR_JAHR",
                                columnList = "autor, jahr DESC"
                            ),
                            @Index(
                                name       = "I_JAHR",
                                columnList = "jahr DESC"
                            )
                        }
                    )
                    public class Buch implements Serializable {
                        @Id
                        @Column(length=30)
                        private String isbn = "";

                        @Column(nullable=false, length=50)
                        private String autor;

                        @Column(nullable=false, precision=4)
                        private long jahr;

                        @Column(nullable=false, precision=7, scale=2)
                        private long preis;

                        @Lob
                        private String klappentext = "";

                        // Und so weiter …
                    }
                </source-code>
            </article>
            <aside>
                <p>
                    In vielen Fällen kann Java aus dem Namen einer Klasse und ihrer Felder sowie den dazugehörigen Datentypen genug
                    herauslesen, um sinnvolle Tabellen in der Datenbank anzulegen. Lässt man die Tabellen jedoch nicht automatisch
                    anlegen, sondern schreibt Entities zu bereits vorhandenen Tabellen, muss man Java hier und da ein wenig auf die
                    Sprünge helfen, 🏇 damit beides auch wirklich zusammen passt. Dasselbe gilt auch, wenn man Sachen definieren
                    will, die sich aus dem Javacode alleine nicht ableiten lassen, beispielsweise die maximale Länge eines Stringfelds. 📏
                </p>
                <p>
                    Der allgemeinen Logik von Java&nbsp;EE folgenden müssen hierfür nur ein paar mehr Annotationen in die Klassen
                    eingebaut werden. Ein etwas größeres Beispiel könnte daher wie auf der Folie dargestellt aussehen. Die Annotationen
                    haben dabei folgende Bedeutung:
                </p>
                <dl>
                    <dt>
                        <code>@Table</code>
                    </dt>
                    <dd>
                        <p>
                            Steht vor einer Klasse und definiert weitere Eigenschaften zur Tabelle:
                        </p>
                        <ul>
                            <li>
                                <b>name:</b> Name der Tabelle
                            </li>
                            <li>
                                <b>schama:</b> Datenbankschema, in dem die Tabelle angelegt wird (wenn die Datenbank mehrere Schemas
                                besitzt und nicht das Standardschema verwendet werden soll)
                            </li>
                            <li>
                                <b>indexes:</b> Mit <code>@Index</code> definierte Indizes zur Beschleunigung häufiger Lesezugriffe
                            </li>
                        </ul>
                    </dd>

                    <dt>
                        <code>@Index</code>
                    </dt>
                    <dd>
                        <p>
                            Definiert die Feldes eines anzulegenden Index. Die Felder werden durch Komma getrennt und können wahlweise
                            mit <code>ASC</code> und <code>DESC</code> auf- oder absteigend sortiert werden. Ohne diese Angabe werden
                            die Felder aufsteigend sortiert.
                        </p>
                    </dd>
                    <dt>
                        <code>@Column</code>
                    </dt>
                    <dd>
                        <p>
                            Steht vor einem einzelnen Feld und definiert weiter Eigenschaften des Felds.
                        </p>
                        <ul>
                            <li>
                                <b>name:</b> Name des Felds
                            </li>
                            <li>
                                <b>length:</b> Maximale Feldlänge
                            </li>
                            <li>
                                <b>precision:</b> Anzahl Ziffern bei numerischen Feldern (inkl. Nachkommastellen!)
                            </li>
                            <li>
                                <b>scale:</b> Anzahl der Nachkommastellen bei nummerischen Feldern
                            </li>
                            <li>
                                <b>nullable:</b> Boolean, ob das Feld Null-Werte beinhalten darf
                            </li>
                            <li>
                                <b>insertable:</b> Boolean, ob das Feld beim Einfügen neuer Sätze berücksichtigt wird
                            </li>
                        </ul>
                    </tdd>

                    <dt>
                        <code>@Lob</code>
                    </dt>
                    <dd>
                        Steht vor einem Feld und legt fest, dass das Feld ein <i>Large Object</i> mit unbegrenzter
                        Länge ist. Dies ist wichtig, da Strings standardmäßig als <code>VARCHR(255)</code> und eben
                        nicht als unbegrenzt lange Felder angelegt werden. Allerdings reduzieren solche Felder die
                        Performance der Datenbank erheblich und sollten daher nur sehr sparsam 💸 benutzt werden.
                        Auch kann man nicht nach ihnen selektieren.
                    </dd>
                </dl>
            </aside>
        </section>

        <section>
            <h1>Fremdschlüsselbeziehungen richtig abbilden</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-uebersicht-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-uebersicht"
                                role          = "tab"
                                aria-controls = "fremdschluessel-uebersicht"
                                aria-expanded = "true"
                            >
                                Übersicht
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-1zu1-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-1zu1"
                                role          = "tab"
                                aria-controls = "fremdschluessel-1zu1"
                            >
                                1:1-Beziehungen
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-1zuN-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-1zuN"
                                role          = "tab"
                                aria-controls = "fremdschluessel-1zuN"
                            >
                                1:n-Beziehungen
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-Nzu1-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-Nzu1"
                                role          = "tab"
                                aria-controls = "fremdschluessel-Nzu1"
                            >
                                n:1-Beziehungen
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "fremdschluessel-NzuM-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#fremdschluessel-NzuM"
                                role          = "tab"
                                aria-controls = "fremdschluessel-NzuM"
                            >
                                n:m-Beziehungen
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Übersicht -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "fremdschluessel-uebersicht"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-uebersicht-tab"
                        >
                            <table style="margin-bottom: 1em;">
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        🔑
                                    </td>
                                    <td>
                                        Fremdschlüssel werden als Objektreferenzen in Java abgebildet.
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        🔑
                                    </td>
                                    <td>
                                        Eine Beziehung kann dabei die Kardinalitäten 1:1, 1:n, n:1 oder n:m besitzen.
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        ➡️
                                    </td>
                                    <td>
                                        Unidirektionale Beziehungen verweisen einfach von einer Klasse auf eine andere.
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        ↔️
                                    </td>
                                    <td>
                                        Bei bidirektionalen Beziehungen verweisen beide Klassen gegenseitig aufeinander.
                                    </td>
                                </tr>
                            </table>

                            <table style="margin-bottom: 2em;">
                                <thead>
                                    <tr>
                                        <th>
                                            Kardinalität
                                        </th>
                                        <th>
                                            Einfache Verknüpfung
                                        </th>
                                        <th>
                                            Optionale Rückverknüpfung
                                        </th>
                                    </tr>
                                </thead>
                                <tr>
                                    <td>
                                        1:1
                                    </td>
                                    <td>
                                        <code>@OneToOne</code>
                                    </td>
                                    <td>
                                        <code>@OneToOne(mappedBy="feldname")</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        1:n
                                    </td>
                                    <td>
                                        <code>@OneToMany</code>
                                    </td>
                                    <td>
                                        <code>@ManyToOne(mappedBy="feldname")</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        n:1
                                    </td>
                                    <td>
                                        <code>@ManyToOne</code>
                                    </td>
                                    <td>
                                        <code>@OneToMany(mappedBy="feldname")</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        n:m
                                    </td>
                                    <td>
                                        <code>@ManyToMany</code>
                                    </td>
                                    <td>
                                        <code>@ManyToMany(mappedBy="feldname")</code>
                                    </td>
                                </tr>
                            </table>

                            <h4 style="margin-bottom: 0.5em;">Beispiel</h4>

                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    …
                                    @ManyToOne(                      // Viele Bücher haben einen Verlag
                                        optional = false,            // Es muss immer einen Verlag geben
                                        fetch    = FetchType.LAZY    // Daten erst bei einem Zugriff darauf laden
                                    )
                                    Verlag verlag = null;

                                    @ManoToOne(
                                        optional = false,
                                        fetch    = FetchType.EAGER   // Daten so früh wie möglich laden
                                    )
                                    Autor autor = null;
                                }
                            </source-code>
                        </div>
                        <!-- 1:1-Beziehungen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fremdschluessel-1zu1"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-1zu1-tab"
                        >
                            <h3>Unidirektionale Verknüpfung</h3>
                            <p>
                                Eine Entity kann mit <code>@OneToOne</code> auf eine beliebige andere Entity verweisen, um einen Fremdschlüssel
                                mit 1:1-Kardinalität abzubilden. In der Tabelle entsteht dadurch ein <b>Fremdschlüsselfeld</b>.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Autor {
                                    …
                                    @OneToOne
                                    Adresse adresse = null;
                                }

                                @Entity
                                public class Adresse {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;
                                    …
                                }
                            </source-code>

                            <h3>Verknüpfung über dieselben Schlüsselfelder</h3>
                            <p>
                                Das Fremdschlüsselfeld in der Tabelle kann entfallen, wenn beide Tabellen <b>identische Schlüsselwerte</b>
                                besitzen. In diesem Fall kommt zu <code>@OneToOne</code> noch die Annotation <code>@MapsId</code> hinzu.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Autor {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    @OneToOne
                                    @MapsId
                                    Adresse adresse = null;
                                }

                                @Entity
                                public class Adresse {
                                    @Id
                                    private long autorId = 0;
                                    …
                                }
                            </source-code>

                            <h3>Bidirektionale Verknüpfung</h3>
                            <p>
                                Eine bidirektionale Verknüpfung entsteht, indem zusätzlich zur Verknüpfung von der einen Klasse auf die andere,
                                die zweite Klasse mit <code>@OneToOne(mappedBy="…")</code> auf das Feld der ersten Klasse zurückverweist.
                                In der Datenbank entsteht dadurch <b>kein zweiter Fremdschlüssel</b>.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Autor {
                                    …
                                    @OneToOne
                                    Adresse adresse = null;
                                }

                                @Entity
                                public class Adresse {
                                    …
                                    @OneToOne(mappedBy="adresse")
                                    Autor autor = null;
                                }
                            </source-code>
                        </div>
                        <!-- 1:n -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fremdschluessel-1zuN"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-1zuN-tab"
                        >
                            <h3>Unidirektionale Verknüpfung</h3>
                            <p>
                                1:n-Beziehungen funktionieren grundsätzlich nicht anders als 1:1-Beziehungen. Doch anstelle einer
                                einfachen Referenz gibt es nun eine ganze Liste, auf die eine Entity verweisen kann. In der Datenbank
                                wird dies durch ein <b>Fremdschlüsselfeld in der Zieltabelle</b> abgebildet.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    …
                                    @OneToMany
                                    List&lt;Bewertung&gt; bewertungen = new ArrayList&lt;&gt;();
                                }

                                @Entity
                                public class Bewertung {
                                    …
                                }
                            </source-code>

                            <h3>Bidirektionale Verknüpfung</h3>
                            <p>
                                Durch <code>@ManyToOne(mappedBy="…")</code> kann die Zielklasse wieder eine rückwärtsgerichtete
                                Beziehung zur Quellklasse herstellen, ohne dass diese in der Datenbank abgelegt wird. Der Verweis
                                zeigt auf eine einzelne Referenz.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    …
                                    @OneToMany
                                    List&lt;Bewertung&gt; bewertungen = new ArrayList&lt;&gt;();
                                }

                                @Entity
                                public class Bewertung {
                                    …
                                    @ManyToOne(mappedBy="bewertungen")
                                    Buch buch = null;
                                }
                            </source-code>
                        </div>
                        <!-- n:1-Beziehungen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fremdschluessel-Nzu1"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-Nzu1-tab"
                        >
                            <h3>Unidirektionale Verknüpfung</h3>
                            <p>
                                n:1 ist das Gegenteil von 1:n, logisch. Technisch gesehen ist es aber mehr mit 1:1 verwandt,
                                da auch hier einfach <b>ein Fremdschlüsselfeld in der Quelltabelle</b> entsteht. Allerdings
                                ist es hier erlaubt, dass mehrere Datensätze auf dieselbe Zielentität verweisen.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    …
                                    @ManyToOne
                                    Verlag verlag = null:
                                }

                                @Entity
                                public class Verlag {
                                    …
                                }
                            </source-code>

                            <h3>Bidirektionale Verknüpfung</h3>
                            <p>
                                Und auch hier gibt es die Möglichkeit, mit <code>@OneToMany(mappedBy="…")</code> eine inverse
                                Verknüpfung zu definieren. Die Annotation muss dabei vor einer Liste stehen.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    …
                                    @ManyToOne
                                    Verlag verlag = null:
                                }

                                @Entity
                                public class Verlag {
                                    …
                                    @OneToMany(mappedBy="verlag")
                                    List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();
                                }
                            </source-code>
                        </div>
                        <!-- n:m-Beziehungen -->
                        <div
                            class           = "tab-pane fade"
                            id              = "fremdschluessel-NzuM"
                            role            = "tabpanel"
                            aria-labelledby = "fremdschluessel-NzuM-tab"
                        >
                            <h3>Unidirektionale Verknüpfung</h3>
                            <p>
                                Nach all den vorherigen Beispielen, wie wird da wohl eine n:m-Beziehung aussehen? Richtig, wir verwenden
                                <code>@ManyToMany</code> vor einer Liste. In der Datenbank entsteht dadurch eine <b>Verknüpfungstabelle</b>.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    …
                                    @ManyToMany
                                    List&lt;Autor&gt; autoren = new ArrayList&lt;&gt;();
                                }

                                @Entity
                                public class Autor {
                                    …
                                }
                            </source-code>

                            <h3>Bidirektionale Verknüpfung</h3>
                            <p>
                                Und wie immer auch mit Rückfahrticket, in diesem Fall <code>@ManyToMany(mappendBy="…")</code> ebenfalls
                                vor einer Liste.
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Buch {
                                    …
                                    @ManyToMany
                                    List&lt;Autor&gt; autoren = new ArrayList&lt;&gt;();
                                }

                                @Entity
                                public class Autor {
                                    …
                                    @ManyToMany(mappedBy="autoren")
                                    List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Fremdschlüsselbeziehungen gehören zu den großen Stärken relationaler Datenbanken und natürlich kann auch
                    die Java Persistence API damit umgehen. Doch im Gegensatz zu den Datenbanken legt JPA hier noch eine Schippe
                    an Komfort drauf und bildet die Beziehungen zwischen zwei Entities nicht einfach durch Übernehmen der
                    Schlüsselwerte der einen Entity in die andere Entity ab. Kurz, so läuft es nicht: 🙃
                </p>
                <source-code language="java">
                    @Entity
                    public class Verlag {
                        @Id
                        @GeneratedValue
                        private long id = 0;
                        …
                    }

                    @Entity
                    public class Buch {
                        @Id
                        private String isbn = "";

                        // Vermeintlicher Fremdschlüssel
                        private long verlagId = 0;
                        …
                    }
                </source-code>
                <p>
                    Stattdessen werden die Beziehungen über Objektreferenzen abgebildet, so dass im obigen Beispiel ein <code>Buch</code>
                    einen direkten Verweis auf seinen <code>Verlag</code> hätte. Zusätzlich kommt eine spezielle Annotation zum Einsatz,
                    die besagt, um was für eine Verknüpfung (1:1, 1:n, n:1 oder n:m) es sich handelt:
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        @Id
                        private String isbn = "";

                        // Richtiger Fremdschlüssel
                        @ManyToOne
                        private Verlag verlag = null;
                        …
                    }
                </source-code>
                <p>
                    Das ist wirklich elegant! 👒 Wir brauchen nämlich nur ein Objekt vom Typ <code>Buch</code> aus der Datenbank lesen
                    und bekommen alle Daten zum <code>Verlag</code> kostenlos mit dazu, ohne eine zweite Datenbankabfrage absetzen
                    zu müssen. Das macht der O/R-Mapper bereits im Hintergrund, ohne dass wir uns darum kümmern müssen. Allerdings sollten
                    wir ihm deshalb auch sagen, wenn der die Daten vorerst nicht zu laden braucht, da sie ohnehin nicht immer benötigt
                    werden:
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        @Id
                        private String isbn = "";

                        // Richtiger Fremdschlüssel
                        @ManyToOne(fetchType=FetchType.LAZY)
                        private Verlag verlag = null;
                        …
                    }
                </source-code>
                <p>
                    In diesem Fall würden die meisten O/R-Mapper die Daten zum Verlag erst nachladen, wenn wir wirklich auf das Attribut
                    <code>verlag</code> des Buchs zugreifen.
                </p>
                <p>
                    Des weiteren können wir in Java auch sogenannte <b>bidirektionale Beziehungen</b> herstellen, was es so in der
                    Datenbankwelt nicht gibt. Damit ist gemeint, dass nicht nur die Entität A auf B verweisen sondern auch B zurück
                    auf A verweisen kann. Ohne dass dieser zusätzliche Verweis in der Datenbank abgelegt wird. Möglich macht das das
                    Attribut <code>mappedBy</code> der verwendeten Annotationen, das immer den Feldnamen innerhalb der Quellentität
                    enthält.
                </p>
                <source-code language="java">
                    @Entity
                    public class Buch {
                        …
                        @ManyToOne
                        Verlag verlag = null;
                    }

                    @Entity
                    public class Verlag {
                        …
                        @OneToMany(mappedBy="verlag")
                        List&lt;Buch&gt; buecher = new ArrayList&lt;&gt;();
                    }
                </source-code>
                <p>
                    Wenn dir das soweit klar ist, hast du bereits alles Wesentliche verstanden. 🤝 Auf der Folie findest du dann
                    weitere Beispiele und Erklärungen darüber, wie die verschiedenen Beziehungstypen in Java nachgebaut werden.
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)" id="aufgabe2">
            <h1>Aufgabe 2: Wir eröffnen ein Kino</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "aufgabe2-diagramm-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#aufgabe2-diagramm"
                                role          = "tab"
                                aria-controls = "aufgabe2-diagramm"
                                aria-expanded = "true"
                            >
                                E/R-Diagramm
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe2-standort-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe2-standort"
                                role          = "tab"
                                aria-controls = "aufgabe2-standort"
                            >
                                Standort &amp; Co.
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe2-spielplan-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe2-spielplan"
                                role          = "tab"
                                aria-controls = "aufgabe2-spielplan"
                            >
                                Spielplan &amp; Co.
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe2-loesung-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe2-loesung"
                                role          = "tab"
                                aria-controls = "aufgabe2-loesung"
                            >
                                Lösung
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- E/R-Diagramm -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "aufgabe2-diagramm"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe2-diagramm-tab"
                        >
                            <p>
                                Hier ist es: Unser Datenmodell in seiner vollen Pracht. 🌅 Um die Aufgabe etwas leichter zu machen, haben wir den
                                Beziehungen eine Richtung gegeben und kleine Bezeichnungen hinzugefügt. Schaue dir das Modell in aller Ruhe an und
                                versuche, so viel wie möglich nachzuvollziehen. 🤔
                                <br />
                                <small>
                                    <small>
                                        Falls du dich wunderst, warum es eine Tabelle mit Standorten gibt: Der ehemalige Besitzer der
                                        <a href="http://www.schauburg.de" target="_blank">Schauburg</a>,
                                        <a href="https://ka.stadtwiki.net/Georg_Fricker" target="_blank">Georg Fricker</a>,
                                        war bis zum Schluss auch Geschäftsführer vom
                                        <a href="http://www.filmpalast.net/" target="_blank">Filmpalast am ZKM</a>.
                                    </small>
                                </small>
                            </p>
                            <img src="aufgabe2-komplett.svg" alt="Komplettes E/R-Diagramm unseres Kinobeispiels" class="d-block" style="width: 100%; margin-top: 1em;" />
                        </div>
                        <!-- Standort & Co. -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe2-standort"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe2-standort-tab"
                        >
                            <p>
                                Als kleine Anschubfinanzierung haben wir den oberen Teil rund um die Standorte des Kinos 🎞️ bereits in Java umgesetzt. Unten findest
                                du den Quellcode.
                            </p>
                            <img src="aufgabe2-standort.svg" alt="Entitäten Standort, Mitarbeiter, Adresse und Öffnungszeit" class="d-block" style="width: 100%; margin-top: 1em;" />
                            <source-code language="java">
                                @Entity
                                public class Standort implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String name = "";

                                    @OneToMany
                                    List&lt;Oeffnungszeit&gt; oeffnungszeiten = new ArrayList&lt;&gt;();

                                    @OneToOne
                                    Adresse adresse = new Adresse();

                                    @OneToMany(mappedBy="standort")
                                    List&lt;Mitarbeiter&gt; mitarbeiter = new ArrayList&lt;&gt;();

                                    @OneToMany
                                    List&lt;Spielplan&gt; = spielplaene new ArrayList&lt;&gt;();

                                    // Konstruktoren …
                                    // Setter und Getter …
                                }

                                @Entity
                                public class Oeffnungszeit implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private Wochentag wochentag = Wochentag.UNBEKANNT;
                                    private Time vonUhrzeit = new Time();
                                    private Time bisUhrzeit = new Time();

                                    @ManyToOne(mappedBy="oeffnungszeiten")
                                    Standort standort = new Standort();

                                    // Konstrukturen …
                                    // Setter und Getter …
                                }

                                public enum Wochentag {
                                    UNBEKANNT, MONTAG, DIENSTAG, MITTWOCH,
                                    DONNERSTAG, FREITAG, SAMSTAG, SONNTAG;
                                }

                                @Entity
                                public class Adresse implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String strasse = "";
                                    private String hausnummer = "";
                                    private String postleitzahl = "";
                                    private String ort = "";
                                    private String land = "";

                                    // Konstruktoren
                                    // Setter und Getter
                                }

                                @Entity
                                public class Mitarbeiter implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String vorname = "";
                                    private String nachname = "";
                                    private Geschlecht geschlecht = Geschlecht.UNBEKANNT;
                                    private int durchwahl = 0;
                                    private String email = "";

                                    @Column(precision=7, scale=2)
                                    private long monatsgehalt = 1000.00;

                                    @OneToOne
                                    Adresse adresse = new Addresse();

                                    @ManyToOne
                                    Standort standort = new Standort();

                                    // Konstruktoren …
                                    // Setter und Getter …
                                }

                                public enum GESCHLECHT {
                                    UNBEKANNT, MAENNLICH, WEIBLICH;
                                }
                            </source-code>
                        </div>
                        <!-- Spielplan & Co. -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe2-spielplan"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe2-spielplan-tab"
                        >
                            <p>
                                Jetzt bist du dran. 👉🏽 Ergänze den Javacode um die fehlenden Entitäten rund im den Spielplan. Die Beziehungen zwischen
                                den Klassen sollen bidirektional umgesetzt werden und <a href="https://de.wikipedia.org/wiki/Filmgenre" target="_blank">Filmgenres</a>
                                können sein: <i>Action</i>, <i>Drama</i>, <i>Fantasy</i>, <i>SciFi</i>, <i>Komödie</i> oder <i>Animation</i>.
                            </p>
                            <img src="aufgabe2-spielplan.svg" alt="Entitäten Spieplan, Vorführung, Film und Mitwirkender" class="d-block" style="width: 100%; margin-top: 1em;" />
                        </div>
                        <!-- Lösung -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe2-loesung"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe2-loesung-tab"
                        >
                            <p>
                                Hier die Musterlösung für die Persistence Entities rund um den Spielplan:
                            </p>
                            <source-code language="java">
                                @Entity
                                public class Spielplan implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String name = "";

                                    @Lob
                                    private String webseitentext = "";

                                    @ManyToOne(mappedBy="spielplaene")
                                    Standort standort = new Standort();

                                    @OneToMany
                                    List&lt;Voerfuerhung&gt; vorfuehrungen = new ArrayList&lt;&gt;();

                                    // Konstruktoren
                                    // Setter und Getter …
                                }

                                @Entity
                                public class Vorfuehrung implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private Wochentag wochentag = Wochentag.UNBEKANNT;
                                    private Time vonUhrzeit = new Time();
                                    private Time bisUhrzeit = new Time();
                                    private String kinosaal = "";

                                    @ManyToOne(mappedBy="vorfuehrungen")
                                    Spielplan spielplan = new Spielplan();

                                    @ManyToOne
                                    Film film = new Film();

                                    // Konstruktoren …
                                    // Setter und Getter …
                                }

                                @Entity
                                public class Film implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String name = "";
                                    private int jahr = 0;
                                    private Genre genre = Genre.UNBEKANNT;
                                    private String verleiher = "";

                                    @Lob
                                    private String webseitentext = "";

                                    @OneToMany(mappedBy="film")
                                    List&lt;Vorfuehrung&gt; vorfuehrungen = new ArrayList&lt;&gt;();

                                    @ManyToMany
                                    List&lt;Mitwirkender&gt; mitwirkende = new ArrayList&lt;&gt;();

                                    // Konstruktoren …
                                    // Setter und Getter …
                                }

                                public enum Genre {
                                    UNBEKANNT, ACTION, DRAMA, FANTASY, SCIFI, COMEDY, ANIMATION;
                                }

                                @Entity
                                public class Mitwirkender implements Serializable {
                                    @Id
                                    @GeneratedValue
                                    private long id = 0;

                                    private String vorname = "";
                                    private String nachname = "";
                                    private String artDerMitwirkung = "";
                                    private String nameImFilm = "";

                                    @ManyToMany(mappedBy="mitwirkende")
                                    Lilst&lt;Film&gt; filme = new ArrayList&lt;&gt;();

                                    // Konstruktoren …
                                    // Setter und Getter …
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Nach so vielen neuen Informationen wollen wir unser neu erworbenes Wissen doch gleich mal anwenden.
                    Auf dieser Folie siehst du daher ein größeres Beispiel über ein
                    <a href="http://www.schauburg.de/">nicht ganz unbekanntes Kino hier in Karlsruhe</a>. 📽️
                    Denn Bücher 📚 haben jetzt wahrlich genug gesehen. 😛
                </p>
                <img src="schauburg.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://ka.stadtwiki.net/Datei:Schauburg_-_Frontal_20131222-121940.hk.jpg" target="_blank">Stadtwiki Karlsruhe: Kucharek</a>
                        <!-- Vorsicht: CC-BY-NC-SA Lizenz -->
                    </small>
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 3: Ein kleines Persistence-Entity-Quiz</h1>
            <article>
                <h2>Aufgabe 3.1: Schlüsselwerte definieren</h2>

                <p>
                    a) Persistence Entities besitzen immer nur ein Schlüsselfeld.
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Wahr
                    </li>
                    <li>
                        Falsch
                    </li>
                </ol>

                <p>
                    b) Persistence Entities können auch nicht-automatisch vergebene Schlüsselfelder besitzen.
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Wahr
                    </li>
                    <li>
                        Falsch
                    </li>
                </ol>

                <p>
                    c) Welche Annotation kennzeichnet die Schlüsselfelder einer Persistence Entity?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <code>@Key</code>
                    </li>
                    <li>
                        <code>@Id</code>
                    </li>
                    <li>
                        <code>@IdClass</code>
                    </li>
                    <li>
                        <code>@IdField</code>
                    </li>
                </ol>

                <p>
                    d) Wie muss man vorgehen, um eine Entity mit mehr als einem Schlüsselfeld zu definieren?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Das geht nicht, siehe Frage a).
                    </li>
                    <li>
                        Einfach alle Felder mit <code>@IdField</code> kennzeichnen.
                    </li>
                    <li>
                        Alle Felder mit <code>@Id</code> kennzeichnen und mit <code>@IdClass</code> auf eine
                        Klasse mit nur den Schlüsselfeldern verweisen.
                    </li>
                    <li>
                        Alle Schlüsselfelder in einer eigenen Klasse definieren und dann eine Referenz
                        auf die Klasse mit <code>@IdClass</code> kennzeichnen.
                    </li>
                </ol>

                <h2>Aufgabe 3.2: Tabellen- und Feldeigenschaften</h2>

                <p>
                    a) Wie oft kann die Annotation <code>@Table</code> in einer Persistence Entity verwendet werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Gar nicht, es handelt sich um eine Annotation für EJBs
                    </li>
                    <li>
                        Höchstens einmal
                    </li>
                    <li>
                        Genau einmal
                    </li>
                    <li>
                        Höchstens drei mal
                    </li>
                    <li>
                        Beliebig oft
                    </li>
                </ol>

                <p>
                    b) An welcher Stelle muss die Annotation <code>@Column</code> in einer Persistence Entity stehen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Irgendwo vor der Klasse
                    </li>
                    <li>
                        Immer vor der Annotation <code>@Entity</code>
                    </li>
                    <li>
                        Immer nach der Annotation <code>@Entity</code>
                    </li>
                    <li>
                        In jeder beliebigen Stelle innerhalb der Klasse
                    </li>
                    <li>
                        Vor beliebig vielen Attributen der Klasse
                    </li>
                    <li>
                        Vor beliebig vielen Methodenparametern
                    </li>
                </ol>

                <p>
                    c) Wozu dienen die Indizes, die mit <code>@Table</code> definiert werden können?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Der Beschleunigung häufig benötigter Datenselektionen
                    </li>
                    <li>
                        Der Beschleunigung häufig benötigter Einfügeoperationen
                    </li>
                    <li>
                        Der Vorsortierung häufig geschriebener Datensätze
                    </li>
                    <li>
                        Der Kompatibilität mit anderen O/R-Mappern
                    </li>
                </ol>

                <p>
                    d) Was drücken die Werte <b>precision</b> und <b>scale</b> der Annotation <code>@Column</code> aus?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Die Mindest- und Maximallänge zeichenartiger Felder
                    </li>
                    <li>
                        Wie genau eine Fremdschlüsselbeziehung spezifiziert ist
                    </li>
                    <li>
                        Die maximale Anzahl Ziffern einer Kommazahl sowie wie viele davon Nachkommastellen sind
                    </li>
                    <li>
                        Die Anzahl, wie oft ein Boolean auf <code>false</code> umschalten darf
                    </li>
                    <li>
                        Die Genauigkeit, mit der du diese Antworten liest
                    </li>
                    <li>
                        Das maximale Gesamtgewicht aller Entities in Kilogramm oder Pfund
                    </li>
                </ol>

                <p>
                    e) Wie kann der Name einer Tabelle oder eines Felds in der Datenbank überschrieben werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Mit der Annotation <code>@Name</code> vor der Klasse oder dem Feld
                    </li>
                    <li>
                        Mit dem Attribut <b>name</b> der Annotationen <code>@Table</code> und <code>@Column</code>
                    </li>
                    <li>
                        Mit der Annotation <code>@BeanName</code> innerhalb der rufenden EJBs
                    </li>
                </ol>

                <p>
                    f) Welche Vor- und Nachteile ergeben sich aus der Annotation <code>@Lob</code>?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Die dadurch gekennzeichneten Stringfelder können jede beliebige Größe annehmen, drücken
                        dafür aber die Performance nach unten.
                    </li>
                    <li>
                        Die dadurch gekennzeichneten Integerfelder können beliebig große Zahlen annehmen, dafür
                        kann nach ihnen nicht selektiert werden.
                    </li>
                    <li>
                        Man lobt den Entwickler für seine gute Arbeit, es gibt aber keine Annotation für <code>@Tadel</code>.
                    </li>
                </ol>

                <h2>Aufgabe 3.3: Fremdschlüsselbeziehungen</h2>

                <p>
                    a) Welche der folgenden Beziehungstypen können nicht mit JPA abgebildet werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        1:1-Beziehungen
                    </li>
                    <li>
                        1:n-Beziehungen
                    </li>
                    <li>
                        n:1-Beziehungen
                    </li>
                    <li>
                        n:m-Beziehungen
                    </li>
                </ol>

                <p>
                    b) Wie werden 16:9-Beziehungen mit der Java Persistence API abgebildet?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Gar nicht, du warst wohl zu oft im Kino!
                    </li>
                    <li>
                        Mit der Annotation <code>@Widescreen</code>
                    </li>
                    <li>
                        Mit den Annotationen <code>@HdReady</code> und <code>@FullHD</code>
                    </li>
                </ol>

                <p>
                    c) Was sind bidirektionale Beziehungen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Einfache Beziehungen von einer Entität zu einer anderen
                    </li>
                    <li>
                        Beziehungen mit mehr als einer Zielentität
                    </li>
                    <li>
                        Beziehungen in beide Richtungen zwischen zwei Entitäten
                    </li>
                    <li>
                        Beziehungen mit mehr als einer Startidentität
                    </li>
                </ol>

                <p>
                    d) Welche Anpassung muss bei einer unidirektionalen Beziehungen an der Zielentität vorgenommen werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Keine, das ist nur bei bidirektionalen Beziehungen erforderlich.
                    </li>
                    <li>
                        Es muss eine passende Annotation mit der Eigenschaft <b>mappedBy</b> hinzugefügt werden.
                    </li>
                    <li>
                        Es muss eine gegenläufige Annotation ohne besondere Eigenschaften hinzugefügt werden.
                    </li>
                    <li>
                        Es muss mit <code>@ForeignKey</code> ein rückwärtsgerichteter Fremdschlüssel hinzugefügt werden.
                    </li>
                </ol>

                <p>
                    e) Und welche Anpassung muss bei einer bidirektionalen Beziehung an der Zielentität vorgenommen werden?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Keine, das ist nur bei unidirektionalen Beziehungen erforderlich.
                    </li>
                    <li>
                        Es muss eine passende Annotation mit der Eigenschaft <b>mappedBy</b> hinzugefügt werden.
                    </li>
                    <li>
                        Es muss eine gegenläufige Annotation ohne besondere Eigenschaften hinzugefügt werden.
                    </li>
                    <li>
                        Es muss mit <code>@ForeignKey</code> ein rückwärtsgerichteter Fremdschlüssel hinzugefügt werden.
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>Lösung:</b> <br />
                        Aufgabe 3.1: 2, 1, 2, 3 <br />
                        Aufgabe 3.2: 4, 5, 1, 3, 2, 1 <br />
                        Aufgabe 3.3: alle, 1, 3, 1, 2
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Hier dann noch ein paar Wiederholungsfragen, um auch die weniger häufigen Annotationen
                    abzuklopfen. Wenn du die kannst, bist du echt gut. 🥉
                </p>
            </aside>
        </section>

        <!--
            ==============================
            DATEN LESEN, SCHREIBEN, ÄNDERN
            ==============================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Daten lesen, schreiben, ändern</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Ohne Persistence Unit geht es nicht</h1>
            <article>
                <ul class="dhbw-carousel-links">
                    <li>
                        <a href="#persistence-unit-carousel" role="button" data-slide="next">Nächstes Bild</a>
                    </li>
                    <li>
                        <a href="#persistence-unit-carousel" role="button" data-slide="prev">Vorheriges Bild</a>
                    </li>
                    <li>
                        <a href="#persistence-unit-carousel" role="button" data-slide-to="0">Nochmal von vorne</a>
                    </li>
                </ul>
                <div id="persistence-unit-carousel" class="carousel slide" style="margin-bottom: 1em;" data-interval="false">
                    <div class="carousel-inner">
                        <div class="carousel-item img-thumbnail active">
                            <p>
                                Angenommen, du hast gerade ein neues Webprojekt in Netbeans erstellt.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-01.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Dann sieht das Projekt am Anfang natürlich noch ziemlich leer aus. Vor allem fehlt uns eine
                                <b>Persistence Unit</b>, die definiert, mit welcher Datenbank wir arbeiten.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-02.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Per Rechtsklick auf den Namen des Projekts lässt sie sich ganz einfach anlegen.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-03.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Im darauf folgenden Fenster musst du die folgenden Werte übernehmen, damit hinterher alles
                                so läuft, wie es soll. 🚶🏿
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-04.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Im Menü links taucht nun die Datei <tt>persistence.xml</tt> auf. Netbeans bietet hierfür
                                auch gleich einen praktischen Editor.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-05.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                So sieht der XML-Code der Datei aus. Der grafische Editor ist aber einfacher zu bedienen.
                            </p>
                            <img class="active d-block w-100" src="persistence-unit-06.png" />
                        </div>
                        <div class="carousel-item img-thumbnail">
                            <p>
                                Jetzt kann es los gehen. 🏁 Lass uns ein paar Daten selektieren.
                            </p>
                            <img class="active d-block w-25 m-auto" src="../../finish.svg" />
                        </div>
                    </div>
                </div>

                <p>
                    <small>
                        <small>
                            Bildnachweis für das Endesymbol: <a href="https://pixabay.com/en/symbol-gui-internet-internet-page-2480163/" target="_blank">Pixabay: janf93</a>
                        </small>
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Bisher sind wir immer davon ausgegangen, dass der Applikationsserver mit nur einer Datenbank verbunden ist und daher
                    einfach alles seinen richtigen Weg läuft. Das muss aber nicht so sein, ein Applikationsserver kann durchaus mit mehreren
                    Datenbanken verbunden sein, so dass jede darauf laufende Anwendung seine eigene Datenbank nutzt. Ja, das ist sogar der
                    Normalfall, selbst wenn die Datenbanken alle vom selben Datenbankserver verwaltet werden.¹ 🐄
                </p>
                <p>
                    <small>
                        ¹ Typische Datenbankserver wie <a href="https://mariadb.org/" target="_blank">MariaDB</a> oder
                        <a href="https://www.postgresql.org/" target="_blank">PostgreSQL</a> können mehrere, logische Datenbanken verwalten,
                        um somit mehrere Anwendungen sauber zu isolieren. Dadurch ist es dann auch kein Problem, wenn zwei Datenbanken
                        gleichnamige Tabellen beinhalten.
                    </small>
                </p>
                <p>
                    Aus diesem Grund benötigt jede Java-EE-Anwendung mindestens eine sogenannte <b>Persistence Unit</b>, die definiert,
                    welche Datenbank sie verwendet. Technisch gesehen bedeutet das, dass Anwendung eine Datei mit dem Namen
                    <tt>persistence.xml</tt> beinhalten muss, in der mindestens eine solche Persistence Unit definiert ist.
                    Doch anstatt jetzt die XML-Syntax zu erklären, zeigen dir die Bilder auf der Folie, wie die Datei mit Netbeans
                    angelegt und bearbeitet werden kann.
                </p>
                <p>
                    Die Felder im Anlagewizard haben dabei folgende Bedeutung:
                </p>
                <ul>
                    <li>
                        <b>Persistence Unit Name:</b> Name der Persistence Unit, unter der sie im Quellcode angesprochen wird.
                        Der Name sollte daher kurz und einprägsam sein, auch wenn er bei vorliegen von nur einer Persistence
                        Unit nicht weiter benötigt wird.
                    </li>
                    <li>
                        <b>Persistence Provider:</b> Die verwendete O/R-Mapper-Implementierung. Die Vorauswahl <i>EclipseLink</i>
                        geht völlig in Ordnung. Wie an den meisten Stellen erlaubt Java eben, dass es mehrere Implementierungen
                        zu einer API gibt.
                    </li>
                    <li>
                        <b>Data Source:</b> Der Name der Datenbank, so wie sie im Applikationsserver konfiguriert wurde. Im
                        Echtbetrieb müssten wir die Konfiguration erst anlegen, für die Übungen reicht aber die von Netbeans
                        bereitgestellte Konfiguration <tt>jdbc/__default</tt>.
                    </li>
                    <li>
                        <b>Table Generation Strategy:</b> Wer legt die Tabellen an und wie oft geschieht dies? Legst du die
                        Tabellen selbst an (None) oder sollen sie beim ersten Start der Anwendung automatisch angelegt werden?
                        Falls ja, soll dies nur einmalig erfolgen (Create) oder bei jedem Start der Anwendung erneut (Drop and Create)?
                    </li>
                </ul>
                <p>
                    Für die Übungen bietet es sich an, als Anlagestrategie <i>Create</i> zu wählen, damit die Inhalte der Tabellen
                    nicht verloren gehen. Jedoch musst du dann hin und wieder die Tabellen von Hand löschen, da nicht jede Änderung
                    an den Persistence Entities immer in den Tabellen nachgezogen wird. Komischen Fehlermeldungen beim Lesen oder
                    Schreiben, beispielsweise dass die Tabelle ein bestimmtes Feld nicht enthält, können hier ein Hinweis sein. 🔔
                </p>
            </aside>
        </section>

        <section>
            <h1>Der Entity Manager stellt sich vor</h1>
            <article>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🗄️
                        </td>
                        <td>
                            Sämtliche Datenbankzugriffe werden von einem <code>EntityManager</code>-Objekt durchgeführt.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🗄️
                        </td>
                        <td>
                            Dieses Objekt stellt aus Anwendungssicht den O/R-Mapper dar, der Daten lesen und schreiben kann.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🗄️
                        </td>
                        <td>
                            Mit der Annotation <code>@PersistenceContext</code> können wir uns das Objekt geben lassen.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🗄️
                        </td>
                        <td>
                            Die Annotation funktioniert in Serlvets und in EJBs, sollte aber nur in EJBs verwendet werden.
                        </td>
                    </tr>
                </table>

                <source-code language="java">
                    @Stateless
                    public class KinoBean {
                        @PersistenceContext
                        EntityManager em;
                        …
                    }
                </source-code>

                <div style="margin-top: 1em;">
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "entitymanager-methoden-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#entitymanager-methoden"
                                role          = "tab"
                                aria-controls = "entitymanager-methoden"
                                aria-expanded = "true"
                            >
                                Häufig benötigte Methoden
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "entitymanager-beispiel-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#entitymanager-beispiel"
                                role          = "tab"
                                aria-controls = "entitymanager-beispiel"
                            >
                                Beispiel
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Häufig benötigte Methoden -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "entitymanager-methoden"
                            role            = "tabpanel"
                            aria-labelledby = "entitymanager-methoden-tab"
                        >
                            <p>
                                <src-code language="java">
                                    &lt;T&gt; T find(Class&lt;T&gt; entityClass, Object primaryKey)
                                </src-code>
                                <br />
                                Auslesen eines Objekts anhand seines Primärschlüssels
                            </p>

                            <p>
                                <src-code language="java">
                                    void persist(Object entity)
                                </src-code>
                                <br />
                                Speichern eines <b>neuen</b> Datensatzes.
                            </p>

                            <p>
                                <src-code language="java">
                                    &lt;T&gt; T merge(&lt;T&gt; entity)
                                </src-code>
                                <br />
                                Aktualisieren eines <b>vorhandenen</b> Datensatzes.
                            </p>

                            <p>
                                <src-code language="java">
                                    void remove(Object entity)
                                </src-code>
                                <br />
                                Löschen eines vorhandenen Datensatzes.
                            </p>

                            <hr />

                            <p>
                                <src-code language="java">
                                    Query createQuery(String qlString)
                                </src-code>
                                <br />
                                Erzeugen einer neuen Datenbankanfrage (vgl. <a href="#18">nächste Folie</a>)
                            </p>
                        </div>
                        <!-- Beispiel -->
                        <div
                            class           = "tab-pane fade"
                            id              = "entitymanager-beispiel"
                            role            = "tabpanel"
                            aria-labelledby = "entitymanager-beispiel-tab"
                        >
                            <source-code language="java">
                                @Stateless
                                public class MitarbeiterBean {
                                    @PersistenceContext
                                    EntityManager em;

                                    /**
                                     * Auslesen eines einzelnen Mitarbeiters
                                     */
                                    public Mitarbeiter findById(long id) {
                                        return this.em.find(Mitarbeiter.class, id);
                                    }

                                    /**
                                     * Speichern eines neuen Mitarbeiters und den gespeicherten
                                     * Satz zurückgeben, damit der Aufrufer die ID erfährt.
                                     */
                                    public Mitarbeiter saveNew(Mitarbeiter mitarbeiter) {
                                        em.persist(mitarbeiter);
                                        return em.merge(mitarbeiter);
                                    }

                                    /**
                                     * Änderungen an einem vorhandenen Mitarbeiter speichern.
                                     */
                                    public Mitarbeiter update(Mitarbeiter mitarbeiter) {
                                        return em.merge(mitarbeiter);
                                    }

                                    /**
                                     * Wie lange arbeiten Sie schon hier, morgen nicht mehr
                                     * mitgerechnet? 🙇
                                     */
                                    public void delete(Mitarbeiter mitarbeiter) {
                                        return em.remove(mitarbeiter);
                                    }
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    <i>Guten Tag, Manager mein Name. Entity Manager. Ich bediene Sie heute. Was würden Sie denn gerne bestellen?
                    Ah, einmal den Film Nummer 7, sehr gern. </i> So oder so ähnlich würde es klingen, wenn wir uns wirklich mit
                    Java unterhalten könnten. 📞 Denn der Entity Manager ist das Objekt, das uns die ganze schreckliche
                    JDBC-Programmierung aus <a href="#3">Folie 3</a> vom Hals hält. Oder anders gesagt: Er ist der O/R-Mapper,
                    der weiß, wie man Javaobjekte zu Tabellenzeilen konvertiert und umgekehrt. ↕️
                </p>
                <p>
                    Doch bevor es losgehen kann, brauchen wir erst mal eine Referenz, die wir uns innerhalb jedes Servlets und
                    jeder Enterprise Java Bean mit folgenden Zeilen besorgen können. Innerhalb eines Servlets sollte das aber
                    eigentlich vermieden werden.
                </p>
                <source-code language="java">
                    @Stateless
                    public class MisterBean {
                        @PersistenceContext
                        EntityManager em;
                        …
                    }
                </source-code>
                <p>
                    Ist das einmal geschafft, können wir die auf der Folie dargestellten Methoden verwenden, um Datensätze
                    auszulesen, zu schreiben oder zu löschen. Es ist wirklich ziemlich einfach, wie das folgende Beispiel zeigt:
                </p>
                <source-code language="java">
                    @Stateless
                    public class MitarbeiterBean {
                        @PersistenceContext
                        EntityManager em;

                        /**
                         * Auslesen eines einzelnen Mitarbeiters
                         */
                        public Mitarbeiter findById(long id) {
                            // Sucht einen Mitarbeiter anhand seiner Schlüsselwerte
                            return this.em.find(Mitarbeiter.class, id);
                        }

                        /**
                         * Gehaltserhöhung für einen Mitarbeiter vornhehmen
                         */
                        public Mitarbeiter gehaltErhoehen(long id, long faktor) {
                            // Auslesen des Mitarbeiters
                            Mitarbeiter ma = this.em.find(Mitarbeiter.class, id);

                            // Abbruch, wenn er nicht gefunden wurde
                            if (ma == null) return;

                            // Neues Gehalt berechnen
                            ma.setGehalt(ma.getGehalt() * faktor);

                            // Mitarbeiter speichern
                            return this.em.merge(ma);
                        }

                        /**
                         * Neuen Mitarbeiter anlegen
                         */
                        public Mitarbeiter saveNew(Mitarbeiter ma) {
                            // Neuen Mitarbeiter speichern
                            this.em.persist(ma);

                            // Mitarbeiter aktualisieren, so dass das ID-Feld
                            // gefüllt ist
                            return this.em.merge(ma);
                        }
                    }
                </source-code>
                <p>
                    Wollten wir nun einen neuen Mitarbeiter anlegen, müssten wir nur eine neues Objekt erzeugen,
                    es mit Werten füllen und die Methode <code>saveNew</code> der obigen EJB aufrufen. Ungefähr so:
                </p>
                <source-code language="java">
                    @WebServet(urlPatterns={"/neuer-mitarbeiter/"})
                    public class NeuerMitarbeiterServlet extends HttpServlet {
                        @EJB
                        MitarbeiterBean mitarbeiterBean

                        public void doGet(…) {
                            // Neuen Mitarbeiter erzeugen
                            Mitarbeiter ma = new Mitarbeiter();
                            ma.setVorname("Frank");
                            ma.setNachname("Columbo");
                            ma.setGehalt(2500.00);

                            // Datensatz speichern
                            ma = this.mitarbeiterBean.saveNew(ma);
                        }
                    }
                </source-code>
                <p>
                    Den Rest übernimmt dann der Entity Manager für uns, ohne dass wir auch nur in die Nähe eines
                    SQL-Statements kommen. Das ist wirklich klasse! 💫
                </p>
            </aside>
        </section>

        <section>
            <h1>Komplexe Anfragen formulieren</h1>
            <article>
                <div class="container-fluid">
                    <!-- Bilder -->
                    <div class="row">
                        <div class="col-md">
                            <img src="jql1.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                            Jede Datenbank hat ihren eigenen SQL-Dialekt, was oftmals ziemlich verwirrend sein kann.
                        </div>
                        <div class="col-md">
                            <img src="jql2.jpg" alt="" class="d-block img-thumbnail" style="width: 100%;" />
                            JQL hilft uns deshalb und definiert neutrale Anweisungen, die immer funktionieren.
                        </div>
                    </div>

                    <!-- Beispielselektionen -->
                    <div class="row">
                        <div class="col-md">
                            <p class="dhbw-lightblue">
                                Selektion mit Parametern in SQL:
                            </p>
                            <source-code language="sql">
                                SELECT * FROM Film
                                    WHERE filmname = ?
                                      AND jahr BETWEEN ? AND ?
                                      AND genre = ?
                            </source-code>
                        </div>
                        <div class="col-md">
                            <p class="dhbw-lightblue">
                                Selektion mit Parametern in JQL:
                            </p>
                            <source-code language="sql">
                                SELECT f FROM Film f
                                    WHERE f.name = :name
                                      AND f.jahr BETWEEN :von AND :bis
                                      AND f.genre = :genre
                            </source-code>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md">
                            <hr />
                            <h4 class="dhbw-lightblue" style="margin-bottom: 1em;">Vollständiges Beispiel</h4>

                            <source-code language="java">
                                @Statless
                                public class JqlSelectBeispiel {
                                    @PersistenceContext
                                    EntityManager em;

                                    public List&lt;Film&gt; sucheFilm(String name, int vonJahr, int bisJahr, Genre genre) {
                                            return em.createQuery(
                                                        "SELECT f FROM Film f"
                                                      + "    WHERE f.name LIKE :name"
                                                      + "      AND f.jahr BETWEEN :von AND :bis"
                                                      + "      AND g.genre = :genre"
                                                     )
                                                     .setParameter("name", name)
                                                     .setParameter("von", vonJahr)
                                                     .setParameter("bis", bisJahr)
                                                     .setParameter("genre", genre)
                                                     .getResultList();
                                        }
                                }
                            </source-code>
                        </div>
                    </div>

                    <!-- Bildnachweise -->
                    <div class="row">
                        <div class="col-md">
                            <small>
                                <small>
                                    Bildnachweise:
                                    <a href="https://pixabay.com/de/kinder-m%C3%A4dchen-wei%C3%9F-kind-attraktiv-3041378/" target="_blank">Pixabay: Khamkhor</a>,
                                    <a href="https://pixabay.com/de/im-freien-kinder-natur-hund-3067805/" target="_blank">Pixabay: tohidabbasy</a>
                                </small>
                            </small>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Manchmal macht es natürlich Sinn, nicht einfach nur einzelne Datensätze aus der Datenbank zu lesen
                    oder zu schreiben, sondern gleich mehrere Sätze auf einen Schlag. Zum Beispiel, wenn der Anwender
                    einen Suchbegriff eingibt und wir ihm eine Liste der möglichen Kandidaten zurückliefern wollen.
                    Oder wenn wir an tausenden Einträgen dieselbe Änderung vornehmen wollten. Da wäre es natürlich pure
                    Zeitverschwendung, jeden Datensatz einzeln zu lesen, zu verändern und dann zu speichern.
                </p>
                <p>
                    In diesem Fällen würde man normalerweise anfangen, auf den jeweiligen Anwendungsfall optimierte
                    SQL-Befehle zu verwenden, doch leider gibt es da ein Problem: Die SQL-Anweisungen unterscheiden sich
                    von Hersteller zu Hersteller. Zwar sind die meisten Statements im Kern normiert, jeder Hersteller
                    bietet aber eigene Spracherweiterungen, die nur mit seinen Produkten funktionieren. Komplexe
                    SQL-Anfragen können daher nur bedingt datenbankneutral formuliert werden. 🤦
                </p>
                <p>
                    Die Java Persistence API löst dieses Problem, indem sie eine eigene, an SQL angelehnte Query Language
                    namens <b>Java Persistence Query Language</b>, kurz JQL, zur Verfügung stellt und die so formulierten
                    Anfragen zur Laufzeit in herstellerspezifische SQL-Anweisungen umwandelt.
                    Auf <a href="https://en.wikibooks.org/wiki/Java_Persistence/JPQL" target="_blank">Wikibooks</a> gibt
                    es eine ziemlich umfangreiche Sammlung mit Beispielen. Hier sollen uns ein paar einfache Selektionen
                    genügen.
                </p>
                <p>
                    Ähnlich wie in SQL gibt es auch in JQL ein <code>SELECT</code>-Statement. Die Syntax ist allerdings
                    leicht anders. Hier siehst du gleich den vollen Aufruf, so wie die Anfrage an den Entity Manager
                    übergeben werden muss, um alle Ergebnisse zurück zu bekommen:
                </p>
                <source-code language="java">
                    @Statless
                    public class SelectBeispiel1 {
                        @PersistenceContext
                        EntityManager em;

                        public List&lt;Film&gt; sucheNameUndJahr(
                            String name, int vonJahr, int bisJahr) {

                                return em.createQuery(
                                            "SELECT f FROM Film f"
                                          + "  WHERE f.name LIKE :name"
                                          + "    AND f.jahr BETWEEN :von AND :bis"
                                         )
                                         .setParameter("name", name)
                                         .setParameter("von", vonJahr)
                                         .setParameter("bis", bisJahr)
                                         .getResultList();
                            }
                    }
                </source-code>
                <p>
                    Mit der Punktsyntax können sogar die Felder aus den Beziehungen abgefragt werden:
                </p>
                <source-code language="java">
                    @Statless
                    public class SelectBeispiel2 {
                        @PersistenceContext
                        EntityManager em;

                        public List&lt;Film&gt; filmeAnWochentag(Wochentag wochentag) {
                            return em.createQuery(
                                        "SELECT f FROM Film f"
                                      + "  WHERE f.vorfuehrungen.wochentag = :wochentag"
                                     )
                                     .setParameter("wochentag", wochentag)
                                     .getResultList();
                        }
                    }
                </source-code>
                <p>
                    Und so weiter und sofort. Schau dir den Link auf
                    <a href="https://en.wikibooks.org/wiki/Java_Persistence/JPQL" target="_blank">Wikibooks</a>
                    an, wenn du weitere Beispiele insbesondere auch zum Aktualisieren und Löschen sehen willst.
                    <span style="font-weight: bold; color: darkgreen; text-shadow: 1px 1px 1px rgba(0,0,0,0.5);">✅</span>
                </p>
            </aside>
        </section>

        <section>
            <h1>Sinnvolle Methoden für die EJBs</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "ejb-methoden-uebersicht-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#ejb-methoden-uebersicht"
                                role          = "tab"
                                aria-controls = "ejb-methoden-uebersicht"
                                aria-expanded = "true"
                            >
                                Übersicht
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "ejb-methoden-copypaste-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#ejb-methoden-copypaste"
                                role          = "tab"
                                aria-controls = "ejb-methoden-copypaste"
                            >
                                Copy&amp;Paste-Version
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "ejb-methoden-vererbung-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#ejb-methoden-vererbung"
                                role          = "tab"
                                aria-controls = "ejb-methoden-vererbung"
                            >
                                Vererbung und Generics
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Übersicht -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "ejb-methoden-uebersicht"
                            role            = "tabpanel"
                            aria-labelledby = "ejb-methoden-uebersicht-tab"
                        >
                            <p>
                                Gute Enterprise Java Beans zu definieren, ist oftmals gar nicht so leicht. Für viele Anwendungen
                                reicht es jedoch, wenn du je Entity eine Bean mit folgenden Methoden anbietest. Dadurch können
                                die Clients ganz einfach Dantesätze suchen, anlegen, ändern und löschen. Die Typen <code>Entity</code>
                                und <code>EntityId</code> musst du natürlich durch eigene Klassen ersetzen.
                            </p>

                            <div style="display: flex; justify-content: center;">
                                <ul>
                                    <li>
                                        <src-code language="java">Entity findById(EntityId id)</src-code>
                                    </li>
                                    <li>
                                        <src-code language="java">List&lt;Entity&gt; findByXYZ(…)</src-code>
                                    </li>
                                    <li>
                                        <src-code language="java">List&lt;Entity&gt; findAll()</src-code>
                                    </li>
                                </ul>
                                <ul>
                                    <li>
                                        <src-code language="java">Entity saveNew(Entity entity)</src-code>
                                    </li>
                                    <li>
                                        <src-code language="java">Entity update(Entity entity)</src-code>
                                    </li>
                                    <li>
                                        <src-code language="java">void delete(Entity entity)</src-code>
                                    </li>
                                </ul>
                            </div>

                            <hr />

                            <h4 class="dhbw-lightblue">Vorhandene Datensätze finden</h4>
                            <p>
                                <src-code language="java">Entity findById(EntityId id)</src-code>
                                <br />
                                Auslesen eines einzelnen Datensatzes anhand seiner ID
                            </p>
                            <p>
                                <src-code language="java">List&lt;Entity&gt; findByXYZ(…)</src-code>
                                <br />
                                Spezielle Suchmethoden nach Datensätzen anhand irgendwelcher Kriterien
                            </p>
                            <p>
                                <src-code language="java">List&lt;Entity&gt; findAll()</src-code>
                                <br />
                                Einache Methode zum Auslesen aller Datensätze (nur, wenn es nicht zu viele werden können!)
                            </p>

                            <hr />

                            <h4 class="dhbw-lightblue">Datensätze speichern, ändern, löschen</h4>
                            <p>
                                <src-code language="java">Entity saveNew(Entity entity)</src-code>
                                <br />
                                Speichern eines komplett neuen Datensatzes, des es zuvor nocht nicht gab
                            </p>
                            <p>
                                <src-code language="java">Entity update(Entity entity)</src-code>
                                <br />
                                Änderungen an einem zuvor ausgelesenen Datensatz speichern
                            </p>
                            <p>
                                <src-code language="java">void delete(Entity entity)</src-code>
                                <br />
                                Löschen eines zuvor ausgelesenen Datensatzes
                            </p>

                            <hr />

                            <p>
                                Darüber hinaus kannst du natürlich noch beliebige, weitere Methoden definieren.
                            </p>
                        </div>
                        <!-- Copy&Paste-Version -->
                        <div
                            class           = "tab-pane fade"
                            id              = "ejb-methoden-copypaste"
                            role            = "tabpanel"
                            aria-labelledby = "ejb-methoden-copypaste-tab"
                        >
                            <p>
                                Das nachfolgende Beispiel zeigt für jede Methode eine einfache Implementierung.
                            </p>
                            <source-code language="java">
                                @Stateless
                                public class StandortBean {
                                    @PersistenceContext
                                    EntityManager em;

                                    //
                                    // Vorhandene Datensätze finden
                                    //
                                    public Standort findById(long id) {
                                        return em.find(Standort.class, id);
                                    }

                                    public List&lt;Standort&gt; findByOrt(String ort) {
                                        return em.createQuery("SELECT s FROM Standort s WHERE s.adresse.ort = :ort")
                                                 .setParameter("ort", ort)
                                                 .getResultList();
                                    }

                                    public List&lt;Standort&gt; findAll() {
                                        return em.createQuery("SELECT s FROM Standort s")
                                                 .getResultList();
                                    }

                                    //
                                    // Datensätze speichern, ändern, löschen
                                    //
                                    public Standort saveNew(Standort standort) {
                                        em.persist(standort);
                                        return em.merge(standort);
                                    }

                                    public Standort update(Standort standort) {
                                        return em.merge(standort);
                                    }

                                    public void delete(Standort standort) {
                                        em.remove(standort);
                                    }
                                }
                            </source-code>
                        </div>
                        <!-- Vererbung und Generics -->
                        <div
                            class           = "tab-pane fade"
                            id              = "ejb-methoden-vererbung"
                            role            = "tabpanel"
                            aria-labelledby = "ejb-methoden-vererbung-tab"
                        >
                            <p>
                                Ein wenig Zauberei ✨ mit Vererbung und Generics können dir helfen, dass du nicht immer und immer
                                wieder dieselben Methoden ausprogrammieren musst. Denn das ganze Lesen, Schreiben und Löschen
                                einzelner Entities unterscheidet sich doch im Grunde genommen nur durch den Namen der Entity.
                                So könnte die Basisklasse daher aussehen:
                            </p>
                            <source-code language="java">
                                /**
                                 * Abstrakte Basisklasse für EJBs, die einfach nur Standardmethoden zum Lesen
                                 * und Schreiben eines Entity-Typs bietet.
                                 *
                                 * @param &lt;Entity&gt; Basisklasse der Entität
                                 * @param &lt;EntityId&gt; Datentyp oder Klasse für die Schlüsselwerte
                                 */
                                public abstract class EntityBean&lt;Entity, EntityId&gt; {

                                    @PersistenceContext
                                    EntityManager em;

                                    private final Class&lt;Entity&gt; entityClass;

                                    public EntityBean(Class&lt;Entity&gt; entityClass) {
                                        this.entityClass = entityClass;
                                    }

                                    //
                                    // Vorhandene Datensätze finden
                                    //
                                    public Entity findById(EntityId id) {
                                        return em.find(entityClass, id);
                                    }

                                    public List&lt;Entity&gt; findAll() {
                                        String select = "SELECT s FROM $C s".replace("$C", this.entityClass.getName());
                                        return em.createQuery(select).getResultList();
                                    }

                                    //
                                    // Datensätze speichern, ändern, löschen
                                    //
                                    public Entity saveNew(Entity entity) {
                                        em.persist(entity);
                                        return em.merge(entity);
                                    }

                                    public Entity update(Entity entity) {
                                        return em.merge(entity);
                                    }

                                    public void delete(Entity entity) {
                                        em.remove(entity);
                                    }
                                }
                            </source-code>
                            <p>
                                Okay, durch die Generics ist die Klasse nicht ganz so einfach. Eine neue EJB für eine bestimmte
                                Entity zu definieren, wird damit aber echt zum Kinderspiel. 🎎 <code>Vorfuehrung</code> ist hier
                                der Name der Entität und <code>Long</code> der Datentyp ihres Primärschlüssels.
                            </p>
                            <source-code language="java">
                                @Stateless
                                public class VorfuehrungBean extends EntityBean&lt;Vorfuehrung, Long&gt; {

                                    public VorfuehrungBean() {
                                        super(Vorfuehrung.class);
                                    }

                                    public List&lt;Vorfuehrung&gt; findByWochentag(Wochentag wochentag) {
                                        return em.createQuery("SELECT v FROM Vorfuehrung v WHERE v.wochentag = :wochentag")
                                                 .setParameter("wochentag", wochentag)
                                                 .getResultList();
                                    }

                                    // Alle anderen Methoden sind automatisch vorhanden!
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Enterprise Java Beans beinhalten die fachliche Logik einer Anwendung und stellen den Clients
                    daher Services zur Verfügung, die diese aufrufen können. Diesen Satz haben wir jetzt schon so
                    oft gehöhrt. Doch wonach soll man die EJBs unterscheiden und welche Methoden sollen sie
                    besitzen? 😓 Das ist gar nicht so leicht zu beantworten, wenn man noch nicht so viel Erfahrung
                    mit Java&nbsp;EE oder ähnlichen Plattformen hat und ein gutes Stück weit lässt sich auch gar
                    keine allgemeingültige Antwort auf diese Frage finden. Dennoch hat es sich in der Praxis bewährt,
                    einen gewissen Grundstock an EJBs anzubieten, der sich einfach an den vorhandenen Persistence
                    Entities orientiert.  Die Überlegung dahinter ist, dass sehr viele Benutzeroberflächen und
                    Clients eigentlich nur folgende Dinge tun:
                </p>
                <table style="margin-bottom: 1em;">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            📄
                        </td>
                        <td>
                            Sie zeigen eine Liste aller Datensätze an.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🔎
                        </td>
                        <td>
                            Sie erlauben die Suche nach Datensätzen anhand einzelner Felder.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🖊️
                        </td>
                        <td>
                            Sie besitzen ein Formular zum Anlegen und Bearbeiten von Datensätzen.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em;">
                            🗑️
                        </td>
                        <td>
                            Sie löschen einzelne Datensätze.
                        </td>
                    </tr>
                </table>
                <p>
                    Also genau die vier CRUD-Operationen aller datenzentrischer Anwendungen: Create, Read, Update
                    und Delete. Wie wir schon gesehen haben, lassen sich diese Operationen danke dem Entity Manager
                    relativ einfach ausprogrammieren. Unser Vorschlag ist daher, zu jeder Persistence Entity eine
                    gleichlautende EJB zu entwickeln, welche die auf der Folie gezeigten Methoden beinhaltet:
                </p>
                <ul>
                    <li>
                        <src-code language="java">Entity findById(EntityId id)</src-code>
                    </li>
                    <li>
                        <src-code language="java">List&lt;Entity&gt; findByXYZ(…)</src-code>
                    </li>
                    <li>
                        <src-code language="java">List&lt;Entity&gt; findAll()</src-code>
                    </li>
                    <li>
                        <src-code language="java">Entity saveNew(Entity entity)</src-code>
                    </li>
                    <li>
                        <src-code language="java">Entity update(Entity entity)</src-code>
                    </li>
                    <li>
                        <src-code language="java">void delete(Entity entity)</src-code>
                    </li>
                </ul>
                <p>
                    Die Folie zeigt dabei zwei Möglichkeiten sie auszuprogrammieren. Einmal durch Copy&amp;Paste für
                    jede einzelne EJB oder mit etwas Zauberei als abstrakte Basisklasse. Letzterer Weg spart natürlich
                    eine ganze Menge Schreibarbeit.
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 4: Geht eine EJB ins Kino</h1>
            <article>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "aufgabe4-aufgabe-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#aufgabe4-aufgabe"
                                role          = "tab"
                                aria-controls = "aufgabe4-aufgabe"
                                aria-expanded = "true"
                            >
                                Aufgabe
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe4-loesung1-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe4-loesung1"
                                role          = "tab"
                                aria-controls = "aufgabe4-loesung1"
                            >
                                Lösung 1
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "aufgabe4-loesung2-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#aufgabe4-loesung2"
                                role          = "tab"
                                aria-controls = "aufgabe4-loesung2"
                            >
                                Lösung 2
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Aufgabe -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "aufgabe4-aufgabe"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe4-aufgabe-tab"
                        >
                            <p>
                                Nimm die beiden Entitäten <i>Film</i> und <i>Mitwirkender</i> von <a href="#aufgabe2">Aufgabe 2</a>
                                und schreibe je eine Enterprise Java Bean, mit folgenden Methoden.
                            </p>

                            <h4 class="dhbw-lightblue">Klasse FilmBean</h4>
                            <ul>
                                <li>
                                    <src-code language="java">Film findById(long id)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">List&lt;Film&gt; findByJahr(int jahr)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">List&lt;Film&gt; findAll()</src-code>
                                </li>
                                <li>
                                    <src-code language="java">Film saveNew(Film film)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">Film update(Film film)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">void delete(Film film)</src-code>
                                </li>
                            </ul>

                            <h4 class="dhbw-lightblue">Klasse MitwirkenderBean</h4>
                            <ul>
                                <li>
                                    <src-code language="java">Mitwirkender findById(long id)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">List&lt;Mitwirkender&gt; findAll()</src-code>
                                </li>
                                <li>
                                    <src-code language="java">Mitwirkender saveNew(Mitwirkender mitwirkender)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">Mitwirkender update(Mitwirkender mitwirkender)</src-code>
                                </li>
                                <li>
                                    <src-code language="java">void delete(Mitwirkender mitwirkender)</src-code>
                                </li>
                            </ul>

                            <p>
                                Programmiere die beiden Klassen erst komplett von Hand aus, bevor du eine zweite Version auf
                                Grundlage der eben gezeigten, abstrakten <a href="#19">EntityBean</a> schreibst.
                            </p>
                        </div>
                        <!-- Lösung 1 -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe4-loesung1"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe4-loesung1-tab"
                        >
                            <p>
                                Hier die Musterlösung für die Version mit Copy&amp;Paste.
                            </p>
                            <source-code language="java">
                                @Stateless
                                public class FilmBean {
                                    @PersistenceContext
                                    EntityManager em;

                                    //
                                    // Vorhandene Datensätze finden
                                    //
                                    public Standort findById(long id) {
                                        return em.find(Film.class, id);
                                    }

                                    public List&lt;Film&gt; findByJahr(int jahr) {
                                        return em.createQuery("SELECT f FROM Film f WHERE f.jahr = :jahr")
                                                 .setParameter("jahr", jahr)
                                                 .getResultList();
                                    }

                                    public List&lt;Film&gt; findAll() {
                                        return em.createQuery("SELECT f FROM Film f")
                                                 .getResultList();
                                    }

                                    //
                                    // Datensätze speichern, ändern, löschen
                                    //
                                    public Film saveNew(Film film) {
                                        em.persist(film);
                                        return em.merge(film);
                                    }

                                    public Film update(Film film) {
                                        return em.merge(film);
                                    }

                                    public void delete(Film film) {
                                        em.remove(film);
                                    }
                                }

                                @Stateless
                                public class MitwirkenderBean {
                                    @PersistenceContext
                                    EntityManager em;

                                    //
                                    // Vorhandene Datensätze finden
                                    //
                                    public Mitwirkender findById(long id) {
                                        return em.find(Mitwirkender.class, id);
                                    }

                                    public List&lt;Mitwirkender&gt; findAll() {
                                        return em.createQuery("SELECT m FROM Mitwirkender m")
                                                 .getResultList();
                                    }

                                    //
                                    // Datensätze speichern, ändern, löschen
                                    //
                                    public Mitwirkender saveNew(Mitwirkender mitwirkender) {
                                        em.persist(mitwirkender);
                                        return em.merge(mitwirkender);
                                    }

                                    public Mitwirkender update(Mitwirkender mitwirkender) {
                                        return em.merge(mitwirkender);
                                    }

                                    public void delete(Mitwirkender mitwirkender) {
                                        em.remove(mitwirkender);
                                    }
                                }
                            </source-code>
                        </div>
                        <!-- Lösung 2 -->
                        <div
                            class           = "tab-pane fade"
                            id              = "aufgabe4-loesung2"
                            role            = "tabpanel"
                            aria-labelledby = "aufgabe4-loesung2-tab"
                        >
                            <p>
                                Und hier die vereinfachte Version auf Basis unserer selbst-entworfenen <a href="#19">EntityBean</a>.
                            </p>
                            <source-code language="java">
                                @Stateless
                                public class FilmBean extends EntityBean&lt;Film, Long&gt; {
                                    @PersistenceContext
                                    EntityManager em;

                                    public FilmBean {
                                        super(Film.class);
                                    }

                                    public List&lt;Film&gt; findByJahr(int jahr) {
                                        return em.createQuery("SELECT f FROM Film f WHERE f.jahr = :jahr")
                                                 .setParameter("jahr", jahr)
                                                 .getResultList();
                                    }
                                }

                                @Stateless
                                public class MitwirkenderBean extends EntityBean&lt;Mitwirkender, Long&gt; {

                                    public MitwirkenderBean {
                                        super(Mitwirkender.class);
                                    }
                                }
                            </source-code>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <p>
                    Hier kannst du das eben gelernte gleich praktisch Anwenden, indem du ein paar Enterprise
                    Java Beans zum Lesen und Schreiben von Datensätzen definierst. Gerne in Netbeans, wenn du
                    willst aber auch gerne einfach auf Papier. 📃
                </p>
                <img src="../../github_atom.png" class="img-fluid d-block"/>
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://atom.io/" target="_blank">Atom Webseite</a>
                    </small>
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 5: Ein kleines Entity-Manager-Quiz</h1>
            <article>
                <p>
                    a) Was ist eine Persistence Unit?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Ein alter Name für Persistence Entities
                    </li>
                    <li>
                        Eine Maßeinheit für die Dauer der Speicherung
                    </li>
                    <li>
                        Eine Konfiguration der zu nutzenden Datenbank
                    </li>
                </ol>

                <p>
                    b) Wie kannst du eine Referenz auf den Entity Manager bekommen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <source-code language="java">
                            @EntityManager
                            PersistenceContext pc;
                        </source-code>
                    </li>
                    <li>
                        <source-code language="java">
                            @PersistenceContext
                            EntityManager em;
                        </source-code>
                    </li>
                    <li>
                        <source-code language="java">
                            @DataSource("jdbc/__default")
                            @EntityManager em;
                        </source-code>
                    </li>
                    <li>
                        <source-code language="java">
                            @PersistenceUnit
                            ObjectMapper om;
                        </source-code>
                    </li>
                </ol>

                <p>
                    c) Welche der folgenden Methoden bietet der Entity Manager für die üblichen CRUD-Operationen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        find(), persist(), update(), delete()
                    </li>
                    <li>
                        find(), persist(), merge(), remove()
                    </li>
                    <li>
                        select(), exist(), update(), delete()
                    </li>
                    <li>
                        find(), persist(), search(), complete()
                    </li>
                </ol>

                <p>
                    d) Welche Vorteile hat die Java Persistence Query Language gegenüber SQL?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Keine, da JQL nur eine spezieller SQL-Dialekt ist.
                    </li>
                    <li>
                        Die Selektionen laufen schneller als mit nativem SQL.
                    </li>
                    <li>
                        Es bietet eine über alle Datenbankhersteller einheitliche Syntax.
                    </li>
                </ol>

                <p>
                    e) Und welche Nachteile hat die Java Persistence Query Language gegenüber SQL?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        Es ist nicht ganz so schnellt wie natives SQL.
                    </li>
                    <li>
                        Es gibt kein <code>UPDATE</code> und <code>DELETE</code>.
                    </li>
                    <li>
                        Es funktioniert nicht mit jeder Datenbank.
                    </li>
                </ol>

                <p>
                    f) Welches ist keine gültige JQL-Anfrage?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <source-code language="sql">
                            SELECT * FROM Film f
                                WHERE f.name LIKE ?
                                  AND f.jahr BETWEEN ? AND ?
                        </source-code>
                    </li>
                    <li>
                        <source-code language="sql">
                            SELECT f FROM Film f
                                WHERE f.genre = :genre
                                  AND f.vorfuehrung.wochentag = :wochentag
                        </source-code>
                    </li>
                </ol>

                <p>
                    g) Welche der folgenden Methoden sollte die EJB zu einer Entity mindestens besitzen?
                </p>
                <ol class="dhbw-liste-mit-viel-text">
                    <li>
                        <src-code language="java">Entity findById(EntityId id)</src-code>
                    </li>
                    <li>
                        <src-code language="java">List&lt;Entity&gt; findByXYZ(…)</src-code>
                    </li>
                    <li>
                        <src-code language="java">List&lt;Entity&gt; findAll()</src-code>
                    </li>
                    <li>
                        <src-code language="java">Entity saveNew(Entity entity)</src-code>
                    </li>
                    <li>
                        <src-code language="java">Entity update(Entity entity)</src-code>
                    </li>
                    <li>
                        <src-code language="java">void delete(Entity entity)</src-code>
                    </li>
                </ol>

                <hr />

                <p style="width: 100%; transform: scaleY(-1) scaleX(-1); display: inline-block;">
                    <small>
                        <b>Lösung:</b> 3, 2, 2, 3, 1, 1, alle bis auf 2 und 3
                    </small>
                </p>
            </article>
            <aside>
                <p>
                    Puh, endlich geschafft! 🌬️ Letzte Folie, oder so. Wie immer zum Abschluss einer Einheit gibt
                    es hier ein paar Wiederholungsfragen für dich.
                </p>
            </aside>
        </section>

        <!--
            ====================
            HINWEISE ZUM SCHLUSS
            ====================
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Hinweise zum Schluss</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section data-background-color="rgb(153, 190, 137)">
            <h1>Do &amp; Don't</h1>
            <article>
                <h4>Erstellung des Datenmodells</h4>
                <ul>
                    <li>
                        Nutze E/R-Diagramme und andere Techniken zur Modellierung des Datenmodells.
                    </li>
                    <li>
                        Achte darauf, das Datenmodell zu normalisieren und Redundanzen zu vermeiden.
                    </li>
                    <li>
                        Gestalte das Datenmodell so einfach wie möglich, so komplex wie nötig.
                    </li>
                    <li>
                        Bilde Fremdschlüssel immer als Objektreferenz in Java ab.
                    </li>
                    <li>
                        Vermeide bidirektionale Beziehungen, wenn du sie nicht wirklich brauchst.
                    </li>
                    <li>
                        Nutze Lzay Loading für Beziehungen, wenn ihre Daten nicht bei jedem Aufruf benötigt werden.
                    </li>
                    <li>
                        Mache regen Gebrauch von <code>@Column</code> zur Spezifizierung der Tabellenfelder.
                    </li>
                    <li>
                        Versuche <code>@Lob</code>-Felder immer zu vermeiden, wenn du sie nicht brauchst.
                    </li>
                    <li>
                        Definiere Indizies für sehr häufg gebrauchte Selektionen.
                    </li>
                    <li>
                        Lege komplexe oder an mehreren Stellen benötigte Selektionen in der Entityklasse als <code>@NamedQuery</code> an.
                    </li>
                    <li>
                        Belege alle Attribute mit einem sinnvollen Startwert vor.
                    </li>
                    <li>
                        Vermeide es, Tabellenfelder mit <b>nullable=True</b> zu definieren.
                    </li>
                    <li>
                        Spendiere jeder Persistence Entity mehrere Konstruktoren, um ihre Benutzung zu vereinfachen.
                    </li>
                    <li>
                        Übergabe die Id nicht an den Konstruktor, wenn sie automatisch generiert werden soll.
                    </li>
                </ul>

                <h4>Konfiguration des O/R-Mappers</h4>
                <ul>
                    <li>
                        Überlege dir, die Tabellen im Produktivbetrieb von Hand anzulegen, um sie zu optimieren.
                    </li>
                    <li>
                        Auf jeden Fall achte darauf, die richtige <b>Table Generation Strategy</b> zu wählen.
                    </li>
                    <li>
                        Nutze <code>@Table</code> und <code>@Column</code>, um die Namen von Tabellen und Feldern anzupassen.
                    </li>
                </ul>

                <h4>Nutzung der Persistence Entities</h4>
                <ul>
                    <li>
                        Definiere gute Enterprise Java Beans zur Verwendung der Persistence Entities.
                    </li>
                    <li>
                        Lagere sich häufig wiederholenden Code in einer allgemeinen Basisklasse aus.
                    </li>
                    <li>
                        Nutze immer <code>addParameter()</code>, um Feldwerte in eine <code>WHERE</code>-Bedingung einzubauen.
                    </li>
                    <li>
                        Biete spezielle Suchmethoden für häufiger benötigte Selektionen.
                    </li>
                    <li>
                        Überlege dir, die maximale Anzahl rückgegebener Sätze zu begrenzen und die Sätze vorzusortieren.
                    </li>
                    <li>
                        Programmiere besonders performancekritische Sachen mit Native SQL.
                    </li>
                    <li>
                        Biete gleichzeitig aber immer auch eine JQL-Version für nicht-kompatible Datenbanken.
                    </li>
                </ul>
            </article>
            <aside>
                <p>
                    Dies sind sie: Die zehn Gebote. 📄 Auf dieser Folie haben wir ein paar allgemeine Tipps
                    zusammengestellt, worauf du bei bei der Programmierung mit der Java Persistence API
                    achten solltest.
                </p>
                <img src="../../do-dont.svg" class="d-block" style="width: 20em; max-width: 100%; margin-bottom: 0.5em;" />
                <p>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/dialog-tip-advice-hint-speaking-148815/" target="_blank" style="color: rgb(25, 68, 49);">Pixabay: OpenClipart-Vectors</a>
                    </small>
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(158, 203, 231)">
            <h1>Rechtshinweise</h1>
            <article>
                <h4>Creative Commons Namensnennung 4.0 International</h4>
                <ul>
                    <li>Beliebiges Teilen ist erlaubt</li>
                    <li>Die Unterlagen dürfen bearbeitet und verändert werden</li>
                    <li>Wenn die Namens- und Urheberangaben erhalten bleiben</li>
                    <li>Und keine weiteren Einschränkungen auferlegt werden</li>
                </ul>
                <span style="font-size: 400px; color: white;" class="dhbw-text-shadow" >§</span>
            </article>
            <aside style="font-size: 80%">
                <h4>Kontaktdaten</h4>
                <p>
                    Dennis Schulmeister-Zimolong<br/>
                    E-Mail: <a data-email-address>dhbw windows3.de</a><br/>
                </p>

                <h4>Urheberrecht und Lizenzvereinbarung</h4>
                <p>
                    © 2018 Dennis Schulmeister-Zimolong <br/>
                    <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-folien" target="_blank">https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-folien</a>
                </p>
                <img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Lizenzvertrag" />
                <p>
                    Das Werk <i>Vorlesung "Verteilte Systeme" im Studiengang Wirtschaftsinformatik
                    an der DHBW Karlsruhe</i> von <a href="http://www.windows3.de" target="_blank">Dennis Schulmeister-Zimolong</a>
                    ist lizenziert unter <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank"><i>Creative Commons
                    Namensnennung 4.0 International</i></a>.
                </p>
                <p>
                    Du darfst:
                </p>
                <ul>
                    <li>
                        <b>Teilen</b> — das Material in jedwedem Format oder Medium vervielfältigen
                        und weiterverbreiten
                    </li>
                    <li>
                        <b>Bearbeiten</b> — das Material remixen, verändern und darauf aufbauen
                        und zwar für beliebige Zwecke, sogar kommerziell.
                    </li>
                </ul>
                <p>
                    Unter folgenden Bedingungen:
                </p>
                <ul>
                    <li>
                        <b>Namensnennung</b> — Du musst angemessene Urheber- und Rechteangaben
                        machen, einen Link zur Lizenz beifügen und angeben, ob Änderungen
                        vorgenommen wurden. Diese Angaben dürfen in jeder angemessenen Art
                        und Weise gemacht werden, allerdings nicht so, dass der Eindruck
                        entsteht, der Lizenzgeber unterstütze gerade dich oder deine Nutzung
                        besonders.
                    </li>
                    <li>
                        <b>Keine weiteren Einschränkungen</b> — Du darfst keine zusätzlichen Klauseln
                        oder technische Verfahren einsetzen, die anderen rechtlich irgendetwas
                        untersagen, was die Lizenz erlaubt.
                    </li>
                </ul>
                <p>
                    Es werden keine Garantien gegeben und auch keine Gewähr geleistet.
                    Die Lizenz verschafft dir möglicherweise nicht alle Erlaubnisse,
                    die du für die jeweilige Nutzung brauchst. Es können beispielsweise
                    andere Rechte wie Persönlichkeits- und Datenschutzrechte zu beachten
                    sein, die deine Nutzung des Materials entsprechend beschränken.
                </p>
            </aside>
        </section>
    </body>
</html>
