<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Grundlagen verteilter Systeme</title>

        <link rel="shortcut icon" href="../../favicon.svg" />
        <link rel="stylesheet" href="../../style.css" />
        <script src="../../learning-slides.bundle.js"></script>
    </head>
    <body class="slides invisible" data-title="Grundlagen verteilter Systeme" tabindex="0">
        <header>
            <h2>Inhaltsverzeichnis</h2>
            <p>
                Bevor wir loslegen und programmieren können, wollen wir an dieser Stelle
                erst einmal das Themengebiet unserer Vorlesung abstecken. Hier erhältst
                du daher einen umfassenden Überblick, was verteilte Systeme sind und
                welche Möglichkeiten es bei ihrer Entwicklung gibt.
            </p>
        </header>

        <!--
            LERNZIELE DIESER EINHEIT
        -->
        <section data-chapter data-background-color="rgb(210,190,210)">
            <h1>Lernziele dieser Einheit</h1>
            <article>
                <h3>Nach Abschluss dieser Einheit kannst du …</h3>
                <ul>
                    <li>
                        den Begriff <span class="dhbw-lightblue font-weight-bold">verteiltes System</span>
                        erklären und von ähnlichen Begriffen abgrenzen.
                    </li>
                    <li>
                        Beispiele für <span class="dhbw-lightblue font-weight-bold">verteilte Anwendungen</span>
                        nennen und von normalen Anwendungen abgrenzen.
                    </li>
                    <li>
                        die wichtigsten Gründe nennen, warum wir in der Wirtschaftsinformatik verteilte
                        Systeme entwickeln 💰.
                    </li>
                    <li>
                        die Bedeutung des <span class="dhbw-lightblue font-weight-bold">CAP-Theorem</span>
                        verstehen und seine Bedeutung wiedergeben.
                    </li>
                    <li>
                        die Begriffe <span class="dhbw-lightblue font-weight-bold">Client</span>,
                        <span class="dhbw-lightblue font-weight-bold">Server</span> und
                        <span class="dhbw-lightblue font-weight-bold">Peer</span> exakt definieren und voneinander abgrenzen.
                    </li>
                    <li>
                        beschreiben, was eine <span class="dhbw-lightblue font-weight-bold">Middleware</span>
                        ist und welche Aufgaben sie besitzt.
                    </li>
                    <li>
                        beschreiben, wie es zur Entwicklung heutiger Middlewarearten gekommen ist.
                    </li>
                    <li>
                        unterschiedliche Arten der Kommunikation verteilter Systeme gegeneinander abwägen.
                    </li>
                    <li>
                        die gängigsten <span class="dhbw-lightblue font-weight-bold">Architekturmuster
                        verteilter Anwendungen</span> beschreiben und bewerten.
                    </li>
                </ul>
                <span style="font-size: 240px; color: white;" class="dhbw-text-shadow" >🏁</span>
            </article>
            <aside>
                <p>
                    Heute wollen wir uns noch nicht ganz so tief in die Programmierung stürzen. Denn bevor wir
                    damit so richtig loslegen können, musst du erst noch ein paar Grundbegriffe kennen und verstehen.
                    Beginnen werden wir die Einheit daher mit ein paar einfachen Definitionen der beiden Begriffe
                    <b>verteiltes System️</b> und <b>verteilte Anwendung</b>, wobei wir hier insbesondere auf die
                    Unterschiede beider Begriffe und ihre heute Bedeutung für die Wirtschaftsinformatik 💰 eingehen
                    werden. Des Weiteren werden wir bei dieser Gelegenheit die beiden Begriffe <b>Client</b> und
                    <b>Server</b> nochmal etwas genauer anschauen. Zwar handelt es sich dabei um alltägliche Begriffe,
                    die du sicher auch schon so gekannt hast, doch gerade weil sie so alltäglich sind, versteht
                    eigentlich jeder etwas anderes darunter und keiner weiß so ganz genau, was sie bedeuten und
                    was nicht. 🤔
                </p>
                <p>
                    Anschließend gehen wir dann doch schon ein ganz klein wenig auf die Programmierung ein, indem
                    wir zeigen, was eine <b>Middleware</b> ist und welche Aufgaben sie hat. Denn, soviel sei hier
                    schon verraten, im Prinzip könnten wir zwar auch mit den Boardmitteln von Java verteilte Anwendungen
                    schreiben, in vielen Fällen gibt es aber komfortablere Möglichkeiten, die uns viel Arbeit sparen
                    können. Aus diesem Grund lernen wir hier verschiedene Middlewarearten kennen, und zeigen, welche
                    Programmierstile sie begünstigen.
                </p>
                <p>
                    Vollenden werden wir die heilige Dreieinigkeit mit einer kurzen Besprechung der wichtigsten
                    <b>Architekturmuster verteilter Anwendungen</b>. Ausgehend von ein paar einfachen Fallbeispielen
                    zeigen wir dabei, aus welchen Bestandteilen verteilte Anwendungen bestehen können und wie
                    diese zusammenspielen. Damit kennst du dann alle Grundlagen 📚, um für den Rest der Vorlesung
                    in unterschiedlichen Middlewares, Frameworks und natürlich ganz viel Quellcode zu versinken. 🕳️
                </p>
            </aside>
        </section>

        <!--
            WICHTIGE BEGRIFFE
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Wichtige Begriffe</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Definition des Begriffs „Verteiltes System”</h1>
            <article>
                <h2>Allgemeine Definition</h2>

                <div style="margin-bottom: 1em;">
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "vertsys-definition-system-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#vertsys-definition-system"
                                role          = "tab"
                                aria-controls = "vertsys-definition-system"
                                aria-expanded = "true"
                            >
                                Ach, ein System
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vertsys-definition-computer-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vertsys-definition-computer"
                                role          = "tab"
                                aria-controls = "vertsys-definition-computer"
                            >
                                Mehrere Computer
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vertsys-definition-cpus-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vertsys-definition-cpus"
                                role          = "tab"
                                aria-controls = "vertsys-definition-cpus"
                            >
                                Mehrere Rechenkerne
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Ach, ein System -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "vertsys-definition-system"
                            role            = "tabpanel"
                            aria-labelledby = "vertsys-definition-system-tab"
                        >
                            <p>
                                Jeden Tag sprechen wir vom System: <br />
                                <i>📣 Das System hängt mal wieder.</i> <br />
                                <i>📣 Dazu musst du dich am System anmelden.</i><br />
                                <i>📣 Das haben wir im System gespeichert.</i>
                            </p>
                            <p>
                                Doch was um alles in der Welt ist überhaupt ein „System”
                                <span style="color: crimson; text-shadow: 1px 1px 1px rgba(0,0,0,0.5);">⁉️</span>
                            </p>
                            <div class="embed-responsive-16by9">
                                <iframe src="https://www.youtube-nocookie.com/embed/UWU14-EK9CE" allow="encrypted-media" allowfullscreen></iframe>
                            </div>
                        </div>
                        <!-- Vollständig getrennte Computereinheiten -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vertsys-definition-computer"
                            role            = "tabpanel"
                            aria-labelledby = "vertsys-definition-computer-tab"
                        >
                            <p>
                                Die klassische Definition eines verteilten Systems: Mehre <b>voneinander unabhängige Computer</b>
                                (Prozessoren) <b>mit jeweils eigenem Hauptspeicher</b> tauschen über ein Netzwerk Daten miteinander
                                Daten aus, um <b>eine gemeinsame Aufgabe</b> zu bearbeiten.
                            </p>
                            <p>
                                <img src="verteiltes-system.jpg" alt="Skizze eines verteilten Systems mit mehreren Computern" style="width: 100%" />
                            </p>
                            <p>
                                <small>
                                    <small>
                                        Bildnachweise:
                                        <a href="https://commons.wikimedia.org/wiki/File:Jolla_PoppyRed_Home.jpg" target="_blank">Wikimedia Commons: Jolla Ltd.</a>,
                                        <a href="https://pixabay.com/en/macbook-laptop-players-mac-office-1443927/" target="_blank">Pixabay: Elianos2</a>,
                                        <a href="https://pixabay.com/en/imac-pc-personal-computer-computer-2493287/" target="_blank">Pixabay: GAMEZONA</a>,
                                        <a href="https://pixabay.com/en/router-network-connection-pc-670079/" target="_blank">Pixabay: succo</a>,
                                        <a href="https://pixabay.com/en/computer-file-mounted-158930/" target="_blank">Pixabay: OpenClipart-Vectors</a>
                                    </small>
                                </small>
                            </p>
                        </div>
                        <!-- Mehrere Prozessoren mit gemeinsamem Speicher -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vertsys-definition-cpus"
                            role            = "tabpanel"
                            aria-labelledby = "vertsys-definition-cpus-tab"
                        >
                            <p>
                                Dies ist <u>kein</u> verteiltes System. Zwar haben wir hier auch mehrere, prinzipiell unabhängige
                                Prozessoren. Jedoch teilen sich diese den Hauptspeicher und alle andere Peripherie des Systems, so
                                dass man hier für alle praktischen Belange von einem einzelnen Computer ausgehen kann.
                            </p>
                            <p>
                                <img src="smp.svg" alt="Schematisches Diagramm eines symetrischen Multiprozessorsystems" style="width: 100%" />
                            </p>
                            <p>
                                <small>
                                    <small>
                                        Bildnachweis: In Anlehnung an
                                        <a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing#/media/File:SMP_-_Symmetric_Multiprocessor_System.svg" target="_blank">
                                            Wikipedia: Diagram of a symmetric multiprocessing system
                                        </a>
                                    </small>
                                </small>
                            </p>
                        </div>
                    </div>
                </div>

                <h2>Fallbeispiele</h2>
                <div>
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item">
                            <a
                                id            = "vertsys-beispiele-internet-tab"
                                class         = "nav-link active"
                                data-toggle   = "tab"
                                href          = "#vertsys-beispiele-internet"
                                role          = "tab"
                                aria-controls = "vertsys-beispiele-internet"
                                aria-expanded = "true"
                            >
                                Das Internet
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vertsys-beispiele-supercomputer-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vertsys-beispiele-supercomputer"
                                role          = "tab"
                                aria-controls = "vertsys-beispiele-supercomputer"
                            >
                                Moderne Supercomputer
                            </a>
                        </li>
                        <li class="nav-item">
                            <a
                                id            = "vertsys-beispiele-videoueberwachung-tab"
                                class         = "nav-link"
                                data-toggle   = "tab"
                                href          = "#vertsys-beispiele-videoueberwachung"
                                role          = "tab"
                                aria-controls = "vertsys-beispiele-videoueberwachung"
                            >
                                Videoüberwachung
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content border border-top-0 bg-white" style="padding: 1em;">
                        <!-- Das Internet -->
                        <div
                            class           = "tab-pane fade show active"
                            id              = "vertsys-beispiele-internet"
                            role            = "tabpanel"
                            aria-labelledby = "vertsys-beispiele-internet-tab"
                        >
                            <p>
                                Das größte verteilte System überhaupt ist sicher das Internet.
                                1977 noch ARPANET genannt, konnte man alle beteiligten Rechner auf einer Seite darstellen. 😎
                            </p>
                            <p>
                                <img src="arpanet.png" alt="Karte des ARPANET von 1977" style="width: 100%" />
                            </p>
                            <p>
                                <small>
                                    <small>
                                        Bildnachweis: <a href="https://commons.wikimedia.org/wiki/File:Arpanet_logical_map,_march_1977.png" target="_blank">Wikimedia Commons</a>
                                    </small>
                                </small>
                            </p>
                        </div>
                        <!-- Moderne Supercomputer -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vertsys-beispiele-supercomputer"
                            role            = "tabpanel"
                            aria-labelledby = "vertsys-beispiele-supercomputer-tab"
                        >
                            <div class="container-fluid">
                                <div class="row">
                                    <div class="col">
                                        Hochleistungsrechner, wie sie in der Forschung und Wissenschaft oder von großen Internetkonzernen
                                        genutzt werden, bestehen aus einer riesigen Anzahl kleiner Computer mit eigenem Hauptspeicher und
                                        in der Regel auch eigenem Massenspeicher. Die Einzelcomputer werden dabei in <b>Storage Nodes</b>
                                        zur Speicherung von Daten und in <b>Compute Nodes</b> zur Bereitstellung von Rechenleistung
                                        unterschieden.
                                    </div>
                                </div>

                                <div class="row">
                                    <div class="col-md-4">
                                        <img src="ibm-blue-gene.jpg" alt="IBM Blue-Gene Supercomputer" style="width: 100%;" class="img-thumbnail" />
                                    </div>
                                    <div class="col-md-8">
                                        <img src="gridcomputer.svg" alt="Skizze eines Grid-Computers" style="width: 100%;" />
                                    </div>
                                </div>

                                <div class="row">
                                    <div class="col">
                                        <small>
                                            <small>
                                                Bildnachweis (Foto):
                                                <a href="https://de.wikipedia.org/wiki/Blue_Gene#/media/File:IBM_Blue_Gene_P_supercomputer.jpg" taget="_blank">Wikimedia Commons / Argonne National Laboratory</a>
                                            </small>
                                        </small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Videoüberwachung -->
                        <div
                            class           = "tab-pane fade"
                            id              = "vertsys-beispiele-videoueberwachung"
                            role            = "tabpanel"
                            aria-labelledby = "vertsys-beispiele-videoueberwachung-tab"
                        >
                            <p>
                                Ein Fallbeispiel aus dem IoT-Umfeld könnte eine IP-basierte Videoüberwachungsanlage sein 📹. In diesem Fall
                                beinhaltet jede Kamera ein eingebettetes Computersystem, das über ein IP-Netz mit einem Archivserver und den
                                Arbeitsplatzcomputern des Sicherheitspersonals kommuniziert.
                            </p>
                            <p>
                                <img src="cctv.svg" alt="Skizee einer digitalen Videoüberwachungsanlage" style="width: 100%" />
                            </p>
                            <p>
                                <small>
                                    <small>
                                        Bildnachweise:
                                        <a href="https://pixabay.com/en/surveillance-camera-security-video-147831/" target="_blank">Pixabay: OpenClipart-Vectors</a>,
                                        <a href="https://pixabay.com/en/mountain-road-winding-road-travel-1556177/" target="_blank">PIxabay: JanBaby</a>,
                                        <a href="https://pixabay.com/en/auto-road-home-window-building-3091234/" target="_blank">Pixabay: GunetherDillingen</a>
                                    </small>
                                </small>
                            </p>
                        </div>
                    </div>
                </div>
            </article>
            <aside>
                <h2>Bedeutung des Begriffs</h2>
                <p>
                    Da es von nun an um verteilte Systeme gehen soll, liegt die Frage nahe, was darunter überhaupt
                    zu verstehen ist. Wobei sich hieraus gleich die nächste Frage ableitet: Was ist überhaupt ein
                    System?. Denn wenn man so darüber nachdenkt, kommt man schnell zu dem Schluss, dass wir im
                    IT-Alltag zwar oft von Systemen sprechen, der Begriff aber niemandem so wirklich klar ist.
                    Oder wie ist es genau gemeint, wenn wir dem Büronachbarn zurufen, <i>das System hängt mal wieder</i>
                    oder <i>die Daten sollten im System gespeichert sein</i>? Meinen wir damit den eigenen Computer,
                    ein bestimmtes Programm oder doch einfach nur <i>das Ding, für das mir gerade kein besserer
                    Name einfällt</i>?
                </p>
                <p>
                    Halten wir also fest, dass ein System einfach ein Irgendwas ist und dass wir ab sofort nicht mehr
                    herkömmliches Irgendwas sondern verteiltes Irgendwas machen. 🤠 Tatsächlich gibt es aber eine
                    relativ klare Definition für verteilte Systeme, die von dem niederländischen Informatikprofessor
                    Andres Tanenbaum und anderen bekannten Persönlichkeiten geprägt wurde. Allerdings ist sie deshalb
                    nur „relativ klar”, da jede dieser Personen einen etwas abweichenden Wortlaut mit geringfügig
                    abweichenden Schwerpunkten benutzt.
                </p>
                <p>
                    Dabei läuft es aber immer auf folgendes hinaus: Ein verteiltes System ist ein Sammlung, mehrerer,
                    <b>voneinander unabhängiger Computer</b> (Prozessoren) <b>mit jeweils eigenem Hauptspeicher</b>,
                    die <b>über ein Netzwerk Daten (Nachrichten) austauschen</b>, um eine gemeinsame Aufgabe zu bearbeiten.
                    Zusammengefasst also:
                </p>
                <ol>
                    <li>
                        Mindestens zwei vollwertige Computer,
                    </li>
                    <li>
                        die einen gemeinsamen Zweck erfüllen,
                    </li>
                    <li>
                        und über ein Netzwerk miteinander verbunden sind.
                    </li>
                </ol>
                <p>
                    Dabei ist insbesondere die Anforderung, dass es sich um zwei vollwertige Computer mit jeweils eigenem
                    Hauptspeicher handeln muss sehr wichtig, da hierüber auch die Abgrenzung zu sogenannten Parallelrechnern
                    oder einfachen Multi-Core-Systemen erfolgt. Denn nur, wenn jeder Rechenkern über seinen eigenen, privaten
                    Hauptspeicher verfügt, kann man wirklich von zwei getrennten Computern ausgehen, die sich lediglich
                    Nachrichten über das Netzwerk schicken können. 🖧 Andernfalls wäre heutzutage jedes kleine Smartphone und
                    jeder Laptop ein verteiltes System, da es heute Computer mit nur einem Rechenkern im Prinzip gar nicht
                    mehr gibt.
                </p>
                <p>
                    Generell mag die Definition eines verteilten Systems in heutiger Zeit etwas befremdlich klingen, wo heute
                    doch nicht nur jedes Smartphone und Tablet eine dauerhafte Internetverbindung besitzt, sondern wir auch über
                    Ausmaß und Bedeutung des Internet of Things oder gar Internet of Everything sprechen. 🌍 Dazu muss man natürlich
                    sagen, dass der Begriff „verteiltes System” noch zu einer Zeit geprägt wurde, als ein Computer tatsächlich
                    einfach nur ein Computer mit einer Single-Core CPU war 🖳, der ohne Verbindung zur Außenwelt einfach seine
                    Aufgabe erfüllte. Ja sogar zu einer Zeit, als es generell etwas Besonderes war, überhaupt einen Computer
                    zu haben. Und zwar sowohl an der Hochschule, in der Firma als auch privat. Heute sieht die Welt tatsächlich
                    etwas anderes aus und wir arbeiten tagtäglich mit verteilten Systemen, meistens sogar ohne es zu wissen.
                </p>

                <h2>Weitere Abgrenzungsmerkmale</h2>
                <p>
                    Manche Autoren gehen neben der oben genannten Definition noch einen Schritt weiter und fügen die zusätzlich
                    Bedingung hinzu, dass die Computer eines verteilten Systems keine gemeinsame Uhrzeit besitzen dürfen. Dies
                    ist aber eigentlich keine Voraussetzung für ein verteiltes System sondern eine zwangsläufige Konsequenz daraus.
                    Denn so gut wie jeder Computer besitzt heute eine eingebaute Echtzeituhr und diese kann natürlich vor oder nach
                    gehen. Es wäre sogar ein Wunder, wenn zwei Uhren per Zufall auf exakt dieselbe Uhrzeit gestellt wären. Vereilte
                    Systeme müssen daher auch mit der Situation umgehen können, dass 11:48 Uhr auf dem einen Rechner später ist als
                    11:50 Uhr auf dem anderen.
                </p>
                <p>
                    Weiterhin wird gerne zwischen heterogenen und homogenen, verteilten Systemen unterscheiden, womit aber nur
                    gemeint ist, ob alle Rechnerknoten dieselbe Hardware und Betriebssysteme verwenden (homogen) oder eben nicht
                    (heterogen). Wie du dir sicher denken kannst, haben wir es gerade in der Wirtschaftsinformatik fast immer
                    mit heterogenen Systemen zu tun. Das <i>Write Once, Run Anywhere</i>-Prinzip von Java könnte am Ende vom Tag
                    also doch noch ganz nützlich sein. 🐶
                </p>
                <p>
                    Wichtig für die weitere Abgrenzung, vor allem von verteilten Anwendungen, ist jedoch, dass bei einem verteilten
                    System lediglich die Hardware und im erweiterten Sinne noch Netzwerk und Betriebssystem betrachtet werden. Es geht
                    also ganz konkret um Fragen wie, <i>welche Hardwarekomponenten habe ich</i>, <i>welcher Knoten übernimmt welche
                    Aufgabe</i>, <i>wie ist das Netzwerk aufgebaut</i> und so weiter?
                </p>

                <h2>Einige Fallbeispiele</h2>
                <p>
                    Mit diesem Wissen ausgestattet schauen wir uns nun ein paar verteilte Systeme in, wobei du sicher zustimmen wirst,
                    dass das größte davon das Internet ist. Auch wenn es manchmal praktikabel ist, bei der Festlegung eines verteilten
                    Systems nur ein paar wenige Rechner zu betrachten, selbst wenn sie ausschließlich über das Internet miteinander
                    verbunden sind, kann man doch ohne Zweifel sagen, dass das Internet in seiner Gesamtheit alle der oben genannten
                    Kriterien erfüllt. Man kann sogar sagen, es war die erste praktikable Umsetzung eines verteilten Systems überhaupt,
                    auch wenn 1977 noch alle beteiligten Computer auf ein Blatt Papier gepasst haben (siehe Folie). 😎
                </p>
                <p>
                    Ein weiteres gutes Beispiel, mit dem wir in der WI leider nicht so oft in Berührung kommen, sind Computer Cluster,
                    Supercomputer oder Grid Computer. Dabei handelt es sich um einen Zusammenschluss wahnsinnig vieler, eigentlich kleiner
                    Computer zu einem großen Computer. Die Einzelcomputer sind hierfür in mehreren Racks dicht and dicht verbaut und über
                    ein physikalisch getrenntes Netzwerk miteinander verbunden. Über eine öffentiche Netzwerkschnittstelle werden sie
                    dann in der Regel als eine Einheit angesprochen, an die die auszuführenden Jobs übergeben werden können. Intern sind
                    die Einzelcomputer hierfür in Compute Nodes zur Bereitstellung von Rechenleistung und in Storage Nodes zur Bereitstellung
                    von Plattenplatz unterteilt. Dem Verwender des Systems bleibt diese Trennung jedoch verborgen.
                </p>
                <p>
                    Etwas mehr in unserem Alltag verortet könnte eine IP-basierte Videoüberwachung sein. 📹 Die Kameras beinhalten dann jeweils
                    ein kleines, eingebettetes Computersystem, das über ein TCP/IP-Netz seine Bilder an einen zentralen Archivserver sowie die
                    PCs des Wachpersonals schickt.
                </p>
                <p>
                    Und so lassen sich noch viele weitere Beispiele finden …
                </p>
            </aside>
        </section>

        <section>
            <h1>Definition des Begriffs „Verteilte Anwendung”</h1>
            <article>
                …
                <!--
                Bullet Points mit der Definition
                E-Mail mit Skizzen im Detail
                Andere Beispiele nur aufgezählt
                -->
            </article>
            <aside>
                <p>
                    Das schönste, verteilte System nützt einem natürlich nichts, wenn es keine Aufgabe erfüllt. Wie Romeo und Julia,
                    Asterix und Obelix, Batman und Robin, Dick und Doof, Bud Spencer und Terence Hill, Protonen und Neutronen, so
                    gehören verteilte Systeme und verteilte Anwendungen immer zusammen. 👥 Wobei mit einer verteilter Anwendung die
                    Summe aller Teilprogramme gemeint ist, die auf den einzelnen Computern laufen, um eine gemeinsame Aufgaben zu
                    erfüllen.
                </p>
                <p>
                    Wie wir später noch sehen werden, kann man sich das so vorstellen, als hätte man einen großen Klumpen Quellcode
                    eines Programms in mehrere Einzelteile zerlegt und diese dann auf die einzelnen Rechner verteilt. Denn für den
                    Anwender soll die Trennung ja gar nicht sichtbar sein und prinzipiell könnte auch der einfachste, kleine Rechner
                    die kompliziertesten Aufgaben erfüllen, wenn er nur lange genug rechnen würde. Da aber niemand mehrere Tage oder
                    gar Jahre auf ein Ergebnis warten will, zerlegt man das Programm einfach in mehrere Teilprogramme und lässt diese
                    zeitgleich auf vielen kleinen Computern laufen.
                </p>
                <p>
                    Okay, das klingt vielleicht ein wenig abstrakt und theoretisch. Aber denke ruhig nochmal eine Minute darüber nach. 🤔
                    Eigentlich ist es ganz einfach: Eine verteilte Anwendung, ist eine Anwendung, die ein <b>verteiltes System zur
                    Lösung ihres Anwendungsproblems</b> nutzt und <b>aus mehreren Teilprogrammen (Softwarekomponenten)</b> besteht,
                    die untereinander durch den <b>Austausch von Nachrichten</b> kommunizieren. Mögliche Beispiele könnten daher sein:
                </p>
                <ul>
                    <li>
                        Das World Wide Web als der Informationsdienst im Internet
                    </li>
                    <li>
                        Der E-Maildienst des Internets
                    </li>
                    <li>
                        Voice-Over-IP generell sowie spezielle VoIP-Anwendungen
                    </li>
                    <li>
                        Aber auch jeder Webshop und nahezu jede Webanwendung
                    </li>
                    <li>
                        Konkrete IoT-Softwarepakete zur Überachung eines „Smart Home”
                    </li>
                    <li>
                        Jedes Computerspiel mit internetbasiertem Mehrspielermodus
                    </li>
                    <li>
                        Und so weiter …
                    </li>
                </ul>
                <p>
                    Leitfragen, die wir uns hier stellen, könnten zum Beispiel sein <i>in welche Teilaspekte kann ich mein Problem
                    zerlegen</i>, <i>welche Programme laufen auf welchen Rechnernknoten</i>, <i>welches Programm muss was in welcher
                    Reihenfolge machen</i>, <i>welche Nachrichten tauschen die Programme untereinander aus</i> und so weiter.
                </p>
            </aside>
        </section>

        <section>
            <h1>Wozu man verteilte Systeme wirklich braucht</h1>
            <article>
                …
                <!--
                Raytracingbild hierher verschieben?
                -->
            </article>
            <aside>
                <p>
                    Um die Wichtigkeit verteilter Systeme in der Wirtschaftsinformatik zu verdeutlichen, schauen wir uns
                    zunächst einmal ein für die meisten Unternehmen eher untypisches, dafür aber umso deutlicheres Beispiel
                    an: 3D-Animationsfilme. 🎞️ Jeder kennt sie und jeder liebt sie 🍿, weshalb zwischenzeitlich selbst Disney
                    seine traditionelle Zeichentricksparte eingestellt hatte, um nur noch 3D-Filme zu produzieren.¹ 😯
                </p>
                <p>
                    <small>
                        ¹ Zum Glück wurde diese Entscheidung wieder rückgängig gemacht, wenn man bedenkt, wie eng doch gerade
                        Walt Disney mit der Entwicklung des Zeichentrick verbunden ist. Aber wusstest du, dass Disney zusammen
                        mit Pixar bereits Ende der 1980er-Jahre <a href="https://en.wikipedia.org/wiki/Computer_Animation_Production_System"
                        target="_blank">das erste Computersystem zur Erstellung von Zeichentrickfilmen</a> entwickelt und für
                        viele seiner Filme genutzt hat?
                    </small>
                </p>
                <p>
                    Was sicher nur wenigen bewusst ist, ist der immense Rechenaufwand, der in jedem 3D-Animationsfilm steckt.
                    Denn ein typischer Kinofilm besitzt bei 90 Minuten Länge und 25 Bildern je Sekunde immerhin 135.000 Einzelbilder,
                    von denen jedes bei einer typischen 4K-Auflösung (von 8K wollen wir erst gar nicht reden) unvorstellbare 8.847.360
                    Pixel umfasst. Und die wollen alle berechnet werden! 🌇🌃🌃🌃🌇🌆🌆🌇🌃🌃🌃🌇
                </p>
                <p>
                    Der Aufwand potentiert sich sogar noch, wenn man bedenkt, dass hierfür das rechenintensive
                    <a href="https://de.wikipedia.org/wiki/Raytracing" target="_blank">Raytracing-Verfahren</a>
                    genutzt wird, bei dem ausgehend von einer virtuellen Kamera für jeden Bildpunkt ein gedachter
                    Lichtstrahl ausgesendet und geprüft wird, auf welche Oberflächen er trifft. Dabei handelt es
                    sich auch noch um einen rekursiven Algorithmus, der auch berücksichtigt, wenn ein Strahl an einer
                    Oberfläche gebrochen wird und dadurch in hunderte weitere Teilstrahlen zerfällt. Das ganze ist
                    wahnsinnig aufwändig, produziert dafür aber umso realistischere Bilder, wie das folgende Beispiel
                    zeigt:
                </p>
                <p>
                    <img src="raytracing.jpg" alt="Beispiel für ein klassisches Raytracing-Motiv (drei Kugeln mit Spiegelung)" class="img-thumbnail" style="width: 100%;" />
                    <small>
                        Klassisches Raytracing-Motiv: Drei Kugeln auf einem Schachbrettmuster. Das Lichtspiel und die Spiegelungen werden
                        durch die rekursive Verfolgung der Lichtstrahlen sehr realistisch simuliert. Für noch mehr beeindruckende
                        Beispiele <a href="http://hof.povray.org/" target="_blank">hier klicken</a>. Bildnachweis:
                        <a href="https://commons.wikimedia.org/wiki/File:3chromeballs.png" target="_blank">Wikimedia Commons: 3chromeballs.png</a>
                    </small>
                </p>
                <p>
                    Ein einzelner Computer wäre Jahrzehnte lang damit beschäftigt, die Bilder eines ganzen Filmes zu berechnen und würde damit
                    fast genauso lange brauchen, wie Deep Thought in <a href="https://de.wikipedia.org/wiki/Per_Anhalter_durch_die_Galaxis"
                    target="_blank">Per Anhalter durch die Galaxis</a> 🐬. Ein verteiltes System oder besser gesagt eine
                    <a href="https://en.wikipedia.org/wiki/Render_farm" target="_blank">Render Farm</a> muss also her, um die Berechnungsdauer
                    auf ein Jahr zu reduzieren. Denn dafür wurden verteilte Systeme ursprünglich erfunden: Zur Parallelisierung großer
                    Berechnungen, um diese schneller durchführen zu können. Und auch für uns Wirtschaftsinformatiker ist das oft ein Grund,
                    auf verteilte Systeme zurückzugreifen. Im gewöhnlichen, grauen IT-Alltag können aber auch folgende ganz unspekatuläre
                    Gründe ausschlaggebend sein:
                </p>
                <ul>
                    <li>
                        Zentralisierung von Daten und Informationen
                    </li>
                    <li>
                        Abschirmung der internen Systeme von der Außenwelt
                    </li>
                    <li>
                        Zum sammeln, speichern und auswerten von Sensordaten
                    </li>
                    <li>
                        Zur Unterstützung von Geschäftsprozessen
                    </li>
                    <li>
                        Für den Zugriff auf interne Daten über eine Smartphone App
                    </li>
                    <li>
                        Für die Nutzung des Browsers als Ersatz für einen Standalone-Client
                    </li>
                    <li>
                        Und so weiter, und so fort …
                    </li>
                </ul>
            </aside>
        </section>

        <section>
            <h1>Allgemeine Anforderungen an verteilte Systeme</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    Hat man sich einmal zu einem verteilten System hinreisen lassen, will man natürlich, dass es die gewünschte
                    Aufgabe so gut wie möglich unterstützt. Und hierfür will man in den meisten Fällen, dass folgende Anforderungen
                    berücksichtigt werden, was uns beim Programmieren manchmal vor echte Herausforderungen stellen kann: 🤤
                </p>

                <h5 class="dhbw-lightblue">Optimale Ressourcennutzung</h5>
                <p>
                    Jeder einzelne Computer eines verteilten Systems stellt Ressourcen wie Rechenleistung oder Speicherkapazität
                    zur Verfügung. Diese sollen effizient genutzt werden können, um somit die Gesamtleistung des Systems zu steigern.
                    Hardwareseitig muss das System daher möglichst wenig Ressourcen für sich beanspruchen und softwareseitig muss man
                    darauf achten, diese intelligent zu nutzen.
                </p>

                <h5 class="dhbw-lightblue">Einfache Skalierbarkeit</h5>
                <p>
                    Ein System, das mit kleinen Anforderungen heute beginnt, kann morgen schon riesengroß sein. Es muss daher einfach möglich
                    sein, die Leistung des Systems zu erhöhen oder diese zu reduzieren, wenn sie nicht mehr benötigt wird. Im einfachsten
                    Fall bedeutet das, dass man einen schwachen Rechner einfach durch ein leistungsfähigeres Modell ersetzen kann (vertikale
                    Skalierung). Zusätzlich sollte es aber auch einfach möglich sein, einen weiteren Rechner hinzuzufügen, ohne an den anderen
                    etwas ändern zu müssen (horizontale Skalierung).
                </p>

                <h5 class="dhbw-lightblue">Einfache Erweiterbarkeit</h5>
                <p>
                    Veränderung ist die einzige Konstante in der Informatik! Anforderungen können sich jederzeit ändern und tun dies auch,
                    weshalb agile Entwicklungsmethoden heute in fast allen Bereichen bevorzugt werden. Doch wer wirklich agil sein will,
                    braucht eine Architektur, die Veränderungen zulässt und sie nicht erschwert. Hardware und Software müssen daher immer
                    so gestaltet werden, dass jeder Bestandteil jederzeit ausgetauscht oder weiterentwickelt werden kann, ohne gleich alles
                    auseinander nehmen zu müssen. Bezogen auf den Code sollte man also keinen Spaghetticode hinlegen und auch keine Lasagnencode
                    (Schichten über Schichten, die sich stapeln). Der Code sollte mehr wie Tortellini sein: Viele, kleine Module, die nur sehr
                    lose miteinander verbunden sind.
                </p>

                <h5 class="dhbw-lightblue">Stabilität und Fehlertoleranz</h5>
                <p>
                    Das schlimmste was einem Programm passieren kann ist ein Absturz. 🗯️ Dieser GAU sollten daher immer vermieden werden, auch
                    wenn davon nur ein Teil einer verteilten Anwendung betroffen ist. Dummerweise bringen verteilte Anwendungen eine ganze
                    Reihe weiterer Fehlerquellen mit sich, die man ebenfalls berücksichtigen muss:
                </p>
                <ul>
                    <li>
                        Manchmal streikt das Netzwerk.
                    </li>
                    <li>
                        Ein anderes mal funktioniert es zwar, ist aber saulangsam.
                    </li>
                    <li>
                        Oder ein Programm auf einem anderen Rechner wurde vergessen zu starten.
                    </li>
                    <li>
                        Oder die Putzfrau hat den Stecker gezogen, um den Serverraum zu saugen. 🤦
                    </li>
                    <li>
                        Oder die Schnittstelle eines entfernten Programms hat sich verändert.
                    </li>
                </ul>
                <p>
                    Fehlerquellen gibt es also mehr als genug! Und das sind nur die technischen Fehler, die sich aus der Verteilung ergeben
                    können. Hinzu kommen natürlich noch all die fachlichen Fehler wie Fehleingaben vom Benutzer, ein nicht gedecktes Konto
                    eines Kunden, fehlende Ware im Lager und so weiter. Der Umgang mit Fehlern ist daher sehr wichtig, weshalb sich in der
                    Praxis folgende Strategien entwickelt haben:
                </p>
                <dl>
                    <dt>Fehler vermeiden</dt>
                    <dd>
                        Das ist der oberklügste Vorschlag und doch der nützlichste. Wenn immer es geht, sollte
                        man Fehler gar nicht erst entstehen lassen. Das System sollte daher möglichst selbsterklärend sein und dem Anwender
                        durch ein komfortables UI möglichst viel Hilfestellung bieten. Aber auch auf technischer Seite sollten Stolperfallen
                        vermieden werden und keine unsauberen Lösungen implementiert werden, weil „das ja eh so gut wie nie vorkommen kann”.
                    </dd>

                    <dt>Fehler erkennen</dt>
                    <dd>
                        Natürlich lassen sich Fehler nicht immer vermeiden. In diesem Fall müssen sie aber wenigstens
                        erkannt werden, um darauf reagieren zu können. Dies heist zum Beispiel, dass Benutzereingaben auf Plausiblität geprüft
                        oder empfangene Daten durch Checksummen abgesichert werden.
                    </dd>

                    <dt>Fehler maskieren</dt>
                    <dd>
                        Nicht jeder Fehler ist es wert, dem Anwender damit auf den Keks zu gehen. 🍪 Gerade kleine
                        Fehler lassen sich auch automatisch beheben, indem zum Beispiel nicht empfangene Daten erneut gesendet werden und
                        so weiter.
                    </dd>

                    <dt>Fehler tolerieren</dt>
                    <dd>
                        Manchmal ist Rückzug der beste Angriff. Wenn ein Fehler keine wirkliche Bedeutung hat, kann es auch ganz sinnvoll
                        sein, sich gar nicht erst darum zu kümmern. Das mag zunächst widersprüchlich klingen, ein Beispiel macht es aber
                        deutlich: NoSQL Document Stores wie <a href="http://couchdb.apache.org/" target="_blank"> CouchDB</a> besitzen aus
                        Performancegründen keinen Sperrmechanismus zur Vermeidung zeitgleicher Änderungen. Es kann also durchaus vorkommen,
                        dass ein Anwender die Änderung eines anderen überschreibt, wenn zwischen dem Einlesend und Speichern des Dokuments
                        ein anderer Anwender eine neue Version angelegt hat. Dieser Fehler wird bewusst in Kauf genommen und es wird einfach
                        festgehalten, dass die beiden Dokumentversion in Konflikt zueinander stehen. (Vgl. <a href="#folie-cap">CAP-Theorem</a>)
                    </dd>

                    <dt>Fehler beheben</dt>
                    <dd>
                        Und last but not least: Wann immer ein Fehler festgestellt wird, sollte dieser möglichst ohne manuelle Eingriffe
                        automatisch behoben werden. Beispielsweise, indem verlorene Daten aus einer redundanten Sicherung wiederhergestellt
                        werden, oder ein abgestürzter Rechner durch ein Hot Standby abgelöst wird.
                    </dd>
                </dl>

                <h5 class="dhbw-lightblue">Einfache Nutzung (Transparenz)</h5>
                <p>
                    Dieser Begriff ist sehr wichtig. Die Welt ist schon kompliziert genug, dann müssen es nicht auch noch die IT-Systeme sein.
                    Zumindest für den Anwender sollte die inheränte Komplexität einer verteilten Anwendung verborgen werden. Für den Anwender
                    (und gerne auch den Entwickler) sollte die Anwendung so einfach wie möglich zu benutzen, einrichten und entwickeln sein.
                    Wenn man das schafft, gilt das System als transparent. Denn merke: In der Informatik bedeutet Transparenz nicht, dass man
                    alle Details sehen kann (wie das in der Wirtschaft oft der Fall ist, frag einfach mal deinen Chef 🙉), sondern dass man sich
                    mit den Details gar nicht erst auseinandersetzen muss.
                </p>

                <h5 class="dhbw-lightblue">Sicherheit</h5>
                <p>
                    Ein weiterer wichtiger Aspekt ist die Sicherheit verteilter Systeme. <a href="https://www.youtube.com/watch?v=rXUlmP5MvnE"
                    target="_blank">Denn das Böse ist immer und überall.</a> Folgende Dinge muss eine Anwendung daher immer sicherstellen:
                </p>
                <dl>
                    <dt>Vertraulichkeit</dt>
                    <dd>
                        Die Anwendung muss eine Benutzer- und Rechteverwaltung besitzen, so dass unbefugte Dritte keine Zugriff auf
                        sensitive Informationen bekommen. Sensible Informationen sollten zustäzlich verschlüsselt werden.
                    </dd>

                    <dt>Integrität</dt>
                    <dd>
                        Die Anwendung muss sicherstellen, dass die in ihr gespeicherten Daten nicht verfälscht werden können.
                        Oder falls sich dies nicht verhindern lässt (zum Beispiel während der Übertragung über das Internet),
                        muss es zumindest möglich sein, die Manipulation aufzudecken. Public-Key-Verfahren und Signaturen
                        können dies sicherstellen.
                    </dd>

                    <dt>Authentizität</dt>
                    <dd>
                        Aus Sicht der Anwendung muss es möglich sein, die Identitiät eines Benutzers überrpüfen und auch nachweisen
                        zu können. (Ist das wirklich der Benutzer, für den er sich ausgibt?) Aus Benutzersicht muss es umgekehrt
                        auch möglich sein, die Authentizität der Gegenseite zu überprfen.
                    </dd>
                </dl>
            </aside>
        </section>

        <section>
            <h1>Die acht Arten der Transparenz</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    Auf der letzten Folie hatten wir ja schon erklärt, was Transparenz in der Informatik bedeutet. Doch damit
                    ist nicht nur Anwenderfreundlichkeit gemeint. Viel mehr geht es darum, dass sich eine verteilte Anwendung
                    auch in folgenden Dingen völlig unkompliziert verhält, damit es von Anwendern und Entwicklern möglichst
                    als Ganzes und nicht als Sammlung unabhängiger Einzelteile wahrgenommen werden kann.¹
                </p>
                <p>
                    <small>
                        ¹ Das ist es, was Andrew Tanenbaum mit „eine Kollektion von Computern, die dem Anwender wie
                        ein einzelner Computer erscheinen” meint.
                    </small>
                </p>

                <h5 class="dhbw-lightblue">Zugriffstransparenz</h5>
                <p>
                    Der Zugriff auf lokale und entfernte Ressourcen sollte mit identischen Operationen erfolgen, so dass
                    man nicht zwischen ihnen unterscheiden muss.
                </p>

                <h5 class="dhbw-lightblue">Positionstransparenz</h5>
                <p>
                    Auch Ortstransparenz genannt. Idealerweise muss man überhaupt nicht wissen, wo eine Ressource sich
                    befindet, um auf sie zugreifen zu können. Nimm zum Beispiel eine Webseite. Du gibst
                    <a href="https://www.dhbw-karlsruhe.de">www.dhbw-karlsruhe.de</a> in den Browser ein und schon
                    erscheint die Seite unserer Hochschule. Du musst dafür nicht wissen, auf welchem Rechner mit welcher
                    IP-Adresse die Seite gespeichert ist. Der symbolische Name reicht völlig aus.
                </p>

                <h5 class="dhbw-lightblue">Mobilitätstransparenz</h5>
                <p>
                    Und da kommen wir auch schon zur Mobilitätstransparenz. Wenn du nicht wissen musst, wo eine Ressource
                    sich befindet, um sie nutzen zu können, sollte es auch möglich sein, die Ressource jederzeit zu verschieben.
                    Die gesamte Anwendung muss dann einfach wie gehabt weiter funktionieren, ohne dass sie angepasst werden
                    muss. Konkret bedeutet das zum Beispiel, dass Servernamen und Adressen nicht hartcodiert sondern in einer
                    Konfigurationsdatei oder einem Namensdienst nachgeschlagen werden sollten.
                </p>

                <h5 class="dhbw-lightblue">Nebenläufigkeitstransparenz</h5>
                <p>
                    Das wäre natürlich schon ganz praktisch, wenn ein verteiltes System wirklich nebenläufig wäre. 😅
                    Nur sollten die Programme und Algorithmen damit auch umgehen können. Beispielsweise darf es keine
                    <a href="https://de.wikipedia.org/wiki/Race_Condition" target="_blank">Race Conditions</a> oder
                    <a href="https://de.wikipedia.org/wiki/Deadlock_(Informatik)">Deadlocks</a> geben, die zu sporadischen
                    Fehlern führen.
                </p>

                <h5 class="dhbw-lightblue">Replikationstransparenz</h5>
                <p>
                    Verteilte Anwendungen arbeiten oft auch mit verteilten Datenbeständen. Aus Gründen der Ausfallsicherheit
                    sollte es dabei möglich sein, mehrere Repliken aller Daten auf unterschiedlichen Computern vorzuhalten.
                    Das System muss dann so intelligent sein, dass die Benutzer auf unterschiedlichen, möglichst synchronen
                    Repliken arbeiten können, ohne davon beeinträchtigt zu werden.
                </p>

                <h5 class="dhbw-lightblue">Fehlertransparenz</h5>
                <p>
                    Dieses Thema haben wir in der letzten Folie schon ein wenig gestreift. Hierunter sind die Strategien zum
                    Umgang mit Fehlern gemeint, so dass ein Fehler nicht die gesamte Anwendung zum Absturz bringt.
                </p>

                <h5 class="dhbw-lightblue">Leistungstransparenz</h5>
                <p>
                    Damit ist gemeint, dass System und Anwendungen prinzipiell skalierbar sind, um erhöhten Leistungsanforderungen
                    genügen zu können. Ob die Skalierung dabei wie in einer Cloud automatisch erfolgt oder von Hand durchgeführt
                    werden muss, ist dafür unbedeutend. Wichtig ist nur, dass es möglich ist.
                </p>

                <h5 class="dhbw-lightblue">Skalierbarkeitstransparenz</h5>
                <p>
                    Auf den ersten Blick klingt das redundant zur Leistungstransparenz. Dies ist aber mitnichten der Fall. Viel
                    mehr geht es hier darum, dass eine Skalierung vorgenommen werden kann, ohne die Systemstruktur oder den
                    Quellcode der Anwendung anpassen zu müssen. Beispielsweise sollten keine wilkürlichen Obergrenzen hart im
                    Quellcode hinterlegt sein und die Teilprogramme müssen so programmiert sein, dass sie mit jeder beliebigen
                    Datenmenge zurecht kommen.
                </p>
            </aside>
        </section>

        <section id="folie-cap">
            <h1>Das CAP-Theorem verteilter Anwendungen</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    In der Datenbankvorlesung haben wir alle mal gelernt, normalisierte Datenmodelle zu erstellen und Transaktionen
                    zu nutzen, damit unsere Daten immer konsistent und widerspruchsfrei sind. <span style="color: darkgreen">✔️</span>
                    Und in vielen Fällen will man das auch genauso haben. Doch eine zu einseitige Fixierung auf die Konsistenz kann zu
                    bedeutenden Nachteilen in anderen Punkten führen, wie das im Jahr 2000 formulierte und 2002 bewiesene CAP-Theorem
                    besagt. Denn aus ihm folgt, dass eine verteilte Anwendung niemals alle drei der folgenden Eigenschaften gleichzeitig
                    erfüllen kann:
                </p>
                <ul>
                    <li>
                        <b>Consistency (Konsistenz):</b> Betrachtet man nur eine einzelne Datenbank auf einem einzelnen Rechner, gibt
                        es hier noch keine Probleme. Doch wenn die Daten auf mehrere Rechner repliziert werden, kann es für einen kurzen
                        Zeitpunkt zu lokalen Unterschieden kommen, so lange die neusten Änderungen noch nicht an alle Rechner weiter
                        verteilt wurden. Nur durch eine verteilte Transaktion, die erst abgeschlossen ist, wenn alle Änderungen auf allen
                        Rechnern nachgezogen wurden, lässt sich eine solche Konsistenz erzielen.
                    </li>
                    <li>
                        <b>Availability (Verfügbarkeit):</b> Hiermit ist sowohl die generelle Verfügbarkeit im Sinne, dass das System
                        überhaupt erreichbar ist gemeint, als auch die maximal zulässige Antwortzeit. Beispielsweise kann es vorkommen,
                        dass das System während einer aktiven, verteilten Transaktionen alle weiteren Anfragen auf denselben Datenbestand
                        ablehnt oder so lange warten lässt, bis die Transaktion abgeschlossen ist. Geht die Transaktion zu lange, weil
                        besonders viele Daten geschrieben werden oder weil ein Deadlock aufgetreten ist, kann das System nicht mehr
                        hinreichend schnell auf die anderen Anfragen reagieren.
                    </li>
                    <li>
                        <b>Partition Tolerance (Partitionstoleranz):</b> Zunächst würde man denken, damit sie die horizontale oder
                        vertikale Partitionierung von Daten auf einzelne Rechnerknoten gemeint. Dem ist aber nicht so. Stattdessen
                        geht es eher darum, dass ein verteiltes System auch dann noch weiter arbeiten kann, wenn ein Teil seiner
                        Rechner ausgefallen ist. Es kann sozusagen auch ein kleiner Teil (eine Partition) des Systems noch autonom
                        weiter arbeiten.
                    </li>
                </ul>
                <p>
                    Das CAP-Theorem besagt, dass ein verteiltes System oder eine verteilte Anwendung immer nur zwei dieser Kriterien,
                    niemals aber alle drei gleichzeitig erfüllen kann, weshalb es auch gerne als Dreieck ⚠️ dargestellt wird. Eine
                    Verbesserung in einem der drei Bereiche führt also unweigerlich zu einer Verschlechterung in einem der anderen
                    beiden. <span style="color: deepskyblue;">⬆️</span><span style="color: crimson;">⬇️</span>
                </p>
                <p>
                    Ein Beispiel hierfür haben wir schon bei den NoSQL-Datenbanken gesehen, wo die Konsistenz oft zu Gunsten der
                    Verfügbarkeit getauscht wird. Anstatt auf das Ende einer Transaktion zu warten, werden mögliche Konflikte
                    einfach nur erkannt und es wird auch in Kauf genommen, dass ein Client eine Änderung nicht sofort sieht, auch
                    wenn der Schreibvorgang bereits abgeschlossen wurde. Die Datenbank ist dann nur noch eventuell-konsistent, was
                    aber für fast alle Anwendungsfälle vollkommen in Ordnung ist. Denn es gibt sogar Autoren, die argumentieren,
                    dass echte, transaktionale Konsistenz absoluter Unsinn sei, da es diese im echten Leben auch nicht gäbe und dort
                    alle Vorgänge nur eventuell-konsistent sein. 🤔
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 1: Ein kleines Verteilte-Systeme-Quiz</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <!--
            MIDDLEWARE
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Middleware</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Von Clients, Servern und Peers</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section>
            <h1>Aufgaben einer Middleware</h1>
            <article>
                …
                <!-- Hier auch Transparenzarten behandeln -->
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section>
            <h1>Ganz am Anfang: Programmieren ohne Middleware</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section>
            <h1>Erste kommunikationsorientierte Middlewares</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section>
            <h1>Moderne Applikationsserver für große Anwendungen</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section>
            <h1>Weitere reelvante Middlewarearten</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 2: Ein kleines Middleware-Quiz</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <!--
            ARCHITEKTURMUSTER
        -->
        <section data-chapter data-background-image="../../trennfolie.jpg">
            <h1>Architekturmuster</h1>
            <article>
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://pixabay.com/en/adult-break-business-caucasian-2398561/" target="_blank">Pixabay: rawpixel</a>
                    </small>
                </small>
            </article>
        </section>

        <section>
            <h1>Einfache Client/Server-Anwendungen</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section>
            <h1>Drei Schichten oder mehr</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section>
            <h1>Vorgeschalteter Proxyserver</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section>
            <h1>Getrennt entwickelte Microservices</h1>
            <article>
                …
                <!-- Tabreiter: Auf Basis RPC / Auf Basis Publish/Subscribe -->
                <!-- Auf der Folie nur Abbildungen und wenige Stichworte -->
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <section data-background-color="rgb(231, 221, 141)">
            <h1>Aufgabe 3: Architekturmuster bewerten</h1>
            <article>
                …
            </article>
            <aside>
                <p>
                    …
                </p>
            </aside>
        </section>

        <!--
            RECHTSHINWEISE
        -->
        <section data-chapter data-background-color="rgb(158, 203, 231)">
            <h1>Rechtshinweise</h1>
            <article>
                <h4>Creative Commons Namensnennung 4.0 International</h4>
                <ul>
                    <li>Beliebiges Teilen ist erlaubt</li>
                    <li>Die Unterlagen dürfen bearbeitet und verändert werden</li>
                    <li>Wenn die Namens- und Urheberangaben erhalten bleiben</li>
                    <li>Und keine weiteren Einschränkungen auferlegt werden</li>
                </ul>
                <span style="font-size: 400px; color: white;" class="dhbw-text-shadow" >§</span>
            </article>
            <aside style="font-size: 80%">
                <h4>Kontaktdaten</h4>
                <p>
                    Dennis Schulmeister-Zimolong<br/>
                    E-Mail: <a data-email-address>dhbw windows3.de</a><br/>
                </p>

                <h4>Urheberrecht und Lizenzvereinbarung</h4>
                <p>
                    © 2018 Dennis Schulmeister-Zimolong <br/>
                    <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-folien" target="_blank">https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-folien</a>
                </p>
                <img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Lizenzvertrag" />
                <p>
                    Das Werk <i>Vorlesung "Verteilte Systeme" im Studiengang Wirtschaftsinformatik
                    an der DHBW Karlsruhe</i> von <a href="http://www.windows3.de" target="_blank">Dennis Schulmeister-Zimolong</a>
                    ist lizenziert unter <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank"><i>Creative Commons
                    Namensnennung 4.0 International</i></a>.
                </p>
                <p>
                    Du darfst:
                </p>
                <ul>
                    <li>
                        <b>Teilen</b> — das Material in jedwedem Format oder Medium vervielfältigen
                        und weiterverbreiten
                    </li>
                    <li>
                        <b>Bearbeiten</b> — das Material remixen, verändern und darauf aufbauen
                        und zwar für beliebige Zwecke, sogar kommerziell.
                    </li>
                </ul>
                <p>
                    Unter folgenden Bedingungen:
                </p>
                <ul>
                    <li>
                        <b>Namensnennung</b> — Du musst angemessene Urheber- und Rechteangaben
                        machen, einen Link zur Lizenz beifügen und angeben, ob Änderungen
                        vorgenommen wurden. Diese Angaben dürfen in jeder angemessenen Art
                        und Weise gemacht werden, allerdings nicht so, dass der Eindruck
                        entsteht, der Lizenzgeber unterstütze gerade dich oder deine Nutzung
                        besonders.
                    </li>
                    <li>
                        <b>Keine weiteren Einschränkungen</b> — Du darfst keine zusätzlichen Klauseln
                        oder technische Verfahren einsetzen, die anderen rechtlich irgendetwas
                        untersagen, was die Lizenz erlaubt.
                    </li>
                </ul>
                <p>
                    Es werden keine Garantien gegeben und auch keine Gewähr geleistet.
                    Die Lizenz verschafft dir möglicherweise nicht alle Erlaubnisse,
                    die du für die jeweilige Nutzung brauchst. Es können beispielsweise
                    andere Rechte wie Persönlichkeits- und Datenschutzrechte zu beachten
                    sein, die deine Nutzung des Materials entsprechend beschränken.
                </p>
            </aside>
        </section>
    </body>
</html>
